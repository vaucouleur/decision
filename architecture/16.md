Here’s the **third example** that explicitly shows **UF theory propagation** (not just conflict), without changing your engine at all: we wrap the UF theory in a tiny `LoggingTheory` decorator that prints every propagation/conflict UF produces.

The trick formula is:

* `a = b ∧ ( (f(a) = f(b)) ∨ r )`

SAT can satisfy this by setting `r = true` and never “needing” `f(a)=f(b)`.
But UF will still deduce by congruence that `f(a)=f(b)` and **propagate** it (with an explanation).

---

## 1) Add a `LoggingTheory` wrapper (in the demo)

### `crates/smt-demo/src/main.rs` (add near the top)

```rust
use smt_engine::theory::{Theory, TheoryConflict, TheoryPropagation};

/// Simple decorator that logs theory propagations/conflicts.
struct LoggingTheory<T: Theory> {
    inner: T,
}

impl<T: Theory> LoggingTheory<T> {
    fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T: Theory> Theory for LoggingTheory<T> {
    fn name(&self) -> &'static str {
        self.inner.name()
    }

    fn push(&mut self) {
        self.inner.push();
    }

    fn pop(&mut self, n: usize) {
        self.inner.pop(n);
    }

    fn on_atom_assigned(&mut self, atom_term: smt_core::TermId, value: bool) {
        // You can uncomment this if you also want assignment logging:
        // println!("[{}] atom assigned: term={:?} value={}", self.name(), atom_term, value);
        self.inner.on_atom_assigned(atom_term, value);
    }

    fn propagate(&mut self) -> Result<Vec<TheoryPropagation>, TheoryConflict> {
        match self.inner.propagate() {
            Ok(props) => {
                for p in &props {
                    println!(
                        "[{}] propagate: implied={:?} explain={:?}",
                        self.name(),
                        p.implied,
                        p.explain
                    );
                }
                Ok(props)
            }
            Err(conf) => {
                println!(
                    "[{}] conflict: explain={:?}",
                    self.name(),
                    conf.explain
                );
                Err(conf)
            }
        }
    }
}
```

This prints exactly what UF is telling the engine:

* implied SAT literal
* explanation literals (the reason clause antecedents)

---

## 2) Add the propagation instance builder

### `crates/smt-demo/src/main.rs` (add this helper)

```rust
/// Build formula: (and (= a b) (or (= (f a) (f b)) r))
///
/// Returns (root, atom_term_id_for_eq_fafb) so the demo can reference it if desired.
fn mk_propagation_formula(
    ctx: &mut Context,
    u: SortId,
    a: TermId,
    b: TermId,
    f_sym: smt_core::SymbolId,
) -> (BoolTerm, TermId) {
    let fa = mk_f_app(ctx, f_sym, a, u);
    let fb = mk_f_app(ctx, f_sym, b, u);

    let eq_ab = ctx.eq(a, b).expect("eq");
    let eq_fafb = ctx.eq(fa, fb).expect("eq"); // UF atom we expect UF to propagate to true

    let r = ctx.mk_bool_var("r");              // unconstrained boolean

    let disj = ctx.or([eq_fafb, r]).expect("or");
    let root = ctx.and([eq_ab, disj]).expect("and");

    (root, eq_fafb.id())
}
```

---

## 3) Wrap UF theory with `LoggingTheory` in `solve_with_uf`

### `crates/smt-demo/src/main.rs` (patch your `solve_with_uf`)

Find:

```rust
let mut uf = UfTheory::new(ctx.clone(), uf_id);
```

Replace with:

```rust
let uf_inner = UfTheory::new(ctx.clone(), uf_id);
let mut uf = LoggingTheory::new(uf_inner);
```

Then when you build the engine, you still do:

```rust
let mut engine = CdcltEngine::new(sat, prop.atoms, vec![Box::new(uf)]);
```

Everything else stays the same.

---

## 4) Add the third demo case

### `crates/smt-demo/src/main.rs` (add in `main()`)

Add this block between your UNSAT and SAT demos (or after them):

```rust
    // ---------- PROPAGATION demo ----------
    {
        let mut ctx = Context::default();
        let (u, a, b, _c, f_sym) = build_uf_terms(&mut ctx);

        let (root, atom_term) = mk_propagation_formula(&mut ctx, u, a, b, f_sym);

        println!("PROP instance: {}", ctx.pretty_term(root.id()));
        println!("(Expect UF to propagate (= (f a) (f b)) true due to a=b)\n");

        let res = solve_with_uf(Arc::new(ctx), root)?;
        println!("Result: {:?}\n", res);
        assert_eq!(res, SolveResult::Sat);

        // Note: the LoggingTheory wrapper prints the propagation lines during solving.
        // That’s the “proof” that UF produced a propagation, regardless of SAT decisions.
        let _ = atom_term; // kept if you want to inspect the specific atom later
    }
```

When you run:

```bash
cargo run -p smt-demo
```

You should see an output line like:

```
[UF] propagate: implied=vN explain=[vM]
```

Interpretation:

* `implied=vN` corresponds to the atom `(= (f a) (f b))`
* `explain=[vM]` corresponds to `(= a b)` (the reason)

(Exact literal names vary, but the shape is what matters.)

---

## Why this demo is “real CDCL(T) behavior”

* UF sees `a=b` is assigned true
* by congruence, UF merges `f(a)` and `f(b)`
* that makes the equality atom `(= f(a) f(b))` logically implied
* UF returns a propagation with explanation `[ (= a b) ]`
* engine translates it into a SAT lemma `(! (=a b) ∨ (=f(a) f(b)))` (guarded if you use activations)

So you’re already using the standard SMT contract: **theory → SAT via explained implications**.

If you say **yes** again, I’ll add a second propagation demo that shows **negative information**: UF derives a **conflict** from a propagated equality + an asserted disequality, and the explanation clause is printed (great sanity check for explanations).
