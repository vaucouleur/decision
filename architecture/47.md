Here’s a clean **bundle-on-failure** pattern that keeps your test output quiet unless something goes wrong, and when it does, it automatically enables the UNSAT bundle (or extra logs) and re-runs the check to capture artifacts.

Since your engine writes bundles **only when debug is enabled**, we do:

1. run normally (debug off)
2. if result mismatches expectation, enable debug toggle
3. re-run the same instance (fresh session) to force writing `target/smt-debug-.../`

This avoids paying the debug overhead on passing tests.

---

## 1) Test helper: `assert_sat_result_with_bundle_on_mismatch`

### `crates/smt-tests/src/bundle_on_failure.rs`

```rust
#![forbid(unsafe_code)]

use smt_api::{CheckSat, Session};
use smt_engine::test_debug;

/// Expected SAT result for a test instance.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Expect {
    Sat,
    Unsat,
}

/// Run `setup(sess)` then `check_sat()`, assert it matches `expect`.
///
/// If it mismatches:
/// - enables eq-sharing debug bundle globally
/// - rebuilds a fresh session via `make_sess()`
/// - re-runs the same setup and check to force writing target/smt-debug-<pid>/...
pub fn assert_sat_with_bundle_on_mismatch<FMake, FSetup>(
    mut make_sess: FMake,
    setup: FSetup,
    expect: Expect,
) -> smt_core::Result<()>
where
    FMake: FnMut() -> Session,
    FSetup: Fn(&mut Session) -> smt_core::Result<()>,
{
    // First run: debug off
    test_debug::set_eqshare_debug_enabled(false);
    let mut sess = make_sess();
    setup(&mut sess)?;
    let got = sess.check_sat();

    let ok = match (expect, got) {
        (Expect::Sat, CheckSat::Sat) => true,
        (Expect::Unsat, CheckSat::Unsat) => true,
        _ => false,
    };

    if ok {
        return Ok(());
    }

    // Mismatch => rerun with debug enabled to write bundle
    test_debug::set_eqshare_debug_enabled(true);

    let mut sess2 = make_sess();
    setup(&mut sess2)?;
    let got2 = sess2.check_sat();

    // Keep debug enabled only for this failure path; restore off afterwards.
    test_debug::set_eqshare_debug_enabled(false);

    // Use the first run's mismatch as the assertion message, but include rerun result too.
    panic!(
        "check_sat mismatch: expected {:?}, got {:?}; rerun-with-debug got {:?}. \
         If UNSAT, see target/smt-debug-<pid>/ for eqshare.dot + conflict.dot.",
        expect, got, got2
    );
}
```

---

## 2) Use it in your matrix tests

Example: ping-pong “both enabled must be UNSAT”; all other configs must be SAT.

### `crates/smt-tests/src/equality_sharing_matrix.rs` (snippet)

```rust
use smt_engine::config::SharingConfig;
use crate::bundle_on_failure::{assert_sat_with_bundle_on_mismatch, Expect};

#[test]
fn ping_pong_regression_matrix() -> smt_core::Result<()> {
    // none => SAT
    assert_sat_with_bundle_on_mismatch(
        || common::make_session(SharingConfig { uf_to_dl: false, dl_to_uf: false }),
        setup_ping_pong_instance,
        Expect::Sat,
    )?;

    // only UF->DL => SAT
    assert_sat_with_bundle_on_mismatch(
        || common::make_session(SharingConfig { uf_to_dl: true, dl_to_uf: false }),
        setup_ping_pong_instance,
        Expect::Sat,
    )?;

    // only DL->UF => SAT
    assert_sat_with_bundle_on_mismatch(
        || common::make_session(SharingConfig { uf_to_dl: false, dl_to_uf: true }),
        setup_ping_pong_instance,
        Expect::Sat,
    )?;

    // both => UNSAT
    assert_sat_with_bundle_on_mismatch(
        || common::make_session(SharingConfig { uf_to_dl: true, dl_to_uf: true }),
        setup_ping_pong_instance,
        Expect::Unsat,
    )?;

    Ok(())
}
```

This way:

* when everything is correct, no bundles are generated
* if something breaks, you get the bundle automatically

---

## 3) Make bundles unique to avoid overwrite

Update your bundle directory name to include PID + epoch:

```rust
let pid = std::process::id();
let dir = Path::new("target").join(format!("smt-debug-{}-{}", pid, engine.export_epoch));
```

Then a failing rerun won’t overwrite.

---

## 4) Optional: bundle only on “unexpected SAT” or only on “unexpected UNSAT”

If you only care about missing UNSAT (i.e., it became SAT), you can restrict the rerun to that case.

But the generic helper above is usually fine.

---

If you want, I can also add a helper `assert_unsat_core_contains_any(...)` that only runs `get_unsat_core()` when UNSAT and checks a minimal label set—also with bundle-on-failure rerun.
