Here’s the **test-local “enable debug” guard** approach that works even when you run the *entire* test suite (no argv/env filtering needed). It uses a **global atomic** that your `make_session()` consults.

This is the nicest ergonomically: each test can do `let _dbg = EnableEqShareDebug::new();` and only that test will emit the bundle.

---

## 1) Test-only global toggle + RAII guard

### `crates/smt-tests/src/test_debug_guard.rs`

````rust
#![forbid(unsafe_code)]

use std::sync::atomic::{AtomicBool, Ordering};

/// Global flag: when true, sessions created by tests should enable eq-sharing debug output.
///
/// This is test-only state. It is intentionally process-wide.
static EQSHARE_DEBUG_ENABLED: AtomicBool = AtomicBool::new(false);

/// RAII guard that enables eq-sharing debug for the lifetime of the guard.
///
/// Usage:
/// ```
/// #[test]
/// fn ping_pong_regression_matrix() {
///     let _dbg = EnableEqShareDebug::new();
///     // build session; if UNSAT, it will write target/smt-debug-<pid>/...
/// }
/// ```
///
/// Note: if tests run in parallel within the same process, this is a global toggle.
/// If you want strict isolation, run these tests with `-- --test-threads=1` or
/// prefer the env/argv filtering method.
pub struct EnableEqShareDebug {
    prev: bool,
}

impl EnableEqShareDebug {
    /// Enable eq-sharing debug output for this test.
    pub fn new() -> Self {
        let prev = EQSHARE_DEBUG_ENABLED.swap(true, Ordering::SeqCst);
        Self { prev }
    }
}

/// Check whether debug is enabled for sessions created by tests.
pub fn eqshare_debug_enabled() -> bool {
    EQSHARE_DEBUG_ENABLED.load(Ordering::SeqCst)
}

impl Drop for EnableEqShareDebug {
    fn drop(&mut self) {
        EQSHARE_DEBUG_ENABLED.store(self.prev, Ordering::SeqCst);
    }
}
````

---

## 2) Wire it into `make_session(...)`

### `crates/smt-tests/src/common.rs`

```rust
mod test_debug_guard;

pub fn make_session(sharing: SharingConfig) -> Session {
    // ... build ctx, theories, atoms, sat, engine ...

    let mut eng = SmtEngine::new(sat, atoms, vec![Box::new(uf), Box::new(dl)]);
    eng.sharing = sharing;

    if test_debug_guard::eqshare_debug_enabled() {
        eng.config.debug_eq.enabled = true;
        eng.config.debug_eq.max_reason_lits = 16;
    }

    // ...
    Session::new(ctx, eng, classifier)
}
```

---

## 3) Use it in the three matrix tests

### `crates/smt-tests/src/equality_sharing_matrix.rs`

```rust
use crate::test_debug_guard::EnableEqShareDebug;

#[test]
fn ping_pong_regression_matrix() -> smt_core::Result<()> {
    let _dbg = EnableEqShareDebug::new(); // only this test emits debug artifacts
    // ... your existing matrix test ...
    Ok(())
}
```

Do the same for the other two tests if you want.

---

## 4) Two practical notes

* If you run tests in parallel **within one process**, the toggle is global, so another test *could* create a session while it’s enabled. For these 3 heavy combo tests, it’s reasonable to run them single-threaded:

```bash
cargo test -p smt-tests equality_sharing_matrix -- --nocapture --test-threads=1
```

* If you want concurrency safety without forcing single-thread, use the env/argv filter (previous approach) or make the debug-bundle writing include a unique subfolder per PID+thread.

---

If you want, I can give you a tiny `#[cfg(test)]` integration on the engine side so this guard also works for engine unit tests outside `smt-tests` (same toggle, different crate boundary).
