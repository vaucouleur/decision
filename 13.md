Below is a **clean CDCL(T) loop** that assumes:

* the SAT component (“kernel”) already implements CDCL learning/backjump internally (like your `ToyCdcl` now does),
* but it also exposes a few extra hooks so the SMT engine can:

  * add a clause and get its index (`add_clause_return_index`)
  * enqueue with an explicit reason clause index
  * advance propagation / query trail deltas

This lets the SMT engine stay *thin*: it does **theory reasoning + lemma injection**, while SAT does **CDCL**.

I’ll show:

1. the minimal extra SAT-kernel API you need
2. the engine loop with activation literals + push/pop discipline
3. how to map `push/pop` to SAT levels safely

---

# 1) Minimal SAT kernel API for CDCL(T)

### `crates/smt-sat/src/kernel.rs` (augment)

```rust
use crate::{Clause, Lit, SatStats, Var};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LBool { True, False, Undef }

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Conflict { pub clause: usize }

/// A CDCL kernel driven by the SMT engine.
pub trait SatKernel {
    fn reserve_vars(&mut self, num_vars: u32);

    /// Add a clause and return its stable index (needed for reasons).
    fn add_clause_return_index(&mut self, clause: Clause) -> usize;

    /// Convenience: add clause ignoring index.
    #[inline]
    fn add_clause(&mut self, clause: Clause) {
        let _ = self.add_clause_return_index(clause);
    }

    fn new_decision_level(&mut self);
    fn backtrack(&mut self, level: usize);
    fn decision_level(&self) -> usize;

    /// Enqueue lit with explicit reason clause.
    fn enqueue(&mut self, lit: Lit, reason: Option<usize>) -> bool;

    /// Propagate (kernel may learn/backjump internally and return OK until fixpoint).
    ///
    /// If it returns Err, it means “global UNSAT at level 0”.
    fn propagate(&mut self) -> Result<(), Conflict>;

    fn value_var(&self, var: Var) -> LBool;
    fn value_lit(&self, lit: Lit) -> LBool;

    /// Trail access (ordered assignments).
    fn trail(&self) -> &[Lit];

    /// Return the index in `trail()` where new assignments begin since last call.
    ///
    /// This is a very convenient pattern for theory notification.
    fn trail_head(&self) -> usize;

    /// Advance the trail head to the current end (engine calls after processing).
    fn set_trail_head(&mut self, new_head: usize);

    fn stats(&self) -> SatStats;

    /// Decision helper (kernel owns heuristics).
    /// Returns `None` if fully assigned.
    fn pick_branch_lit(&self) -> Option<Lit>;

    /// Optional: create a fresh variable (so engine can allocate activation literals).
    fn fresh_var(&mut self) -> Var;
}
```

**In `ToyCdcl`:**

* `add_clause_return_index` = `add_clause_internal` returning `cidx`
* `trail_head / set_trail_head` = store a `notify_head` in the kernel (or expose qhead-like)
* `fresh_var` = reserve_vars(num_vars+1) + return new Var
* `pick_branch_lit` already exists (VSIDS-lite in your previous step)

---

# 2) Activation literals for scoped theory lemmas

**Why:** theory lemmas should be backtrackable across `push/pop` (or across “calls” to solve in incremental mode). Instead of deleting clauses, guard them:

* lemma `L` becomes `(¬act ∨ L)`
* at the scope where you created it, you assume `act = true`
* when popping scope, you stop assuming that activation literal

This is the standard trick used by real SMT solvers.

---

# 3) Engine state and push/pop mapping

We maintain:

* `scope_acts: Vec<Vec<Lit>>` activation literals created at each scope
* `scope_sat_level: Vec<usize>` the SAT decision level at scope boundaries (optional but handy)
* `theories: Vec<Box<dyn Theory>>` each theory also has `push/pop`

### `crates/smt-engine/src/cdclt.rs`

```rust
use smt_sat::kernel::{LBool, SatKernel};
use smt_sat::{Clause, Lit, Var};

use crate::atoms::{AtomTable};
use crate::engine_ctx::{conflict_clause, guarded_lemma, implication_clause};
use crate::theory::{Theory, TheoryConflict, TheoryPropagation};

/// Solver outcome.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SolveResult { Sat, Unsat }

/// CDCL(T) engine driven by a SAT kernel that already does CDCL learning.
pub struct CdcltEngine<K: SatKernel> {
    sat: K,
    atoms: AtomTable,
    theories: Vec<Box<dyn Theory>>,

    /// Activation literals created per scope level.
    scope_acts: Vec<Vec<Lit>>,
    /// SAT decision level snapshot per scope (for predictable backtracking).
    scope_sat_level: Vec<usize>,
}

impl<K: SatKernel> CdcltEngine<K> {
    pub fn new(sat: K, atoms: AtomTable, theories: Vec<Box<dyn Theory>>) -> Self {
        Self {
            sat,
            atoms,
            theories,
            scope_acts: vec![Vec::new()],     // base scope
            scope_sat_level: vec![0],         // base at level 0
        }
    }

    /// Add a base CNF clause (from Tseitin, etc.). Permanent.
    pub fn add_base_clause(&mut self, c: Clause) {
        self.sat.add_clause(c);
    }

    /// SMT push: create a new scope.
    pub fn push(&mut self) {
        self.scope_acts.push(Vec::new());
        self.scope_sat_level.push(self.sat.decision_level());
        for th in self.theories.iter_mut() {
            th.push();
        }
    }

    /// SMT pop: rollback `n` scopes.
    pub fn pop(&mut self, n: usize) {
        for _ in 0..n {
            if self.scope_acts.len() <= 1 {
                return; // keep base scope
            }
            self.scope_acts.pop();
            let level = self.scope_sat_level.pop().unwrap_or(0);

            // Backtrack SAT to the recorded level
            self.sat.backtrack(level);

            // Pop theories
            for th in self.theories.iter_mut() {
                th.pop(1);
            }
        }
    }

    /// Add a theory lemma guarded by a fresh activation literal in the *current* scope.
    ///
    /// Returns the clause index in SAT.
    fn add_guarded_lemma(&mut self, lemma: Clause) -> usize {
        // Fresh activation var
        let act_var = self.sat.fresh_var();
        let act_lit = Lit::pos(act_var);
        self.scope_acts.last_mut().expect("scope").push(act_lit);

        // Guard it: (¬act ∨ lemma...)
        let guarded = guarded_lemma(act_lit, &lemma);

        self.sat.add_clause_return_index(guarded)
    }

    /// Solve in the current scope.
    ///
    /// The engine:
    /// - asserts all activation literals in current scope stack
    /// - drives SAT propagation
    /// - runs theory propagation to fixpoint, adding guarded lemmas
    /// - lets SAT kernel learn/backjump
    pub fn solve(&mut self) -> SolveResult {
        // Assumptions = all activation lits currently active.
        let assumptions = self.collect_active_activations();

        // Seed assumptions as decisions at a fresh level (typical).
        if !assumptions.is_empty() {
            self.sat.new_decision_level();
            for a in assumptions {
                if !self.sat.enqueue(a, None) {
                    return SolveResult::Unsat;
                }
            }
        }

        loop {
            // SAT propagate (kernel may learn/backjump internally).
            if self.sat.propagate().is_err() {
                return SolveResult::Unsat;
            }

            // Theory fixpoint: may inject lemmas and implied literals.
            if let Err(_unsat) = self.theory_fixpoint() {
                // Theory injected a conflict clause; SAT will now learn/backjump.
                // We just continue the loop; if truly UNSAT it will emerge at level 0.
                continue;
            }

            // If all vars assigned (kernel indicates no branch lit), SAT+theories consistent => SAT.
            if self.sat.pick_branch_lit().is_none() {
                return SolveResult::Sat;
            }

            // Decision
            let d = self.sat.pick_branch_lit().expect("some");
            self.sat.new_decision_level();
            if !self.sat.enqueue(d, None) {
                // Kernel should handle this, but keep safe.
                continue;
            }
        }
    }

    fn collect_active_activations(&self) -> Vec<Lit> {
        let mut out = Vec::new();
        for scope in &self.scope_acts {
            out.extend_from_slice(scope);
        }
        out
    }

    /// Notify theories of new atom assignments + ask for propagations until fixpoint.
    fn theory_fixpoint(&mut self) -> Result<(), ()> {
        // 1) Notify theories about new SAT trail literals that correspond to theory atoms.
        self.notify_theories_new_trail();

        // 2) Repeatedly ask theories for propagations/conflicts; translate to guarded SAT lemmas.
        loop {
            let mut any = false;

            for th in self.theories.iter_mut() {
                match th.propagate() {
                    Ok(props) => {
                        for p in props {
                            any = true;
                            self.apply_theory_propagation(p);
                        }
                    }
                    Err(conf) => {
                        any = true;
                        self.apply_theory_conflict(conf);
                        // A conflict lemma was added; SAT must see it via propagation.
                        return Err(());
                    }
                }
            }

            if !any {
                return Ok(());
            }

            // Let SAT absorb new lemmas & implied enqueues.
            if self.sat.propagate().is_err() {
                return Err(());
            }

            // Notify theories about any newly assigned atoms created by those propagations.
            self.notify_theories_new_trail();
        }
    }

    fn notify_theories_new_trail(&mut self) {
        let trail = self.sat.trail();
        let mut head = self.sat.trail_head();

        while head < trail.len() {
            let lit = trail[head];
            head += 1;

            if let Some(atom) = self.atoms.get(lit.var()) {
                let val = match self.sat.value_lit(lit) {
                    LBool::True => true,
                    LBool::False => false,
                    LBool::Undef => continue,
                };
                self.theories[atom.theory.0].on_atom_assigned(atom.term, val);
            }
        }

        self.sat.set_trail_head(head);
    }

    fn apply_theory_propagation(&mut self, p: TheoryPropagation) {
        // Build lemma: explain => implied
        let lemma = implication_clause(&p.explain, p.implied);

        // Guard it by current scope activation literal
        let cidx = self.add_guarded_lemma(lemma);

        // Best-effort enqueue implied with reason = lemma clause (fast).
        // If it’s already assigned, enqueue() will return true or false appropriately.
        let _ = self.sat.enqueue(p.implied, Some(cidx));
    }

    fn apply_theory_conflict(&mut self, c: TheoryConflict) {
        // lemma: explain => false   i.e., (¬e1 ∨ ¬e2 ∨ ...)
        let lemma = conflict_clause(&c.explain);
        let _cidx = self.add_guarded_lemma(lemma);
    }
}
```

### `guarded_lemma` helper (from earlier)

Put in `engine_ctx.rs`:

```rust
use smt_sat::{Clause, Lit};

pub fn guarded_lemma(act: Lit, lemma: &Clause) -> Clause {
    let mut c = Vec::with_capacity(lemma.len() + 1);
    c.push(act.not());
    c.extend_from_slice(lemma);
    c
}
```

---

# 4) Mapping `push/pop` to SAT levels: the safe rule

There are two sane options. I recommend the “activation literal only” approach:

### Option A (recommended): push/pop affects only theories + activations

* SAT doesn’t need to pop clauses; clauses are permanent but guarded.
* SAT decision levels are purely search-related.
* `push/pop` doesn’t force a SAT backtrack, except to restore consistency if needed.

In the code above, we *also* store `scope_sat_level` and backtrack on pop. This is safe and often convenient, but optional.

### Option B: tie scope boundaries to SAT levels

* On `push`, call `sat.new_decision_level()` and record it
* On `pop`, `sat.backtrack(recorded_level)`
* Only add lemmas guarded by “scope activation” or simply rely on backtracking

Option B can be nice for predictable incremental behavior, but you must be careful not to interfere with SAT’s own restarts/backjumps. So if SAT kernel owns CDCL, Option A is cleaner.

**In practice:** keep push/pop separate from search levels; use activation literals for scoping.

---

# 5) What you now have (architecture-wise)

* `smt-core`: term DAG + sorts + typed terms
* `smt-preprocess`: Tseitin encoding (structural) + leaves-as-atoms
* `smt-sat`: CDCL kernel (with learning/backjump), plus a kernel interface
* `smt-engine`: CDCL(T) orchestration
* `theories/*`: UF/LIA/BV etc., each returning explanations as SAT literals

This is exactly the kind of layout used by “serious” solvers, but made Rust-idiomatic.

---

If you want the next step: say **yes** and I’ll show the concrete changes needed in `ToyCdcl` to implement `SatKernel`:

* `add_clause_return_index`
* `fresh_var`
* `trail_head/set_trail_head`
* and the subtle detail: when SAT backjumps internally, the engine’s `trail_head` must also clamp (so theories don’t read stale assignments).
