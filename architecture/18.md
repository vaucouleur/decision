Here’s the next “serious UF” step: **incremental congruence closure with parent/use-lists** (e-graph style), **rollbackable**, and with **structured explanations** (so conflicts/propagations can return tight `Vec<Lit>`).

The core idea is the classic Nelson–Oppen UF engine used by real solvers:

* Maintain **e-classes** (union-find).
* Maintain for each e-class a **parent list**: all UF applications that *use* that class as an argument.
* Maintain a **signature table** mapping `(f, reps(args…)) → canonical app`.
* When you merge two classes, you merge their parent lists and **reconsider** those apps; signature collisions trigger more merges.

This is incremental and avoids “rebuild all signatures every propagate()”.

---

## Data structures and invariants

### E-nodes (terms)

* Each UF term (variable/const/app) gets a `NodeId`.
* UF applications store their function symbol and argument node ids.

### E-classes (union-find)

* `parent[node]`, `rank[node]`.
* `edge_reason[node]`: reason why `node` points to its parent (for explanations).
* `class_parents[rep]`: list of application nodes where `rep` appears as an argument.

### Signatures

* For each application node `app`, store its current signature `Sig = (f, rep(arg1), rep(arg2), …)`.
* A hash map `sig_table: Sig -> NodeId(app)` returns the canonical app for that sig.
* On signature collision, merge the apps, with a **congruence reason**.

### Explanations

Use a small reason DAG:

```rust
enum Reason {
  Atom(Lit),                      // asserted equality
  Derived(Vec<ReasonId>),         // conjunction of reasons
}
```

Union edges store a `ReasonId`, not a `Vec<Lit>`. When you need a clause explanation, you expand `ReasonId` to a deduped `Vec<Lit>`.

---

## Rollback (push/pop)

Use a single `trail: Vec<Undo>` with checkpoints. Every mutation pushes an undo record.

Key mutations to trail:

* union-find parent/rank/reason changes
* moving items between parent lists
* signature table inserts/overwrites
* `app_sig[app]` changes

---

## Code skeleton: incremental rollbackable UF with explanations

Below is a single module you can base your `UfTheory` on. It’s verbose on purpose; all the “hard” parts are commented.

```rust
// crates/smt-engine/src/theories/uf_inc.rs

use core::hash::{Hash, Hasher};
use hashbrown::HashMap;
use rustc_hash::FxHasher;
use core::hash::BuildHasherDefault;

use smt_core::{Context, SymbolId, TermId, TermKind};
use smt_sat::{Lit, Var};

type FxBuild = BuildHasherDefault<FxHasher>;

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NodeId(pub u32);

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ReasonId(pub u32);

/// A UF application node: f(args...)
#[derive(Debug, Clone)]
struct AppNode {
    f: SymbolId,
    args: Vec<NodeId>,
    term: TermId,
}

/// Signature key: f + representative args.
/// In production you’d use SmallVec; Vec is fine for a clean starter.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct Sig {
    f: SymbolId,
    reps: Vec<NodeId>,
}

/// Reason DAG nodes. Keep it tiny:
/// - Atom(lit): an asserted (or implied) equality atom literal.
/// - Derived: conjunction of child reasons.
#[derive(Debug, Clone)]
enum Reason {
    Atom(Lit),
    Derived(Vec<ReasonId>),
}

#[derive(Debug, Clone)]
enum Undo {
    /// Undo a UF parent link + rank change + edge reason.
    UfLink {
        node: NodeId,
        old_parent: NodeId,
        old_rank_parent: u8,
        old_edge_reason: Option<ReasonId>,
    },

    /// Undo moving `moved` parent-app entries from `from` to `to` (pop them back).
    ParentsMoved {
        from: NodeId,
        to: NodeId,
        moved: usize,
    },

    /// Undo signature table mapping for a key.
    SigTable {
        key: Sig,
        prev: Option<NodeId>,
    },

    /// Undo stored signature for an app node.
    AppSig {
        app: NodeId,
        prev: Sig,
    },
}

#[derive(Debug, Clone, Copy)]
struct Checkpoint {
    trail_len: usize,
    reason_len: usize,
}

pub struct UfCc {
    ctx: std::sync::Arc<Context>,

    // Term interning to NodeId
    term_to_node: HashMap<TermId, NodeId, FxBuild>,
    node_to_term: Vec<TermId>,

    // UF apps (subset of nodes); for a NodeId, if it is an app, we store its app data.
    apps: HashMap<NodeId, AppNode, FxBuild>,

    // Union-find over all nodes
    parent: Vec<NodeId>,
    rank: Vec<u8>,
    edge_reason: Vec<Option<ReasonId>>,

    // Per representative: parent applications that mention this class in their args
    class_parents: Vec<Vec<NodeId>>,

    // Signature infrastructure
    app_sig: HashMap<NodeId, Sig, FxBuild>,
    sig_table: HashMap<Sig, NodeId, FxBuild>,

    // Reasons + rollback
    reasons: Vec<Reason>,
    trail: Vec<Undo>,
    checkpoints: Vec<Checkpoint>,
}

impl UfCc {
    pub fn new(ctx: std::sync::Arc<Context>) -> Self {
        Self {
            ctx,
            term_to_node: HashMap::default(),
            node_to_term: Vec::new(),
            apps: HashMap::default(),
            parent: Vec::new(),
            rank: Vec::new(),
            edge_reason: Vec::new(),
            class_parents: Vec::new(),
            app_sig: HashMap::default(),
            sig_table: HashMap::default(),
            reasons: Vec::new(),
            trail: Vec::new(),
            checkpoints: vec![Checkpoint { trail_len: 0, reason_len: 0 }],
        }
    }

    // -----------------------------
    // Push/pop (rollback)
    // -----------------------------

    pub fn push(&mut self) {
        self.checkpoints.push(Checkpoint {
            trail_len: self.trail.len(),
            reason_len: self.reasons.len(),
        });
    }

    pub fn pop(&mut self, n: usize) {
        for _ in 0..n {
            if self.checkpoints.len() <= 1 {
                return;
            }
            let cp = self.checkpoints.pop().unwrap();

            // Undo trail actions
            while self.trail.len() > cp.trail_len {
                self.undo_one();
            }

            // Truncate reasons (ReasonId stability is only within the current search;
            // in a production solver, you'd keep them in a bump arena and never truncate).
            self.reasons.truncate(cp.reason_len);
        }
    }

    fn undo_one(&mut self) {
        match self.trail.pop().unwrap() {
            Undo::UfLink { node, old_parent, old_rank_parent, old_edge_reason } => {
                let i = node.0 as usize;
                let p_new = self.parent[i];
                self.parent[i] = old_parent;
                self.edge_reason[i] = old_edge_reason;

                // Restore rank of the parent we attached under (best-effort)
                let p_idx = p_new.0 as usize;
                self.rank[p_idx] = old_rank_parent;
            }
            Undo::ParentsMoved { from, to, moved } => {
                // We previously moved `moved` entries from `from` to `to` by appending them to `to`.
                // Undo by popping them from `to` and pushing back onto `from`.
                let to_list = &mut self.class_parents[to.0 as usize];
                let from_list = &mut self.class_parents[from.0 as usize];
                for _ in 0..moved {
                    if let Some(x) = to_list.pop() {
                        from_list.push(x);
                    }
                }
            }
            Undo::SigTable { key, prev } => {
                match prev {
                    Some(v) => { self.sig_table.insert(key, v); }
                    None => { self.sig_table.remove(&key); }
                }
            }
            Undo::AppSig { app, prev } => {
                self.app_sig.insert(app, prev);
            }
        }
    }

    // -----------------------------
    // Reason management
    // -----------------------------

    fn mk_reason_atom(&mut self, lit: Lit) -> ReasonId {
        let id = ReasonId(self.reasons.len() as u32);
        self.reasons.push(Reason::Atom(lit));
        id
    }

    fn mk_reason_derived(&mut self, kids: Vec<ReasonId>) -> ReasonId {
        let id = ReasonId(self.reasons.len() as u32);
        self.reasons.push(Reason::Derived(kids));
        id
    }

    /// Expand a reason id into a deduplicated vector of SAT literals.
    pub fn expand_reason_lits(&self, rid: ReasonId) -> Vec<Lit> {
        let mut out = Vec::new();
        let mut seen = hashbrown::HashSet::<Lit, FxBuild>::default();
        self.expand_reason_lits_rec(rid, &mut seen, &mut out);
        out
    }

    fn expand_reason_lits_rec(&self, rid: ReasonId, seen: &mut hashbrown::HashSet<Lit, FxBuild>, out: &mut Vec<Lit>) {
        match &self.reasons[rid.0 as usize] {
            Reason::Atom(l) => {
                if seen.insert(*l) {
                    out.push(*l);
                }
            }
            Reason::Derived(kids) => {
                for &k in kids {
                    self.expand_reason_lits_rec(k, seen, out);
                }
            }
        }
    }

    // -----------------------------
    // Node creation
    // -----------------------------

    /// Ensure a UF term is tracked and return its NodeId.
    /// This adds app nodes + registers parents lists + signatures for Uf applications.
    pub fn ensure_term(&mut self, t: TermId) -> NodeId {
        if let Some(&nid) = self.term_to_node.get(&t) {
            return nid;
        }

        let nid = NodeId(self.node_to_term.len() as u32);
        self.term_to_node.insert(t, nid);
        self.node_to_term.push(t);

        // init union-find
        self.parent.push(nid);
        self.rank.push(0);
        self.edge_reason.push(None);
        self.class_parents.push(Vec::new());

        // If t is a UF application, register it.
        let (k, _) = self.ctx.term_node(t);
        if let TermKind::App { op, args } = k {
            if let smt_core::OpKind::Uf(f) = op.kind {
                let arg_nodes: Vec<NodeId> = args.iter().map(|&a| self.ensure_term(a)).collect();
                self.apps.insert(nid, AppNode { f, args: arg_nodes, term: t });

                // Add this app to each argument class parent list (by current representative).
                for &a in self.apps[&nid].args.iter() {
                    let ra = self.find(a);
                    self.class_parents[ra.0 as usize].push(nid);
                }

                // Compute and register signature (may trigger congruence merge).
                self.recompute_sig_and_register(nid);
            }
        }

        nid
    }

    // -----------------------------
    // Union-find + explain paths
    // -----------------------------

    fn find(&self, mut x: NodeId) -> NodeId {
        while self.parent[x.0 as usize] != x {
            x = self.parent[x.0 as usize];
        }
        x
    }

    /// Return the list of reason-edges on the path from node to root (excluding root).
    fn path_reasons(&self, mut x: NodeId) -> Vec<ReasonId> {
        let mut out = Vec::new();
        while self.parent[x.0 as usize] != x {
            if let Some(r) = self.edge_reason[x.0 as usize] {
                out.push(r);
            }
            x = self.parent[x.0 as usize];
        }
        out
    }

    /// Explain why a == b as a ReasonId (Derived of path edges).
    ///
    /// This is a simple “path-to-root” explanation (not minimal but sound).
    pub fn explain_eq(&mut self, a: NodeId, b: NodeId) -> Option<ReasonId> {
        if self.find(a) != self.find(b) {
            return None;
        }
        let mut ra = self.path_reasons(a);
        let mut rb = self.path_reasons(b);
        ra.append(&mut rb);
        Some(self.mk_reason_derived(ra))
    }

    /// Union classes with an explicit reason id.
    ///
    /// Also merges parent lists and triggers congruence reconsideration.
    pub fn union(&mut self, a: NodeId, b: NodeId, reason: ReasonId) {
        let mut ra = self.find(a);
        let mut rb = self.find(b);
        if ra == rb {
            return;
        }

        // union by rank: attach smaller under larger
        let (rka, rkb) = (self.rank[ra.0 as usize], self.rank[rb.0 as usize]);
        if rka > rkb {
            core::mem::swap(&mut ra, &mut rb);
        }

        // trail UF link info
        let rb_idx = rb.0 as usize;
        let old_rank_parent = self.rank[rb_idx];
        let old_parent = self.parent[ra.0 as usize];
        let old_reason = self.edge_reason[ra.0 as usize];

        self.trail.push(Undo::UfLink {
            node: ra,
            old_parent,
            old_rank_parent,
            old_edge_reason: old_reason,
        });

        // attach
        self.parent[ra.0 as usize] = rb;
        self.edge_reason[ra.0 as usize] = Some(reason);

        if rka == rkb {
            self.rank[rb_idx] = old_rank_parent.saturating_add(1);
        }

        // merge parent app lists: move ra parents into rb parents
        let moved = self.class_parents[ra.0 as usize].len();
        if moved > 0 {
            self.trail.push(Undo::ParentsMoved { from: ra, to: rb, moved });
            let mut tmp = Vec::new();
            core::mem::swap(&mut tmp, &mut self.class_parents[ra.0 as usize]);
            self.class_parents[rb.0 as usize].extend(tmp);
        }

        // reconsider apps that mention this merged class
        self.reconsider_class_parents(rb);
    }

    // -----------------------------
    // Congruence closure (incremental)
    // -----------------------------

    /// Recompute an app's signature and maintain the signature table.
    /// If a collision occurs, merge the two apps by congruence.
    fn recompute_sig_and_register(&mut self, app: NodeId) {
        let Some(appnode) = self.apps.get(&app) else { return };

        let reps: Vec<NodeId> = appnode.args.iter().map(|&a| self.find(a)).collect();
        let new_sig = Sig { f: appnode.f, reps };

        // Undo old app_sig if it existed.
        if let Some(old) = self.app_sig.get(&app).cloned() {
            if old != new_sig {
                self.trail.push(Undo::AppSig { app, prev: old });
            } else {
                // signature unchanged; nothing to do
                return;
            }
        }
        self.app_sig.insert(app, new_sig.clone());

        // Update sig_table: record previous mapping
        let prev = self.sig_table.get(&new_sig).copied();
        self.trail.push(Undo::SigTable { key: new_sig.clone(), prev });

        match prev {
            None => {
                self.sig_table.insert(new_sig, app);
            }
            Some(other_app) => {
                // Collision: app ≡ other_app by congruence
                self.sig_table.insert(new_sig, other_app);

                // Build congruence reason = AND(explain(arg_i(app) = arg_i(other)))
                let mut kid_reasons: Vec<ReasonId> = Vec::new();

                let a_args = &self.apps[&app].args;
                let b_args = &self.apps[&other_app].args;

                for (&aa, &bb) in a_args.iter().zip(b_args.iter()) {
                    // They should already be in same class under reps, but explanation may be empty if not.
                    if let Some(r) = self.explain_eq(aa, bb) {
                        kid_reasons.push(r);
                    }
                }

                let reason = self.mk_reason_derived(kid_reasons);
                self.union(app, other_app, reason);
            }
        }
    }

    /// When a class representative changes, reconsider all app nodes that use it.
    fn reconsider_class_parents(&mut self, rep: NodeId) {
        // In a production solver, you'd avoid duplicates. For a starter, duplicates are OK.
        let apps = self.class_parents[rep.0 as usize].clone();
        for app in apps {
            self.recompute_sig_and_register(app);
        }
    }

    // -----------------------------
    // Public UF API used by Theory layer
    // -----------------------------

    /// Assert equality a=b with a SAT-level atom literal as the justification.
    pub fn assert_eq_atom(&mut self, a: TermId, b: TermId, atom_lit: Lit) {
        let na = self.ensure_term(a);
        let nb = self.ensure_term(b);
        let r = self.mk_reason_atom(atom_lit);
        self.union(na, nb, r);
    }

    /// Assert disequality a!=b (store it outside UF; your Theory wrapper checks conflicts).
    pub fn are_equal(&self, a: TermId, b: TermId) -> bool {
        let Some(&na) = self.term_to_node.get(&a) else { return false };
        let Some(&nb) = self.term_to_node.get(&b) else { return false };
        self.find(na) == self.find(nb)
    }
}
```

---

## How this integrates into your `UfTheory`

Your `UfTheory` (the CDCL(T) theory wrapper) becomes mostly glue:

* parse equality atoms `(= lhs rhs)` and remember `AtomInfo { var, lhs, rhs, value }`
* on assignment:

  * if true: `uf.assert_eq_atom(lhs, rhs, Lit::pos(var))`
  * if false: store a diseq record `(lhs, rhs, Lit::neg(var))`
* in `propagate()`:

  * check each diseq: if now equal, conflict explanation:

    * `why_eq = uf.explain_eq(node(lhs), node(rhs)) -> ReasonId -> lits`
    * plus the diseq literal `¬eqAtom`
  * propagate equalities: if `(= x y)` is unassigned but UF says equal:

    * `why_eq` as above
    * return `TheoryPropagation { implied: Lit::pos(var), explain: lits }`

You’ll notice: **you no longer need rebuild-per-propagate**; merges automatically trigger signature reconsiderations.

---

## Why this is closer to Z3/cvc5 behavior

* Parent/use-lists + signature table is the standard incremental CC algorithm.
* Storing **Reason DAG** gives you more structured, extensible explanations than flattening at union time.
* Rollback is clean because:

  * union-find is rollbackable
  * parent list moves are undoable
  * signature table changes are undoable
  * reason ids are stable within a checkpoint window

---

## Two practical next polish steps (still “beautiful”)

1. **Avoid cloning parent lists** in `reconsider_class_parents`
   Use a small work queue and push apps onto it as you merge classes; dedup with a mark bitset per app per “epoch”.

2. **Make explanations tighter**
   Right now `explain_eq` is “path to root”; it can include extra literals. You can tighten later by:

   * storing parent pointers in a proper proof forest with LCA computation, or
   * doing a small minimization pass over the returned lits.

---

If you say **yes**, I’ll show the exact `UfTheory` wrapper built on top of `UfCc` (including conflict/propagation generation), and the tiny optimization that prevents “propagation spam” (re-sending the same implied equality atom repeatedly).
