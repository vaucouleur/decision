Here’s `assert_eqshare_hop_none!` — it asserts that **none** of the candidate pairs appear in the trace for the given direction. This is great for the SAT rows in your matrix (e.g., “UF→DL disabled” should not exchange `f(a)=f(b)`).

It supports both:

* array literal form: `[(a,b), (c,d)]`
* slice form: `&[(a,b), ...]`

---

## Add this macro to `crates/smt-tests/src/eqshare_macros.rs`

It reuses the same `has_pair` + `dump` helpers.

```rust
#[macro_export]
macro_rules! assert_eqshare_hop_none {
    // Array literal overload
    ($events:expr, UF => DL, [ $(($a:expr, $b:expr)),+ $(,)? ] $(,)?) => {{
        let candidates = [ $(($a, $b)),+ ];
        $crate::assert_eqshare_hop_none!($events, UF => DL, &candidates);
    }};

    ($events:expr, DL => UF, [ $(($a:expr, $b:expr)),+ $(,)? ] $(,)?) => {{
        let candidates = [ $(($a, $b)),+ ];
        $crate::assert_eqshare_hop_none!($events, DL => UF, &candidates);
    }};

    // Slice form
    ($events:expr, UF => DL, $candidates:expr $(,)?) => {{
        let events = $events;
        let cands = $candidates;

        let found = cands.iter().find(|(a, b)| {
            $crate::eqshare_macros::has_pair(
                events,
                $crate::eqshare_macros::UF,
                $crate::eqshare_macros::DL,
                **a,
                **b,
            )
        });

        if let Some((a, b)) = found {
            panic!(
                "unexpected eqshare hop UF=>DL for pair {:?} = {:?}\n\
                 candidates={:?}\n\
                 first events:\n{}",
                a, b, cands, $crate::eqshare_macros::dump(events)
            );
        }
    }};

    ($events:expr, DL => UF, $candidates:expr $(,)?) => {{
        let events = $events;
        let cands = $candidates;

        let found = cands.iter().find(|(a, b)| {
            $crate::eqshare_macros::has_pair(
                events,
                $crate::eqshare_macros::DL,
                $crate::eqshare_macros::UF,
                **a,
                **b,
            )
        });

        if let Some((a, b)) = found {
            panic!(
                "unexpected eqshare hop DL=>UF for pair {:?} = {:?}\n\
                 candidates={:?}\n\
                 first events:\n{}",
                a, b, cands, $crate::eqshare_macros::dump(events)
            );
        }
    }};
}
```

---

## Example usage in a SAT matrix row

Say ping-pong with only UF→DL enabled should stay SAT and **must not** share `x=y` back (DL→UF).

```rust
let mut sess = common::make_session(SharingConfig { uf_to_dl: true, dl_to_uf: false });
let inst = setup_ping_pong_instance(&mut sess)?;
assert_eq!(sess.check_sat(), CheckSat::Sat);

let events = sess.take_eqshare_events();

// UF→DL may happen; DL→UF must not
assert_eqshare_hop_none!(&events, DL => UF, [
    (inst.x, inst.y),
]);
```

Or for the row where UF→DL is disabled:

```rust
let mut sess = common::make_session(SharingConfig { uf_to_dl: false, dl_to_uf: true });
let inst = setup_ping_pong_instance(&mut sess)?;
assert_eq!(sess.check_sat(), CheckSat::Sat);

let events = sess.take_eqshare_events();

assert_eqshare_hop_none!(&events, UF => DL, [
    (inst.fa, inst.fb),
]);
```

---

If you want, I can add one last macro `assert_eqshare_events_empty!(events)` that’s handy for “both disabled” rows (shouldn’t exchange anything at all).
