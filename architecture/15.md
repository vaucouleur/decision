Below is a complete **vertical-slice UF demo** you can drop into your workspace. It builds a small UF problem, runs **propositionalization + CDCL(T)** (SAT kernel learns; engine injects UF lemmas), and prints `SAT/UNSAT`.

It also includes the **one small refactor** you need so `UfTheory` can live inside `Box<dyn Theory>`: store the `Context` in an `Arc` instead of `&Context`.

---

## 0) One necessary refactor: `UfTheory` must own `Arc<Context>`

Your earlier `UfTheory<'a> { ctx: &'a Context, ... }` can’t be put in a `Box<dyn Theory>` unless you thread lifetimes everywhere. Make it:

### `crates/smt-engine/src/theories/uf.rs` (minimal patch)

```rust
use std::sync::Arc; // <-- requires std (fine for the demo)

pub struct UfTheory {
    ctx: Arc<Context>,
    id: TheoryId,
    // ... rest unchanged
}

impl UfTheory {
    pub fn new(ctx: Arc<Context>, id: TheoryId) -> Self {
        Self {
            ctx,
            id,
            // ... rest unchanged
        }
    }

    // Update uses: self.ctx -> &Context where needed:
    // parse_eq_atom(&self.ctx, ...) becomes parse_eq_atom(&self.ctx, ...)
}
```

And adjust the helper signatures to take `&Context` (they already do).

---

## 1) Ensure `smt-engine` exports what the demo uses

### `crates/smt-engine/src/lib.rs`

```rust
pub mod cdclt;
pub mod propositionalize;
pub mod theory;
pub mod atoms;
pub mod engine_ctx;

// Your theories module
pub mod theories {
    pub mod uf;
}

pub use cdclt::{CdcltEngine, SolveResult};
pub use propositionalize::{propositionalize, DefaultClassifier, Propositionalization};
pub use atoms::{TheoryId};
```

---

## 2) Demo crate

### `crates/smt-demo/Cargo.toml`

```toml
[package]
name = "smt-demo"
version = "0.1.0"
edition = "2021"

[dependencies]
smt-core = { path = "../smt-core" }
smt-preprocess = { path = "../smt-preprocess" }
smt-sat = { path = "../smt-sat", features = ["toy"] }
smt-engine = { path = "../smt-engine" }
```

---

## 3) The demo program

### `crates/smt-demo/src/main.rs`

```rust
//! UF vertical slice demo:
//! - build a small UF problem in `smt-core`
//! - propositionalize (Tseitin for Bool structure; theory predicates as atoms)
//! - register UF atoms
//! - run CDCL(T) with a CDCL SAT kernel and UF theory
//!
//! Two examples:
//! 1) UNSAT:  a = b  ∧  f(a) != f(b)   (congruence forces f(a)=f(b))
//! 2) SAT:    a = b  ∧  f(a) = c       (consistent)

use std::sync::Arc;

use smt_core::prelude::*;
use smt_engine::{
    propositionalize, DefaultClassifier, SolveResult, TheoryId, CdcltEngine,
};
use smt_engine::theories::uf::UfTheory;
use smt_sat::ToyCdcl;

/// Build an uninterpreted-sort scenario with:
/// - sort U
/// - constants a,b,c : U
/// - unary function f : U -> U (represented by OpKind::Uf(f_sym))
fn build_uf_terms(ctx: &mut Context) -> (SortId, TermId, TermId, TermId, smt_core::SymbolId) {
    let sym_u = ctx.intern_sym("U");
    let u = ctx.mk_uninterpreted_sort(sym_u);

    let a = ctx.mk_var("a", u);
    let b = ctx.mk_var("b", u);
    let c = ctx.mk_var("c", u);

    let f_sym = ctx.intern_sym("f");
    (u, a, b, c, f_sym)
}

/// Apply f to a term: f(x)
fn mk_f_app(ctx: &mut Context, f_sym: smt_core::SymbolId, x: TermId, u: SortId) -> TermId {
    ctx.mk_app(Op::new(OpKind::Uf(f_sym)), [x], u)
        .expect("mk_app should succeed in demo")
}

/// Build formula: (and (= a b) (not (= (f a) (f b))))
fn mk_unsat_formula(ctx: &mut Context, u: SortId, a: TermId, b: TermId, f_sym: smt_core::SymbolId) -> BoolTerm {
    let fa = mk_f_app(ctx, f_sym, a, u);
    let fb = mk_f_app(ctx, f_sym, b, u);

    let eq_ab = ctx.eq(a, b).expect("eq");
    let eq_fafb = ctx.eq(fa, fb).expect("eq");
    let neq_fafb = ctx.not(eq_fafb).expect("not");

    ctx.and([eq_ab, neq_fafb]).expect("and")
}

/// Build formula: (and (= a b) (= (f a) c))
fn mk_sat_formula(ctx: &mut Context, u: SortId, a: TermId, b: TermId, c: TermId, f_sym: smt_core::SymbolId) -> BoolTerm {
    let fa = mk_f_app(ctx, f_sym, a, u);

    let eq_ab = ctx.eq(a, b).expect("eq");
    let eq_fac = ctx.eq(fa, c).expect("eq");

    ctx.and([eq_ab, eq_fac]).expect("and")
}

/// Run CDCL(T) on a root BoolTerm and return SAT/UNSAT.
fn solve_with_uf(ctx: Arc<Context>, root: BoolTerm) -> Result<SolveResult> {
    // Only one theory for this demo: UF at index 0
    let uf_id = TheoryId(0);

    // Classifier tells propositionalizer which Bool terms are UF atoms.
    let classifier = DefaultClassifier::new(uf_id);

    // Propositionalize:
    // - CNF for Bool structure
    // - term_to_var mapping for all Bool subterms and atoms
    // - AtomTable (Var -> Atom{term, theory})
    let prop = propositionalize(&ctx, root, &classifier)?;

    // SAT kernel
    let mut sat = ToyCdcl::new();
    sat.reserve_vars(prop.cnf.num_vars);

    // Engine takes ownership of SAT kernel + atoms + theories
    let mut uf = UfTheory::new(ctx.clone(), uf_id);

    // Register UF atoms: iterate over terms mapped to vars, ask classifier.
    for (&term, &var) in prop.term_to_var.iter() {
        if classifier.classify_bool_term(&ctx, term) == Some(uf_id) {
            uf.register_eq_atom(term, var)?;
        }
    }

    let mut engine = CdcltEngine::new(sat, prop.atoms, vec![Box::new(uf)]);

    // Add CNF clauses
    for c in prop.cnf.clauses {
        engine.add_base_clause(c);
    }
    // Assert root true
    engine.add_base_clause(vec![prop.root]);

    Ok(engine.solve())
}

fn main() -> Result<()> {
    // ---------- UNSAT demo ----------
    {
        let mut ctx = Context::default();
        let (u, a, b, _c, f_sym) = build_uf_terms(&mut ctx);

        let root = mk_unsat_formula(&mut ctx, u, a, b, f_sym);
        println!("UNSAT instance: {}", ctx.pretty_term(root.id()));

        let res = solve_with_uf(Arc::new(ctx), root)?;
        println!("Result: {:?}\n", res);
        assert_eq!(res, SolveResult::Unsat);
    }

    // ---------- SAT demo ----------
    {
        let mut ctx = Context::default();
        let (u, a, b, c, f_sym) = build_uf_terms(&mut ctx);

        let root = mk_sat_formula(&mut ctx, u, a, b, c, f_sym);
        println!("SAT instance: {}", ctx.pretty_term(root.id()));

        let res = solve_with_uf(Arc::new(ctx), root)?;
        println!("Result: {:?}\n", res);
        assert_eq!(res, SolveResult::Sat);
    }

    Ok(())
}
```

---

## 4) Run it

From the workspace root:

```bash
cargo run -p smt-demo
```

You should see the pretty-printed SMT-ish formulas and `Unsat` then `Sat`.

---

## 5) If it doesn’t compile on first try

The demo assumes these `smt-core` APIs exist (as we used them earlier):

* `Context::intern_sym(&str) -> SymbolId`
* `Context::mk_uninterpreted_sort(SymbolId) -> SortId`
* `Context::mk_var(&str, SortId) -> TermId`
* `Context::mk_app(Op, impl IntoIterator<Item=TermId>, SortId) -> Result<TermId>`
* typed helpers: `ctx.eq(a,b) -> Result<BoolTerm>`, `ctx.not(BoolTerm)`, `ctx.and(iter)`

If any names differ in your current code, it’s usually a 1–2 minute rename.

---

If you want, I can also add a third example that shows **theory propagation** (not just conflict): e.g. asserting `a=b` and leaving `(= f(a) f(b))` unassigned, UF will *propagate* it to true with an explanation, and you’ll see the engine injecting that lemma.
