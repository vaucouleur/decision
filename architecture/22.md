Yep — the clean fix is to separate **user scopes** (`push/pop` like SMT-LIB) from **search levels** (SAT decision levels / CDCL backjump). Real solvers keep two independent rollback “dimensions”.

Below is a practical, Rust-friendly way to do it.

---

## 1) Split the Theory API: scope vs search-level

### `crates/smt-engine/src/theory.rs`

```rust
use smt_core::TermId;
use smt_sat::Lit;

#[derive(Debug, Clone)]
pub struct TheoryPropagation {
    pub implied: Lit,
    /// Explanation literals assumed true: (¬e1 ∨ ¬e2 ∨ ... ∨ implied)
    pub explain: Vec<Lit>,
}

#[derive(Debug, Clone)]
pub struct TheoryConflict {
    /// Explanation literals assumed true: (¬e1 ∨ ¬e2 ∨ ...)
    pub explain: Vec<Lit>,
}

/// CDCL(T) theory interface with *two* rollback stacks:
/// - scope stack: SMT-LIB push/pop (between solve calls)
/// - level stack: SAT decision levels/backjump (during solve)
pub trait Theory {
    fn name(&self) -> &'static str;

    // -------------------------
    // User scopes (SMT push/pop)
    // -------------------------

    /// SMT-LIB `push`: start a new user scope.
    fn push_scope(&mut self);

    /// SMT-LIB `pop n`: revert user scopes.
    fn pop_scope(&mut self, n: usize);

    // -------------------------
    // Search levels (CDCL trail)
    // -------------------------

    /// Called whenever SAT enters a new decision level.
    fn push_level(&mut self);

    /// Called whenever SAT backtracks (including non-chronological backjump / restart).
    fn pop_levels(&mut self, n: usize);

    // -------------------------
    // Assignments + propagation
    // -------------------------

    /// Notify about assignment of a theory atom term to a boolean value.
    fn on_atom_assigned(&mut self, atom_term: TermId, value: bool);

    /// Produce theory propagations or a theory conflict.
    fn propagate(&mut self) -> Result<Vec<TheoryPropagation>, TheoryConflict>;
}
```

**Key rule:** `push_scope/pop_scope` happen outside the SAT search (typically between solve calls).
`push_level/pop_levels` are driven by SAT as it searches.

---

## 2) Engine: mirror SAT decision levels into theories (handles backjump!)

Add a small piece of state to the engine:

* `sat_level_seen: usize`

and a sync function that you call after **every SAT step that could backjump**, notably after `sat.propagate()`.

### `crates/smt-engine/src/cdclt.rs` (core changes)

```rust
pub struct CdcltEngine<K: smt_sat::kernel::SatKernel> {
    sat: K,
    atoms: crate::atoms::AtomTable,
    theories: Vec<Box<dyn crate::theory::Theory>>,

    // Engine cursor into SAT trail (you already have this pattern).
    // This stays inside SAT kernel as `trail_head()`, but we also keep:
    sat_level_seen: usize,
}

impl<K: smt_sat::kernel::SatKernel> CdcltEngine<K> {
    pub fn new(sat: K, atoms: crate::atoms::AtomTable, theories: Vec<Box<dyn crate::theory::Theory>>) -> Self {
        Self { sat, atoms, theories, sat_level_seen: 0 }
    }

    /// Call this after any SAT operation that can change decision_level() *internally*:
    /// - propagate() (conflict analysis may backjump)
    /// - restart() if you add it later
    fn sync_levels_with_sat(&mut self) {
        let cur = self.sat.decision_level();

        if cur > self.sat_level_seen {
            let delta = cur - self.sat_level_seen;
            for _ in 0..delta {
                for th in self.theories.iter_mut() {
                    th.push_level();
                }
            }
        } else if cur < self.sat_level_seen {
            let delta = self.sat_level_seen - cur;
            for th in self.theories.iter_mut() {
                th.pop_levels(delta);
            }

            // Also ensure SAT trail notification head is clamped (your ToyCdcl does this on backtrack).
            // But if you keep a head in the engine too, clamp it here.
        }

        self.sat_level_seen = cur;
    }

    /// Engine-driven decisions: whenever the engine calls sat.new_decision_level(),
    /// it must also push_level() in theories *immediately* (before enqueue notifications),
    /// so theory state matches SAT level nesting.
    fn new_decision_level(&mut self) {
        self.sat.new_decision_level();
        for th in self.theories.iter_mut() {
            th.push_level();
        }
        self.sat_level_seen = self.sat.decision_level();
    }

    fn notify_theories_new_trail(&mut self) {
        // Ensure theory levels are synced before applying new assignments.
        self.sync_levels_with_sat();

        let trail = self.sat.trail();
        let mut head = self.sat.trail_head();

        while head < trail.len() {
            let lit = trail[head];
            head += 1;

            if let Some(atom) = self.atoms.get(lit.var()) {
                let value = match self.sat.value_lit(lit) {
                    smt_sat::kernel::LBool::True => true,
                    smt_sat::kernel::LBool::False => false,
                    smt_sat::kernel::LBool::Undef => continue,
                };
                self.theories[atom.theory.0].on_atom_assigned(atom.term, value);
            }
        }

        self.sat.set_trail_head(head);
    }

    pub fn push(&mut self) {
        // User scope: do NOT touch SAT decision levels here.
        for th in self.theories.iter_mut() {
            th.push_scope();
        }
        // If you still use activation literals for scoped assertions, manage them here.
    }

    pub fn pop(&mut self, n: usize) {
        // Typically called between solve calls, when SAT is at level 0.
        for th in self.theories.iter_mut() {
            th.pop_scope(n);
        }
        // If you used activation literals, backtrack/clear assumptions here.
        // Keep sat_level_seen consistent:
        self.sat_level_seen = self.sat.decision_level();
    }

    pub fn solve(&mut self) -> crate::cdclt::SolveResult {
        // Ensure theories start with search level stack empty.
        // SAT should be at level 0 here.
        self.sat_level_seen = self.sat.decision_level();
        self.sat.set_trail_head(0);

        loop {
            // SAT propagation may backjump internally -> sync after.
            if self.sat.propagate().is_err() {
                return crate::cdclt::SolveResult::Unsat;
            }
            self.sync_levels_with_sat();

            // Notify theory atoms assigned by SAT propagation or decisions.
            self.notify_theories_new_trail();

            // Theory fixpoint loop.
            loop {
                let mut any = false;

                for th in self.theories.iter_mut() {
                    match th.propagate() {
                        Ok(props) => {
                            for p in props {
                                any = true;
                                // translate explain => implied into SAT clause and enqueue with reason if possible
                                let lemma = crate::engine_ctx::implication_clause(&p.explain, p.implied);
                                let cidx = self.sat.add_clause_return_index(lemma);
                                let _ = self.sat.enqueue(p.implied, Some(cidx));
                            }
                        }
                        Err(conf) => {
                            any = true;
                            let lemma = crate::engine_ctx::conflict_clause(&conf.explain);
                            let _ = self.sat.add_clause_return_index(lemma);
                            // SAT will see it on next propagate
                            break;
                        }
                    }
                }

                if self.sat.propagate().is_err() {
                    return crate::cdclt::SolveResult::Unsat;
                }
                self.sync_levels_with_sat();
                self.notify_theories_new_trail();

                if !any {
                    break;
                }
            }

            if self.sat.pick_branch_lit().is_none() {
                return crate::cdclt::SolveResult::Sat;
            }

            // Decision
            let d = self.sat.pick_branch_lit().unwrap();
            self.new_decision_level();
            let _ = self.sat.enqueue(d, None);
        }
    }
}
```

**What this buys you:** even if `ToyCdcl::propagate()` learns and backjumps from level 12 to level 4, the engine observes `decision_level()` decreased and calls `theory.pop_levels(8)` immediately — so the theory’s internal state stays consistent.

---

## 3) UF theory wrapper: implement BOTH rollback stacks

Your UF internals (`UfCc`) already have `push/pop`. We’ll use that rollback machinery for **search levels**.

For **user scopes**, keep a separate checkpoint stack — but simplest is:

* `push_scope/pop_scope`: manipulate a *scope checkpoint stack* (and also call `UfCc::push/pop`)
* `push_level/pop_levels`: manipulate a *level checkpoint stack* (and also call `UfCc::push/pop`)

Because user scope changes are normally between solve calls, the stacks won’t interleave in weird ways.

### `UfTheoryInc` core idea

```rust
pub struct UfTheoryInc {
    uf: UfCc,

    // Atom state + theory-side assignment trail (as you already added)
    atoms: HashMap<TermId, EqAtom, FxBuild>,
    atom_trail: Vec<AtomUndo>,
    diseqs: Vec<Diseq>,

    // Two checkpoint stacks
    scope_cp: Vec<(usize, usize)>, // (atom_trail_len, diseqs_len)
    level_cp: Vec<(usize, usize)>, // (atom_trail_len, diseqs_len)
}

impl UfTheoryInc {
    fn checkpoint(&mut self, stack: &mut Vec<(usize, usize)>) {
        self.uf.push();
        stack.push((self.atom_trail.len(), self.diseqs.len()));
    }

    fn rollback(&mut self, stack: &mut Vec<(usize, usize)>, n: usize) {
        for _ in 0..n {
            if stack.len() <= 1 { return; }
            let (trail_len, diseq_len) = stack.pop().unwrap();
            self.uf.pop(1);

            while self.atom_trail.len() > trail_len {
                let u = self.atom_trail.pop().unwrap();
                if let Some(a) = self.atoms.get_mut(&u.atom_term) {
                    a.value = u.prev_value;
                    a.propagated_true = u.prev_propagated_true;
                }
            }
            self.diseqs.truncate(diseq_len);
        }
    }
}

impl Theory for UfTheoryInc {
    fn name(&self) -> &'static str { "UF" }

    fn push_scope(&mut self) {
        self.checkpoint(&mut self.scope_cp);
    }

    fn pop_scope(&mut self, n: usize) {
        self.rollback(&mut self.scope_cp, n);
    }

    fn push_level(&mut self) {
        self.checkpoint(&mut self.level_cp);
    }

    fn pop_levels(&mut self, n: usize) {
        self.rollback(&mut self.level_cp, n);
    }

    fn on_atom_assigned(&mut self, atom_term: TermId, value: bool) {
        // same as your precise rollback version:
        // - record AtomUndo
        // - apply
        // - if value=true => uf.assert_eq_atom(...)
        // - else => store diseq
    }

    fn propagate(&mut self) -> Result<Vec<TheoryPropagation>, TheoryConflict> {
        // same as before
    }
}
```

### Initialization

In `new()`:

```rust
scope_cp: vec![(0, 0)],
level_cp: vec![(0, 0)],
```

---

## 4) Practical policy: avoid activation literals for theory lemmas

Once theories are rollback-correct on **search levels**, you typically do:

* theory lemmas added during search are **permanent** (global) clauses
* they remain valid logically, regardless of backtracking
* you do **not** need activation literals for those

Activation literals are still great for:

* user-scoped assertions (`push/pop`)
* “temporary” constraints you only want during a call

So the clean policy is:

* **use activation literals for user scopes only**
* **don’t guard theory lemmas** (they’re globally valid)

This reduces clause bloat and makes performance much closer to real SMT solvers.

---

If you want the next step: say **yes** and I’ll show how to structure the engine so user-scoped assertions become activation literals automatically (SMT-LIB `assert` attaches to current scope), while theory lemmas stay permanent — plus a tiny API to fetch an UNSAT core over user assertions.
