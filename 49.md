Below are **trace assertions** that directly verify the equality-sharing hop(s), using the `EqShareTrace` you added to the engine:

* UF→DL test must contain an event exporting/importing `f(a) = f(b)` with `src=UF, dst=DL`
* DL→UF test must contain an event `x = y` with `src=DL, dst=UF`
* Ping-pong must contain **both** (at least one UF→DL and one DL→UF), and optionally the specific pairs

This is often the most surgical signal when debugging combination.

---

# 1) Expose a read-only trace from `Session`

If `Session` wraps the engine, add a method:

### `crates/smt-api/src/session.rs` (or wherever)

```rust
impl Session {
    pub fn eqshare_events(&self) -> Option<&[smt_engine::eqshare_trace::EqShareEvent]> {
        // adjust field names based on your Session internals
        Some(self.engine.eqshare_trace.events())
    }
}
```

If you can’t expose engine internals, add a getter in engine and forward it.

---

# 2) Trace assertion helpers

### `crates/smt-tests/src/trace_assert.rs`

```rust
#![forbid(unsafe_code)]

use smt_core::TermId;
use smt_engine::atoms::TheoryId;
use smt_engine::eqshare_trace::EqShareEvent;

/// Directional requirement for an equality-sharing event.
#[derive(Debug, Clone, Copy)]
pub struct DirReq {
    pub src: TheoryId,
    pub dst: TheoryId,
}

/// Check whether events contain an equality (a=b or b=a) with matching src/dst.
pub fn has_eq_event(
    events: &[EqShareEvent],
    dir: DirReq,
    a: TermId,
    b: TermId,
) -> bool {
    events.iter().any(|ev| {
        ev.src == dir.src
            && ev.dst == dir.dst
            && ((ev.a == a && ev.b == b) || (ev.a == b && ev.b == a))
    })
}

/// Check whether events contain at least one event for the given direction (any pair).
pub fn has_any_dir_event(events: &[EqShareEvent], dir: DirReq) -> bool {
    events.iter().any(|ev| ev.src == dir.src && ev.dst == dir.dst)
}

/// Panic with a readable dump of the first N events.
pub fn assert_has_eq_event(
    events: &[EqShareEvent],
    dir: DirReq,
    a: TermId,
    b: TermId,
    label: &str,
) {
    if has_eq_event(events, dir, a, b) {
        return;
    }
    let dump: Vec<String> = events.iter().take(30).map(|e| {
        format!(
            "epoch={} {:?}->{:?} a={:?} b={:?} reason={:?}",
            e.epoch, e.src, e.dst, e.a, e.b, e.explain
        )
    }).collect();

    panic!(
        "missing eqshare event: {} (dir {:?}->{:?}, pair {:?}={:?}).\nfirst events:\n{}",
        label, dir.src, dir.dst, a, b, dump.join("\n")
    );
}

pub fn assert_has_any_dir_event(events: &[EqShareEvent], dir: DirReq, label: &str) {
    if has_any_dir_event(events, dir) {
        return;
    }
    let dump: Vec<String> = events.iter().take(30).map(|e| {
        format!(
            "epoch={} {:?}->{:?} a={:?} b={:?} reason={:?}",
            e.epoch, e.src, e.dst, e.a, e.b, e.explain
        )
    }).collect();

    panic!(
        "missing eqshare direction event: {} (dir {:?}->{:?}).\nfirst events:\n{}",
        label, dir.src, dir.dst, dump.join("\n")
    );
}
```

---

# 3) Where to get the `TermId`s for the expected pairs

In each setup function, keep the key terms in a small struct returned by setup:

* `fa`, `fb` for UF→DL
* `x`, `y` for DL→UF
* ping-pong: `fa`, `fb`, `x`, `y`

Modify setup to return these terms.

Example for UF→DL:

```rust
pub struct UfToDlInstance {
    pub fa: TermId,
    pub fb: TermId,
}

fn setup_uf_to_dl_instance(sess: &mut Session) -> smt_core::Result<UfToDlInstance> {
    // ... as before ...
    Ok(UfToDlInstance { fa, fb })
}
```

---

# 4) Trace-asserting tests

### UF→DL trace test

```rust
use crate::bundle_on_failure::{assert_sat_with_bundle_on_mismatch, Expect};
use crate::trace_assert::{DirReq, assert_has_eq_event};
use smt_engine::atoms::TheoryId;

#[test]
fn uf_to_dl_trace_contains_fa_eq_fb() -> smt_core::Result<()> {
    let uf = TheoryId(0);
    let dl = TheoryId(1);

    // run with UF->DL enabled, expect UNSAT
    let mut sess = common::make_session(SharingConfig { uf_to_dl: true, dl_to_uf: false });
    let inst = setup_uf_to_dl_instance(&mut sess)?;
    assert_eq!(sess.check_sat(), CheckSat::Unsat);

    let events = sess.eqshare_events().expect("eqshare events missing");
    assert_has_eq_event(events, DirReq { src: uf, dst: dl }, inst.fa, inst.fb, "UF->DL should share f(a)=f(b)");
    Ok(())
}
```

If you want bundle-on-failure behavior here too, wrap this in the same rerun pattern; but in practice, if the trace assert fails you already want debug enabled. You can either:

* always enable debug for this test via the guard, or
* on failure rerun with debug.

---

### DL→UF trace test

```rust
#[test]
fn dl_to_uf_trace_contains_x_eq_y() -> smt_core::Result<()> {
    let uf = TheoryId(0);
    let dl = TheoryId(1);

    let mut sess = common::make_session(SharingConfig { uf_to_dl: false, dl_to_uf: true });
    let inst = setup_dl_to_uf_instance(&mut sess)?;
    assert_eq!(sess.check_sat(), CheckSat::Unsat);

    let events = sess.eqshare_events().expect("eqshare events missing");
    assert_has_eq_event(events, DirReq { src: dl, dst: uf }, inst.x, inst.y, "DL->UF should share x=y");
    Ok(())
}
```

---

### Ping-pong trace test: require both directions (and optionally the exact pairs)

```rust
use crate::trace_assert::{assert_has_any_dir_event, assert_has_eq_event};

#[test]
fn ping_pong_trace_has_both_hops() -> smt_core::Result<()> {
    let uf = TheoryId(0);
    let dl = TheoryId(1);

    let mut sess = common::make_session(SharingConfig { uf_to_dl: true, dl_to_uf: true });
    let inst = setup_ping_pong_instance(&mut sess)?;
    assert_eq!(sess.check_sat(), CheckSat::Unsat);

    let events = sess.eqshare_events().expect("eqshare events missing");

    // minimal: both directions present
    assert_has_any_dir_event(events, DirReq { src: uf, dst: dl }, "ping-pong should include UF->DL hop");
    assert_has_any_dir_event(events, DirReq { src: dl, dst: uf }, "ping-pong should include DL->UF hop");

    // stronger: exact key pairs present
    assert_has_eq_event(events, DirReq { src: uf, dst: dl }, inst.fa, inst.fb, "UF->DL should share f(a)=f(b)");
    assert_has_eq_event(events, DirReq { src: dl, dst: uf }, inst.x, inst.y, "DL->UF should share x=y");

    Ok(())
}
```

---

# 5) Make trace always available

Even when debug is off, it’s useful for tests. Two options:

* Always record trace events (cheap: a Vec push per import), but only dump DOT when debug enabled.
* Or record only when `test-debug` feature enabled. I’d do that:

In engine:

```rust
#[cfg(feature = "test-debug")]
self.eqshare_trace.push(...);
```

This keeps production clean.

---

If you want, I can show a neat pattern where each test calls `sess.take_eqshare_events()` (drains the trace) so events don’t accumulate across multiple `check_sat()` calls in the same session.
