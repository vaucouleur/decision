Great — let’s do two concrete upgrades:

1. **Make uninterpreted sorts use `SymbolId` directly** (cleaner + consistent with terms)
2. Add **small type-checking helpers** in `Context` that your SAT/theory layers can reuse.

Below are the exact changes.

---

## 1) Change `SortKind::Uninterpreted` to store `SymbolId`

### `crates/smt-core/src/sort.rs` (replace the uninterpreted bits)

```rust
use core::fmt;

use crate::ids::{SortId, SymbolId};

/// Public “view” of a sort (type). Internally, sorts are interned.
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Sort {
    /// Interned id.
    pub id: SortId,
}

/// The kind of sort. This is hash-consed via the `Context`.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum SortKind {
    Bool,
    Int,
    Real,
    BitVec { width: u32 },
    Array { index: SortId, elem: SortId },

    /// Uninterpreted sort, named by an interned symbol id (e.g. `U`, `MySort`).
    Uninterpreted { name: SymbolId },
}

impl fmt::Debug for Sort {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // Keep this lightweight; use PrettySort for nicer printing.
        write!(f, "{:?}", self.id)
    }
}
```

**Delete** the old `SortIdName` wrapper entirely (no longer needed).

---

### `crates/smt-core/src/context.rs` (update `mk_uninterpreted_sort`)

```rust
    /// Create or reuse an uninterpreted sort with a user-facing name.
    pub fn mk_uninterpreted_sort(&mut self, name: SymbolId) -> SortId {
        self.sorts.intern(SortKind::Uninterpreted { name })
    }
```

That’s it.

---

### `crates/smt-core/src/pretty.rs` (update printing of uninterpreted sorts)

Replace the `SortKind::Uninterpreted` arm in `fmt_sort` with:

```rust
        SortKind::Uninterpreted { name } => write!(f, "{}", ctx.sym_name(*name)),
```

So now `(declare-sort U 0)`-style names print nicely.

---

## 2) Add type-checking helpers in `Context`

These are intentionally small and composable; later crates (preprocess/theories/engine) can call them and get consistent error messages.

### `crates/smt-core/src/context.rs` (add these methods)

Add inside `impl Context { ... }`:

```rust
    // -------------------------------------------------------------------------
    // Sort/type helpers (reused by preprocess + theories + engine)
    // -------------------------------------------------------------------------

    /// Return the sort of a term (cheap: stored in the interned node).
    #[inline]
    pub fn term_sort(&self, t: TermId) -> SortId {
        let (_k, s) = self.term_node(t);
        s
    }

    /// Ensure `t` has sort Bool.
    #[inline]
    pub fn ensure_bool(&self, t: TermId) -> crate::Result<()> {
        let s = self.term_sort(t);
        if s == self.bool_sort() {
            Ok(())
        } else {
            Err(Error::SortError("expected Bool term".to_string()))
        }
    }

    /// Ensure two terms have the same sort. Returns that sort if OK.
    #[inline]
    pub fn ensure_same_sort(&self, a: TermId, b: TermId) -> crate::Result<SortId> {
        let sa = self.term_sort(a);
        let sb = self.term_sort(b);
        if sa == sb {
            Ok(sa)
        } else {
            Err(Error::SortError("expected terms of the same sort".to_string()))
        }
    }

    /// Ensure term has the given sort.
    #[inline]
    pub fn ensure_sort(&self, t: TermId, expected: SortId) -> crate::Result<()> {
        let s = self.term_sort(t);
        if s == expected {
            Ok(())
        } else {
            Err(Error::SortError("term has unexpected sort".to_string()))
        }
    }

    /// If `t` is a BV term, return its bit-width.
    #[inline]
    pub fn bv_width_of(&self, t: TermId) -> crate::Result<u32> {
        match self.sort_kind(self.term_sort(t)) {
            SortKind::BitVec { width } => Ok(*width),
            _ => Err(Error::SortError("expected BitVec term".to_string())),
        }
    }

    /// Ensure all terms are Bool.
    pub fn ensure_all_bool(&self, args: impl IntoIterator<Item = TermId>) -> crate::Result<()> {
        for t in args {
            self.ensure_bool(t)?;
        }
        Ok(())
    }
```

Now you can simplify your constructors.

---

## 3) Tighten the convenience constructors using the helpers

### `mk_eq`

Replace your current `mk_eq` with:

```rust
    /// Convenience: (= a b)
    pub fn mk_eq(&mut self, a: TermId, b: TermId) -> crate::Result<TermId> {
        self.ensure_same_sort(a, b)?;
        self.mk_app(Op::new(OpKind::Eq), [a, b], self.bool_sort())
    }
```

### `mk_not`

```rust
    /// Convenience: (not a)
    pub fn mk_not(&mut self, a: TermId) -> crate::Result<TermId> {
        self.ensure_bool(a)?;
        self.mk_app(Op::new(OpKind::Not), [a], self.bool_sort())
    }
```

### `mk_and` / `mk_or`

```rust
    /// Convenience: (and ...)
    pub fn mk_and(&mut self, args: impl IntoIterator<Item = TermId>) -> crate::Result<TermId> {
        // If you don’t want to iterate twice, collect to SmallVec first.
        let args: SmallVec<[TermId; 4]> = args.into_iter().collect();
        self.ensure_all_bool(args.iter().copied())?;
        self.mk_app(Op::new(OpKind::And), args, self.bool_sort())
    }

    /// Convenience: (or ...)
    pub fn mk_or(&mut self, args: impl IntoIterator<Item = TermId>) -> crate::Result<TermId> {
        let args: SmallVec<[TermId; 4]> = args.into_iter().collect();
        self.ensure_all_bool(args.iter().copied())?;
        self.mk_app(Op::new(OpKind::Or), args, self.bool_sort())
    }
```

### `mk_ite`

```rust
    /// Convenience: (ite c t e)
    pub fn mk_ite(&mut self, c: TermId, t: TermId, e: TermId) -> crate::Result<TermId> {
        self.ensure_bool(c)?;
        let s = self.ensure_same_sort(t, e)?;
        self.mk_app(Op::new(OpKind::Ite), [c, t, e], s)
    }
```

This makes the API consistent and keeps sort logic in one place.

---

## 4) One small cleanup: `mk_app` minimal checks

Given the helpers above, you can choose to keep `mk_app` “dumb” (trust callers) *or* keep only essential guardrails. My suggestion:

* Keep `mk_app` mostly dumb (fast, low policy)
* Put “policy” in typed convenience constructors and in later layers (preprocess/theories)

So your `mk_app` can simply intern:

```rust
    /// Low-level application constructor (hash-consed).
    ///
    /// This does not attempt full type inference. Prefer typed helpers like `mk_eq`, `mk_and`, etc.
    pub fn mk_app(
        &mut self,
        op: Op,
        args: impl IntoIterator<Item = TermId>,
        result_sort: SortId,
    ) -> crate::Result<TermId> {
        let args: SmallVec<[TermId; 4]> = args.into_iter().collect();
        Ok(self.terms.intern(TermKind::App { op, args }, result_sort))
    }
```

---

If you want the next step, I’d implement a *typed layer* on top of `Context` (e.g. `BoolTerm`, `BvTerm { width }`, `IntTerm`) using newtypes that carry `TermId` + enforce invariants at construction. That makes later solver code *much* cleaner without paying runtime cost.
