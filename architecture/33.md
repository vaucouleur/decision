Here’s a tight **end-to-end regression demo** that becomes **UNSAT only if UF↔DL equality sharing works**, plus the **classifier wiring** so *int-valued UF terms* participate correctly.

---

# 1) The combination-critical formula

Let:

* `U` be an uninterpreted sort
* `a, b : U`
* `f : U → Int` (UF function returning Int)

Constraints:

1. `a = b` (UF)
2. `f(a) ≤ 0` (DL)
3. `f(b) ≥ 1` (DL)

Alone:

* UF knows `a=b` ⇒ `f(a)=f(b)` (congruence), **but DL does not know it** unless equality is shared/imported.
* DL constraints alone are satisfiable unless it also knows `f(a)=f(b)`.

With equality sharing:

* UF exports `f(a)=f(b)` with explanation from `a=b`
* DL imports `f(a)=f(b)` as two zero-weight edges
* Then DL sees `f(a) ≤ 0` and `f(b) ≥ 1` become inconsistent (since they’re equal), and it derives a conflict.

That’s exactly the “hello Nelson–Oppen” baby-step.

---

# 2) What has to be shared

The shared terms are:

* `f(a)` and `f(b)` (Int sort terms)

They appear in DL atoms (`f(a) ≤ 0`, `f(b) ≥ 1`) and in UF-derived equality (`f(a)=f(b)`), so your `compute_shared_terms()` based on `atom_endpoints()` must include them.

So:

* DL’s `atom_endpoints(atom_term)` must return `(x, y)` from `x - y ≤ c`, i.e. endpoints include `x` and `y` (including `f(a)` as a TermId)
* UF’s `atom_endpoints(eq_atom)` returns `(lhs, rhs)` (which for `(= a b)` includes `a,b` but not `f(a)` directly)
* However, UF’s **exported equality** should be filtered by the shared set and include `f(a)=f(b)` because `f(a)` and `f(b)` are in `shared`.

That means UF must be able to *discover* congruence equalities on shared terms. Easiest is: export from UF the equalities between **applications** that are now in the same e-class and are shared.

---

# 3) A practical UF export that catches `f(a)=f(b)`

In the UF CC, you already have `class_parents` = list of applications that have an argument in the class. That’s perfect.

Minimal export rule:

* iterate over *shared* terms `t` that are UF apps
* if `t`’s representative equals another shared app’s rep, export equality for that pair

But pairwise over all shared apps can be O(m²). For a regression demo, fine.

Better minimal: bucket shared apps by their representative and export one spanning tree per bucket.

Pseudo:

```rust
let mut buckets: HashMap<NodeId, Vec<TermId>> = ...
for each shared TermId t:
  if is_uf_app(t):
     let rep = uf.find(ensure_term(t))
     buckets[rep].push(t)

for each bucket with >=2 terms:
  pick head h
  for each other t in bucket:
     export (h = t) with explanation uf.explain_eq(h,t)
```

This guarantees you’ll export `f(a)=f(b)` once UF has merged `a` and `b`.

---

# 4) Classifier wiring for int-valued UF applications

You want:

* `Le/Lt` on Int terms → DL
* `Eq` on UF-ish terms → UF, even if those terms are Int sort (like `f(a) = f(b)`)
* `Eq` on pure arithmetic (optional) → DL later

A robust heuristic:

* An equality `x = y` is UF-owned if either side contains a UF application symbol (OpKind::Uf).
* Otherwise, leave it boolean/pure (or DL).

### `crates/smt-engine/src/classifier.rs`

```rust
use smt_core::{Context, TermId, TermKind, SortKind};
use crate::atoms::TheoryId;
use crate::propositionalize::AtomClassifier;

pub struct UfDlClassifier {
    pub uf: TheoryId,
    pub dl: TheoryId,
}

impl UfDlClassifier {
    fn contains_uf_app(&self, ctx: &Context, t: TermId) -> bool {
        let (k, _) = ctx.term_node(t);
        match k {
            TermKind::App { op, args } => {
                if matches!(op.kind, smt_core::OpKind::Uf(_)) {
                    return true;
                }
                // recurse
                args.iter().any(|&a| self.contains_uf_app(ctx, a))
            }
            _ => false,
        }
    }
}

impl AtomClassifier for UfDlClassifier {
    fn classify_bool_term(&self, ctx: &Context, atom: TermId) -> Option<TheoryId> {
        let (k, s) = ctx.term_node(atom);
        if s != ctx.bool_sort() {
            return None;
        }

        let TermKind::App { op, args } = k else { return None; };

        match op.kind {
            smt_core::OpKind::Le | smt_core::OpKind::Lt => {
                // DL if both args are Int
                if args.len() == 2
                    && ctx.sort_kind(ctx.term_sort(args[0])) == SortKind::Int
                    && ctx.sort_kind(ctx.term_sort(args[1])) == SortKind::Int
                {
                    return Some(self.dl);
                }
                None
            }

            smt_core::OpKind::Eq => {
                if args.len() != 2 { return None; }

                let a = args[0];
                let b = args[1];

                // UF owns equalities involving UF applications (including Int-returning ones).
                if self.contains_uf_app(ctx, a) || self.contains_uf_app(ctx, b) {
                    return Some(self.uf);
                }

                // Optional: DL owns equality between pure Int terms, if you implement it.
                // For now, let it be "generic bool" or treat as UF as well.
                None
            }

            _ => None,
        }
    }
}
```

---

# 5) The regression test / demo program

Assuming your `Session` API exists, and you have:

* `declare_uninterpreted_sort`
* `declare_const`
* `declare_ufun` (symbol)
* `app_uf`
* integer constants / comparisons constructors (or a generic `le(term,int)` builder)

Here’s a demo in pseudo-Rust that uses your `Context` ops:

### `crates/smt-demo/src/uf_dl_combo.rs`

```rust
use std::sync::Arc;

use smt_api::Session;
use smt_api::CheckSat;
use smt::Label;

fn main() -> smt_core::Result<()> {
    let ctx = Arc::new(smt_core::Context::default());

    // Build engine with UF + DL theories and classifier UfDlClassifier
    let mut sess = build_session_with_uf_and_dl(ctx.clone());

    let u = sess.declare_uninterpreted_sort("U");
    let a = sess.declare_const("a", u);
    let b = sess.declare_const("b", u);

    // f: U -> Int
    let f = sess.declare_ufun("f");
    let int_sort = sess.ctx().int_sort();

    let fa = sess.app_uf(f, &[a], int_sort)?;
    let fb = sess.app_uf(f, &[b], int_sort)?;

    // 1) a = b
    let ab = sess.eq(a, b)?;
    sess.assert(ab, Some("AB"))?;

    // 2) f(a) <= 0
    let zero = sess.ctx().int_const(0);
    let fa_le_0 = sess.ctx().le(fa, zero)?;
    sess.assert(fa_le_0, Some("FA_LE_0"))?;

    // 3) f(b) >= 1   ->  1 <= f(b)
    let one = sess.ctx().int_const(1);
    let one_le_fb = sess.ctx().le(one, fb)?;
    sess.assert(one_le_fb, Some("FB_GE_1"))?;

    match sess.check_sat() {
        CheckSat::Sat => {
            println!("SAT (BUG: equality sharing not working?)");
        }
        CheckSat::Unsat => {
            println!("UNSAT (expected)");
            println!("core: {:?}", sess.get_unsat_core());
        }
    }

    Ok(())
}
```

**Expected result:** `UNSAT` and the core should contain labels `AB`, `FA_LE_0`, `FB_GE_1` (or at least a subset containing those).

If you disable equality sharing, this will likely become `SAT` → excellent regression signal.

---

# 6) Engine wiring: build session with UF + DL

Your builder should:

* create theories: `UfTheory` (reasoned) and `DlTheory` (reasoned)
* create `AtomTable`
* create `SmtEngine<ToyCdcl>` with those theories
* create classifier `UfDlClassifier { uf: TheoryId(0), dl: TheoryId(1) }`

Also: when propositionalizing and registering atoms:

* if classifier returns UF for an `Eq` atom, call `UfTheory::register_eq_atom`
* if classifier returns DL for a `Le/Lt` atom, call `DlTheory::register_dl_atom`

This is typically done inside your incremental boolean encoder when it detects a term is a theory atom:

* allocate var
* register into `AtomTable`
* call theory’s registration method

---

# 7) One important UF export tweak (so the demo works)

In UF’s `export_equalities`, don’t just export *existing UF atoms*. Also export equalities between **shared application terms** that are in the same class (that’s how you get `f(a)=f(b)`).

Add this export pass:

```rust
// Build buckets of shared UF-app terms by representative
let mut buckets: HashMap<NodeId, Vec<TermId>> = ...
for t in shared_terms:
  if ctx.is_uf_app(t) {
     let n = uf.ensure_term(t, tcx);
     let r = uf.find(n);
     buckets[r].push(t);
  }

for each bucket with >=2:
  let head = bucket[0]
  for other in bucket[1..]:
    let rid = uf.explain_eq(ensure(head), ensure(other), tcx).unwrap();
    out.push(SharedEq { a: head, b: other, explain: rid });
```

That’s the key to making the regression example a guaranteed UNSAT when sharing is on.

---

If you want, I can also give you a second regression that goes the other direction (DL exports an equality that UF needs), but the one above is the classic “UF creates equality over Int terms, DL needs it” smoke test.
