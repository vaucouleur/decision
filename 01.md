If you look at **veriT**, **Z3**, **cvc5**, **Bitwuzla**, the common “shape” is a **modular CDCL(T) / DPLL(T) core**: a SAT engine + a theory-combination interface, with separate theory solvers and preprocessing/proof infrastructure. Z3’s classic architecture description literally calls out SAT + a core equality/UF solver + “satellite solvers” (arith/arrays/…) + quantifier machinery. ([algos.inesc-id.pt][1])
Bitwuzla and cvc5 also emphasize “componentized” architectures, and cvc5 in particular invests in a **flexible proof-production module** that spans preprocessing, SAT, theories, etc. ([theory.stanford.edu][2])
veriT is explicitly **proof-producing** (that’s central to its identity). ([verit.loria.fr][3])

Below is a Rust architecture that stays **beautiful**, **customizable**, and (importantly) **portable/safe across linkers** (no “magic” global constructors required).

---

## 1) Core design goals (Rust-friendly)

### A. “Small stable kernel, everything else is a component”

Keep one crate that owns the *semantic invariants*:

* term representation + interning / hash-consing
* sorts/types
* scoped context (push/pop)
* common utilities (rewriting hooks, stats, tracing, error types)

Everything else (SAT engine, e-graph, bit-blaster, arithmetic solver, quantifiers, proofs) plugs in via traits.

### B. Terms are IDs, not trees

Nearly all serious SMT solvers use DAGs with maximal sharing (Bitwuzla explicitly describes immutable DAG nodes + hash-consing). ([Computer Science][4])
In Rust, make “terms” cheap handles:

```rust
/// Opaque handle to an interned term node.
/// Copy, comparable, hashable: perfect for watchlists and e-graphs.
#[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct TermId(u32);

/// Opaque handle to an interned sort/type node.
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct SortId(u32);
```

Back them by an arena + interner so clones are trivial and sharing is guaranteed.

### C. Customization without linker tricks

Avoid relying on `ctor`/link-section registration for “plugins” if you want maximum portability.
Prefer:

* `SolverBuilder` that explicitly receives components
* optional feature-gated convenience constructors

(You *can* add `inventory`/`linkme` later for “auto registration”, but keep it an optional layer.)

---

## 2) Crate layout that scales (and reads nicely)

A clean split that people will instantly recognize:

```
smt/
  crates/
    smt-core/          # Term DAG, sorts, Context, scopes, rewriting API, errors
    smt-smt2/          # SMT-LIB2 parser/printer (library-first)
    smt-engine/        # Orchestrates CDCL(T): SAT + theory combination + model/proof
    smt-sat/           # CDCL SAT solver (or wrapper over an embedded one)
    smt-egraph/        # Congruence closure / e-graph utilities (optional)
    smt-preprocess/    # CNF, skolemization, simplification passes
    smt-proof/         # Proof objects, proof streams, checkers/emitters
    smt-theory-uf/     # UF + equality engine glue
    smt-theory-lia/    # Linear int arith (or just a stub at first)
    smt-theory-bv/     # Bit-vectors (bit-blast + lemmas)
    smt-quant/         # E-matching / MBQI hooks (optional)
    smt-cli/           # Binary: options, files, REPL
  smt/                 # top-level “facade” crate re-exporting a nice API
```

**Facade pattern**:

* `smt` crate exposes the stable API
* internal crates can evolve faster without breaking users

---

## 3) The “engine” is a pipeline + event loop

Think of your solver as two interacting layers:

### Layer 1 — preprocessing pipeline

* parsing
* rewriting / simplification
* CNF / clausification
* optional theory-specific preprocessing (BV normalization, arithmetic canonicalization)

### Layer 2 — CDCL(T) loop

* SAT decides/propagates
* theories propagate/conflict/explain
* learn clauses
* repeat

This matches the modular theme described for modern SMT solvers (CDCL(T) as the cooperation framework). ([theory.stanford.edu][5])

---

## 4) The key traits (your customization points)

Here’s a minimal set that stays ergonomic and “pretty” in Rustdocs.

```rust
/// A theory module that can participate in CDCL(T).
///
/// Design notes:
/// - `push/pop` are required for incremental solving.
/// - `propagate` adds implied literals (with explanations).
/// - `check` reports consistency or a conflict clause.
/// - Everything is expressed in terms of `TermId` and `Lit` to stay DAG-based.
pub trait Theory {
    /// Human-readable name for logs/stats.
    fn name(&self) -> &'static str;

    /// Called when the engine enters a new incremental scope.
    fn push(&mut self);

    /// Backtrack `n` scopes.
    fn pop(&mut self, n: usize);

    /// Inform the theory that a literal became true at the SAT level.
    fn on_assign(&mut self, lit: Lit, ctx: &mut TheoryCtx) -> Result<(), Conflict>;

    /// Ask the theory to produce propagations, if any.
    fn propagate(&mut self, ctx: &mut TheoryCtx) -> Result<Vec<Propagation>, Conflict>;

    /// Final consistency check at a SAT model candidate.
    fn check(&mut self, ctx: &mut TheoryCtx) -> Result<(), Conflict>;

    /// Optionally contribute to model construction.
    fn model_value(&self, term: TermId, ctx: &TheoryModelCtx) -> Option<Value>;
}

/// A preprocessing pass (simplifier, normalizer, CNF, …).
pub trait PreprocessPass {
    fn name(&self) -> &'static str;
    fn run(&mut self, input: TermId, ctx: &mut PreprocessCtx) -> TermId;
}

/// Proof recorder / emitter.
/// cvc5’s approach is “proof generators transmitted between components”
/// (so components can justify steps without hard-coding a single monolithic proof). :contentReference[oaicite:5]{index=5}
pub trait ProofSink {
    fn record_step(&mut self, step: ProofStep);
}
```

**Customization** becomes trivial:

* swap SAT solver
* add/remove theory modules
* enable/disable proof production
* choose preprocessing passes

---

## 5) Builder API: explicit, feature-gated convenience

```rust
/// Public entry point (facade crate).
pub struct SolverBuilder {
    passes: Vec<Box<dyn PreprocessPass>>,
    theories: Vec<Box<dyn Theory>>,
    proof: Option<Box<dyn ProofSink>>,
    options: Options,
}

impl SolverBuilder {
    /// Create a builder with sane defaults (can be empty).
    pub fn new() -> Self { /* ... */ }

    /// Add a preprocessing pass.
    pub fn with_pass(mut self, pass: impl PreprocessPass + 'static) -> Self {
        self.passes.push(Box::new(pass));
        self
    }

    /// Add a theory module (UF, BV, LIA, Arrays…).
    pub fn with_theory(mut self, th: impl Theory + 'static) -> Self {
        self.theories.push(Box::new(th));
        self
    }

    /// Enable proof production.
    pub fn with_proofs(mut self, sink: impl ProofSink + 'static) -> Self {
        self.proof = Some(Box::new(sink));
        self
    }

    /// Build the solver instance.
    pub fn build(self) -> Solver { /* wires engine */ }
}
```

Then add **feature-gated presets**:

```rust
impl SolverBuilder {
    /// A “typical” QF_UF + LIA preset.
    #[cfg(feature = "preset-qf_uf_lia")]
    pub fn preset_qf_uf_lia() -> Self {
        Self::new()
            .with_theory(smt_theory_uf::UfTheory::new())
            .with_theory(smt_theory_lia::LiaTheory::new())
            .with_pass(smt_preprocess::Simplify::default())
    }
}
```

This gives you **compile-time configurability** without forcing the main crate to “know all crates” except when the user chooses a preset/feature.

---

## 6) Proofs: make it a first-class, optional subsystem

If you want “a la veriT”, proofs aren’t an afterthought. veriT is explicitly proof-producing and its proof format is designed to be reconstructible in proof assistants. ([verit.loria.fr][3])
cvc5 shows what “industrial” proof plumbing looks like: proofs across preprocessing, SAT, and theories, with flexibility and reconstruction. ([Computer Science][6])

In Rust terms:

* keep a small `smt-proof` crate that defines `ProofStep`, `RuleId`, `ProofTermRef`
* each component optionally returns “explanations” as proof objects
* the engine streams them into a sink (LFSC-like, Alethe-like, or your own)

Critically: **make proofs zero-cost when disabled** via `cfg(feature="proofs")` and a `NoopProofSink`.

---

## 7) Internals that matter for performance *and* cleanliness

* **Node manager (interning)**: hash-consing for terms/sorts; keep it behind `Context`.
* **Scopes**: every component supports `push/pop` with a trail (classic SMT requirement; also critical for usability).
* **Shared rewriting**: one canonical rewriter interface used by preprocess passes and theories.
* **Stats & tracing**: instrument with `tracing` spans; users love it when debugging.
* **Divergence-friendly tests**: differential testing against Z3/cvc5/Bitwuzla is extremely effective for SMT.

---

## 8) What to copy (conceptually) from the solvers you cited

* **Z3**: “SAT + core equality/UF + satellite solvers” modularity. ([algos.inesc-id.pt][1])
* **cvc5**: treat proof production as a cross-cutting architecture, not a bolt-on. ([theory.stanford.edu][2])
* **Bitwuzla**: immutable DAG nodes + maximal sharing; multiple solving contexts with shared node storage is a good pattern to aim for. ([Computer Science][4])
* **veriT**: proof-first identity and a focused theory set (start small, be excellent). ([verit.loria.fr][3])

---

## 9) A practical “starter roadmap” that won’t paint you into a corner

1. **smt-core**: terms/sorts + SMT-LIB2 parser/printer + rewriting
2. **QF_UF** with congruence closure/e-graph + SAT (enough to solve lots of benchmarks)
3. incremental `push/pop`, assumptions, model for UF
4. add a proof skeleton (`ProofSink`, “explain” objects), even if incomplete
5. only then add BV or LIA (each as its own crate + feature)

---

If you tell me which *first logic* you want to support (e.g., **QF_UF**, **QF_BV**, **QF_LIA**, or “veriT-like”: UF + linear arithmetic), I’ll propose:

* the exact initial crate list to implement,
* the minimal set of literals/clauses/rewrites you need,
* and a concrete “first 10k LOC” plan that stays extensible.

[1]: https://algos.inesc-id.pt/projects/timewarp/ref13.pdf?utm_source=chatgpt.com "Z3: An Efficient SMT Solver"
[2]: https://theory.stanford.edu/~barrett/pubs/BRK%2B22.pdf?utm_source=chatgpt.com "Flexible Proof Production in an Industrial-Strength SMT Solver"
[3]: https://verit.loria.fr/?utm_source=chatgpt.com "The veriT solver"
[4]: https://cs.stanford.edu/~preiner/talks/Preiner-CENTAUR23.pdf?utm_source=chatgpt.com "Bitwuzla: A New SMT Solver For Bit-Precise Reasoning"
[5]: https://theory.stanford.edu/~nikolaj/z3navigate.html?utm_source=chatgpt.com "Navigating the Universe of Z3 Theory Solvers"
[6]: https://www-cs.stanford.edu/~preiner/publications/2022/BarbosaBBKLMMMN-TACAS22.pdf?utm_source=chatgpt.com "cvc5: A Versatile and Industrial-Strength SMT Solver"
