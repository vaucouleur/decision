Below is a **compact “golden” set** of the three matrix tests that combines:

* SAT/UNSAT matrix checks
* (optional but recommended) UNSAT core group assertions
* trace assertions using the macros:

  * `assert_eqshare_events_empty!`
  * `assert_eqshare_dir!`
  * `assert_eqshare_hop!`
  * `assert_eqshare_hop_none!`
* bundle-on-failure rerun for mismatches (so you automatically get `target/smt-debug-.../` when something breaks)

I’m assuming you already have:

* `make_session(SharingConfig)`
* `setup_*_instance(&mut Session) -> Result<InstanceStruct>`
* `Session::take_eqshare_events() -> Vec<EqShareEvent>`
* core helpers (`assert_unsat_core_contains_any`), optional

---

# `crates/smt-tests/src/equality_sharing_golden.rs`

```rust
#![forbid(unsafe_code)]

use smt_api::CheckSat;
use smt_engine::config::SharingConfig;

use crate::bundle_on_failure::{assert_sat_with_bundle_on_mismatch, Expect};
use crate::core_assert::{assert_unsat_core_contains_any, CoreReq};
use crate::{
    assert_eqshare_dir,
    assert_eqshare_events_empty,
    assert_eqshare_hop,
    assert_eqshare_hop_none,
};

mod common;
use common::make_session;

// ----- Instances returned by setup -----

#[derive(Debug, Clone, Copy)]
struct UfToDlInst {
    fa: smt_core::TermId,
    fb: smt_core::TermId,
}

#[derive(Debug, Clone, Copy)]
struct DlToUfInst {
    x: smt_core::TermId,
    y: smt_core::TermId,
}

#[derive(Debug, Clone, Copy)]
struct PingPongInst {
    fa: smt_core::TermId,
    fb: smt_core::TermId,
    x: smt_core::TermId,
    y: smt_core::TermId,
}

// ----- Setup functions (adapt from your existing ones) -----

fn setup_uf_to_dl(sess: &mut smt_api::Session) -> smt_core::Result<UfToDlInst> {
    let u = sess.declare_uninterpreted_sort("U");
    let a = sess.declare_const("a", u);
    let b = sess.declare_const("b", u);

    let f = sess.declare_ufun("f");
    let int = sess.ctx().int_sort();
    let fa = sess.app_uf(f, &[a], int)?;
    let fb = sess.app_uf(f, &[b], int)?;

    sess.assert(sess.eq(a, b)?, Some("AB"))?;

    let zero = sess.ctx().int_const(0);
    sess.assert(sess.ctx().le(fa, zero)?, Some("FA_LE_0"))?;

    let one = sess.ctx().int_const(1);
    sess.assert(sess.ctx().le(one, fb)?, Some("FB_GE_1"))?;

    Ok(UfToDlInst { fa, fb })
}

fn setup_dl_to_uf(sess: &mut smt_api::Session) -> smt_core::Result<DlToUfInst> {
    let int = sess.ctx().int_sort();
    let x = sess.declare_const("x", int);
    let y = sess.declare_const("y", int);

    let u = sess.declare_uninterpreted_sort("U");
    let g = sess.declare_ufun("g");

    let gx = sess.app_uf(g, &[x], u)?;
    let gy = sess.app_uf(g, &[y], u)?;

    sess.assert(sess.ctx().le(x, y)?, Some("X_LE_Y"))?;
    sess.assert(sess.ctx().le(y, x)?, Some("Y_LE_X"))?;

    sess.assert(sess.not(sess.eq(gx, gy)?)?, Some("GX_NE_GY"))?;

    Ok(DlToUfInst { x, y })
}

fn setup_ping_pong(sess: &mut smt_api::Session) -> smt_core::Result<PingPongInst> {
    let u = sess.declare_uninterpreted_sort("U");
    let int = sess.ctx().int_sort();

    let a = sess.declare_const("a", u);
    let b = sess.declare_const("b", u);

    let x = sess.declare_const("x", int);
    let y = sess.declare_const("y", int);

    let f = sess.declare_ufun("f"); // U -> Int
    let g = sess.declare_ufun("g"); // Int -> U

    let fa = sess.app_uf(f, &[a], int)?;
    let fb = sess.app_uf(f, &[b], int)?;
    let gx = sess.app_uf(g, &[x], u)?;
    let gy = sess.app_uf(g, &[y], u)?;

    sess.assert(sess.eq(a, b)?, Some("A_EQ_B"))?;

    // x = f(a)
    sess.assert(sess.ctx().le(x, fa)?, Some("X_LE_FA"))?;
    sess.assert(sess.ctx().le(fa, x)?, Some("FA_LE_X"))?;

    // y = f(b)
    sess.assert(sess.ctx().le(y, fb)?, Some("Y_LE_FB"))?;
    sess.assert(sess.ctx().le(fb, y)?, Some("FB_LE_Y"))?;

    sess.assert(sess.not(sess.eq(gx, gy)?)?, Some("GX_NE_GY"))?;

    Ok(PingPongInst { fa, fb, x, y })
}

// ----- The Golden Tests -----

#[test]
fn golden_uf_to_dl_matrix() -> smt_core::Result<()> {
    // Row: both off => SAT, no events
    {
        let mut sess = make_session(SharingConfig { uf_to_dl: false, dl_to_uf: false });
        let _ = setup_uf_to_dl(&mut sess)?;
        assert_eq!(sess.check_sat(), CheckSat::Sat);
        let events = sess.take_eqshare_events();
        assert_eqshare_events_empty!(&events);
    }

    // Row: UF->DL only => UNSAT, must see fa=fb hop UF->DL
    {
        // SAT/UNSAT with bundle on mismatch
        assert_sat_with_bundle_on_mismatch(
            || make_session(SharingConfig { uf_to_dl: true, dl_to_uf: false }),
            |s| { setup_uf_to_dl(s).map(|_| ()) },
            Expect::Unsat,
        )?;

        // Stronger: core shape (optional but good)
        assert_unsat_core_contains_any(
            || make_session(SharingConfig { uf_to_dl: true, dl_to_uf: false }),
            |s| { setup_uf_to_dl(s).map(|_| ()) },
            &[
                CoreReq { name: "UF equality", any_of: &["AB"] },
                CoreReq { name: "DL fa constraint", any_of: &["FA_LE_0"] },
                CoreReq { name: "DL fb constraint", any_of: &["FB_GE_1"] },
            ],
        )?;

        // Trace: exact hop
        let mut sess = make_session(SharingConfig { uf_to_dl: true, dl_to_uf: false });
        let inst = setup_uf_to_dl(&mut sess)?;
        assert_eq!(sess.check_sat(), CheckSat::Unsat);
        let events = sess.take_eqshare_events();

        assert_eqshare_dir!(&events, UF => DL);
        assert_eqshare_hop!(&events, UF => DL, inst.fa, inst.fb);
        // DL->UF should not occur in this config
        assert_eqshare_hop_none!(&events, DL => UF, [(inst.fa, inst.fb)]); // any pair is fine; direction is what matters
    }

    // Row: DL->UF only => SAT (UF->DL disabled), no UF->DL hop
    {
        let mut sess = make_session(SharingConfig { uf_to_dl: false, dl_to_uf: true });
        let inst = setup_uf_to_dl(&mut sess)?;
        assert_eq!(sess.check_sat(), CheckSat::Sat);
        let events = sess.take_eqshare_events();
        assert_eqshare_hop_none!(&events, UF => DL, [(inst.fa, inst.fb)]);
    }

    Ok(())
}

#[test]
fn golden_dl_to_uf_matrix() -> smt_core::Result<()> {
    // both off => SAT, no events
    {
        let mut sess = make_session(SharingConfig { uf_to_dl: false, dl_to_uf: false });
        let _ = setup_dl_to_uf(&mut sess)?;
        assert_eq!(sess.check_sat(), CheckSat::Sat);
        let events = sess.take_eqshare_events();
        assert_eqshare_events_empty!(&events);
    }

    // DL->UF only => UNSAT, must see x=y hop DL->UF
    {
        assert_sat_with_bundle_on_mismatch(
            || make_session(SharingConfig { uf_to_dl: false, dl_to_uf: true }),
            |s| { setup_dl_to_uf(s).map(|_| ()) },
            Expect::Unsat,
        )?;

        assert_unsat_core_contains_any(
            || make_session(SharingConfig { uf_to_dl: false, dl_to_uf: true }),
            |s| { setup_dl_to_uf(s).map(|_| ()) },
            &[
                CoreReq { name: "DL x<=y", any_of: &["X_LE_Y"] },
                CoreReq { name: "DL y<=x", any_of: &["Y_LE_X"] },
                CoreReq { name: "UF diseq", any_of: &["GX_NE_GY"] },
            ],
        )?;

        let mut sess = make_session(SharingConfig { uf_to_dl: false, dl_to_uf: true });
        let inst = setup_dl_to_uf(&mut sess)?;
        assert_eq!(sess.check_sat(), CheckSat::Unsat);
        let events = sess.take_eqshare_events();

        assert_eqshare_dir!(&events, DL => UF);
        assert_eqshare_hop!(&events, DL => UF, inst.x, inst.y);
        assert_eqshare_hop_none!(&events, UF => DL, [(inst.x, inst.y)]);
    }

    // UF->DL only => SAT, no DL->UF hop
    {
        let mut sess = make_session(SharingConfig { uf_to_dl: true, dl_to_uf: false });
        let inst = setup_dl_to_uf(&mut sess)?;
        assert_eq!(sess.check_sat(), CheckSat::Sat);
        let events = sess.take_eqshare_events();
        assert_eqshare_hop_none!(&events, DL => UF, [(inst.x, inst.y)]);
    }

    Ok(())
}

#[test]
fn golden_ping_pong_matrix() -> smt_core::Result<()> {
    // both off => SAT, no events
    {
        let mut sess = make_session(SharingConfig { uf_to_dl: false, dl_to_uf: false });
        let _ = setup_ping_pong(&mut sess)?;
        assert_eq!(sess.check_sat(), CheckSat::Sat);
        let events = sess.take_eqshare_events();
        assert_eqshare_events_empty!(&events);
    }

    // only UF->DL => SAT; must not see DL->UF hop x=y
    {
        let mut sess = make_session(SharingConfig { uf_to_dl: true, dl_to_uf: false });
        let inst = setup_ping_pong(&mut sess)?;
        assert_eq!(sess.check_sat(), CheckSat::Sat);
        let events = sess.take_eqshare_events();

        // UF->DL may happen (fa=fb), but DL->UF must not
        assert_eqshare_hop_none!(&events, DL => UF, [(inst.x, inst.y)]);
    }

    // only DL->UF => SAT; must not see UF->DL hop fa=fb
    {
        let mut sess = make_session(SharingConfig { uf_to_dl: false, dl_to_uf: true });
        let inst = setup_ping_pong(&mut sess)?;
        assert_eq!(sess.check_sat(), CheckSat::Sat);
        let events = sess.take_eqshare_events();

        assert_eqshare_hop_none!(&events, UF => DL, [(inst.fa, inst.fb)]);
    }

    // both => UNSAT; must see BOTH hops
    {
        assert_sat_with_bundle_on_mismatch(
            || make_session(SharingConfig { uf_to_dl: true, dl_to_uf: true }),
            |s| { setup_ping_pong(s).map(|_| ()) },
            Expect::Unsat,
        )?;

        assert_unsat_core_contains_any(
            || make_session(SharingConfig { uf_to_dl: true, dl_to_uf: true }),
            |s| { setup_ping_pong(s).map(|_| ()) },
            &[
                CoreReq { name: "UF diseq", any_of: &["GX_NE_GY"] },
                CoreReq { name: "UF a=b", any_of: &["A_EQ_B"] },
                CoreReq { name: "some DL equality constraints", any_of: &["X_LE_FA", "FA_LE_X", "Y_LE_FB", "FB_LE_Y"] },
            ],
        )?;

        let mut sess = make_session(SharingConfig { uf_to_dl: true, dl_to_uf: true });
        let inst = setup_ping_pong(&mut sess)?;
        assert_eq!(sess.check_sat(), CheckSat::Unsat);
        let events = sess.take_eqshare_events();

        assert_eqshare_dir!(&events, UF => DL);
        assert_eqshare_dir!(&events, DL => UF);

        assert_eqshare_hop!(&events, UF => DL, inst.fa, inst.fb);
        assert_eqshare_hop!(&events, DL => UF, inst.x, inst.y);
    }

    Ok(())
}
```

---

## Notes / small tweaks you might want

* In the UF→DL test, I used `assert_eqshare_hop_none!(events, DL => UF, [(fa, fb)])` just to assert the direction didn’t happen, but the pair is irrelevant there. If you want a direction-only negative assertion, I can add `assert_eqshare_dir_none!(events, DL => UF)` (cleaner).
* These tests assume UF is `TheoryId(0)` and DL is `TheoryId(1)`. If you reorder theories, update the constants in `eqshare_macros.rs`.

If you want that cleaner negative direction macro (`assert_eqshare_dir_none!`), say **yes**.
