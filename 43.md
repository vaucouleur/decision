Here’s a **single “UNSAT debug bundle”** helper that writes:

* `target/smt-debug/eqshare.dot` (equality-sharing graph)
* `target/smt-debug/conflict.dot` (reason DAG for the final conflict)
* `target/smt-debug/README.txt` (how to render + what files mean)

…and it does it in one call from the engine when UNSAT is detected.

---

# 1) Engine method: write debug bundle

### `crates/smt-engine/src/unsat_bundle.rs`

```rust
#![forbid(unsafe_code)]

use std::io::Write;
use std::path::Path;

use crate::reason::ReasonId;

/// Write a small set of DOT files that help debug why the solver concluded UNSAT.
pub fn write_unsat_debug_bundle<K: crate::sat_iface::SatKernel>(
    engine: &crate::engine::SmtEngine<K>,
    conflict_reason: ReasonId,
) {
    // Put all debug artifacts in one place.
    let dir = Path::new("target").join("smt-debug");
    if std::fs::create_dir_all(&dir).is_err() {
        return;
    }

    // 1) Equality-sharing exchanges graph
    let eqshare_dot = engine.dump_eqshare_dot();
    let eqshare_path = dir.join("eqshare.dot");
    let _ = std::fs::write(&eqshare_path, eqshare_dot.as_bytes());

    // 2) Conflict reason DAG
    let conflict_dot = engine.dump_conflict_reason_dot(conflict_reason);
    let conflict_path = dir.join("conflict.dot");
    let _ = std::fs::write(&conflict_path, conflict_dot.as_bytes());

    // 3) README
    let readme_path = dir.join("README.txt");
    let mut f = match std::fs::File::create(&readme_path) {
        Ok(f) => f,
        Err(_) => return,
    };

    let _ = writeln!(f, "SMT UNSAT DEBUG BUNDLE");
    let _ = writeln!(f, "");
    let _ = writeln!(f, "Files:");
    let _ = writeln!(f, "  - eqshare.dot   : graph of equality-sharing imports (edges labeled with src->dst and reason summary)");
    let _ = writeln!(f, "  - conflict.dot  : reason DAG for the final UNSAT conflict");
    let _ = writeln!(f, "");
    let _ = writeln!(f, "Render to SVG:");
    let _ = writeln!(f, "  dot -Tsvg eqshare.dot  > eqshare.svg");
    let _ = writeln!(f, "  dot -Tsvg conflict.dot > conflict.svg");
    let _ = writeln!(f, "");
    let _ = writeln!(f, "Tips:");
    let _ = writeln!(f, "  - In eqshare.svg, look for the expected hop(s) UF->DL and/or DL->UF.");
    let _ = writeln!(f, "  - In conflict.svg, leaves are SAT literals (vNN / ¬vNN).");
    let _ = writeln!(f, "  - If eqshare is empty, shared-term detection is likely too weak or export throttling too aggressive.");
    let _ = writeln!(f, "");
    let _ = writeln!(f, "Conflict root ReasonId: {}", conflict_reason.0);
}
```

---

# 2) Wire it into the engine UNSAT path

Wherever you turn a `TheoryConflict { explain: ReasonId }` into a SAT-level conflict / return UNSAT, add:

```rust
if self.config.debug_eq.enabled {
    crate::unsat_bundle::write_unsat_debug_bundle(self, conf.explain);
    eprintln!("[smt] wrote UNSAT debug bundle to target/smt-debug/");
}
```

Do the same if SAT kernel returns UNSAT and you have an “analyzed conflict reason” (if not, you can still dump eqshare.dot alone).

---

# 3) Ensure engine exposes the required dump methods

You already have (from earlier messages):

```rust
pub fn dump_eqshare_dot(&self) -> String { ... }
pub fn dump_conflict_reason_dot(&self, root: ReasonId) -> String { ... }
```

If you used `engine_debug.rs`, just re-export them.

---

# 4) Make it CI-friendly

In GitHub Actions, you can archive `target/smt-debug/*` when tests fail. Example (YAML idea):

* run tests with `SMT_EQSHARE_DEBUG=1`
* on failure, upload `target/smt-debug/` as an artifact

(You’ll likely set the env var only for the failing job or only for certain tests.)

---

# 5) Optional: auto-unique filenames per test run

If you run tests in parallel, multiple UNSAT bundles can overwrite each other. The simplest fix is to suffix with PID:

```rust
let pid = std::process::id();
let dir = Path::new("target").join(format!("smt-debug-{}", pid));
```

Or include `export_epoch` too.

---

If you want, I can show a small `cargo test` wrapper that automatically enables debug for only the three matrix tests (via env var matching the test name), so you don’t pay any overhead in normal runs.
