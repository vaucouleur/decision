Here’s `assert_eqshare_hop_any!` that passes if **any** candidate pair shows up for a given direction. This is perfect when UF exports a spanning tree and you don’t want to overfit to a specific pair.

---

## Add this macro to `eqshare_macros.rs`

Append to the same file (it reuses the existing helpers):

```rust
#[macro_export]
macro_rules! assert_eqshare_hop_any {
    // Candidates passed as a slice: &[(a,b), (c,d)]
    ($events:expr, UF => DL, $candidates:expr $(,)?) => {{
        let events = $events;
        let cands = $candidates;

        let ok = cands.iter().any(|(a, b)| {
            $crate::eqshare_macros::has_pair(
                events,
                $crate::eqshare_macros::UF,
                $crate::eqshare_macros::DL,
                *a,
                *b,
            )
        });

        if !ok {
            panic!(
                "missing eqshare hop UF=>DL for any candidate pair.\n\
                 candidates={:?}\n\
                 first events:\n{}",
                cands,
                $crate::eqshare_macros::dump(events)
            );
        }
    }};

    ($events:expr, DL => UF, $candidates:expr $(,)?) => {{
        let events = $events;
        let cands = $candidates;

        let ok = cands.iter().any(|(a, b)| {
            $crate::eqshare_macros::has_pair(
                events,
                $crate::eqshare_macros::DL,
                $crate::eqshare_macros::UF,
                *a,
                *b,
            )
        });

        if !ok {
            panic!(
                "missing eqshare hop DL=>UF for any candidate pair.\n\
                 candidates={:?}\n\
                 first events:\n{}",
                cands,
                $crate::eqshare_macros::dump(events)
            );
        }
    }};
}
```

---

## Example usage

Say your UF export may share either `(fa, fb)` or maybe `(fa, something_else)` depending on bucket head choice.

```rust
use crate::{assert_eqshare_hop_any};

let candidates = &[(inst.fa, inst.fb), (inst.fb, inst.fa)];
assert_eqshare_hop_any!(&events, UF => DL, candidates);
```

More realistic: accept several plausible exported pairs:

```rust
let candidates = &[
    (inst.fa, inst.fb),
    (inst.fa, inst.fa2),
    (inst.fb, inst.fb2),
];
assert_eqshare_hop_any!(&events, UF => DL, candidates);
```

---

## One small improvement (optional)

If you want the macro to accept a literal array without taking a reference:

```rust
assert_eqshare_hop_any!(&events, UF => DL, [
    (inst.fa, inst.fb),
    (inst.fa, inst.fa2),
]);
```

I can add that overload too, but the slice form is already ergonomic and avoids allocation.

If you want that overload, say **yes**.
