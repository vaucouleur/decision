Below is a **bounded Graphviz (DOT) dump** for a single **conflict reason DAG**, designed to be:

* small enough to paste into CI artifacts
* stable-ish (dedup nodes)
* useful: shows `ReasonId` nodes, their children, and leaf `Lit`s
* includes term-equality edges if you pass a label (optional)

You can render with `dot -Tsvg reason.dot > reason.svg`.

---

# 1) Add a DOT exporter for `ReasonArena`

### `crates/smt-engine/src/reason_dot.rs`

```rust
#![forbid(unsafe_code)]

use std::fmt::Write;

use hashbrown::{HashMap, HashSet};
use rustc_hash::FxHasher;
use core::hash::BuildHasherDefault;

use smt_sat::Lit;

use crate::reason::{Reason, ReasonArena, ReasonId};

type FxBuild = BuildHasherDefault<FxHasher>;

#[derive(Debug, Clone, Copy)]
pub struct DotLimits {
    /// Maximum number of Reason nodes to emit (prevents huge dumps)
    pub max_reason_nodes: usize,
    /// Maximum number of literals to show per Atom node label
    pub max_lit_label_len: usize,
}

impl Default for DotLimits {
    fn default() -> Self {
        Self {
            max_reason_nodes: 300,
            max_lit_label_len: 64,
        }
    }
}

/// Convert a literal to a compact label like "v12" or "¬v12".
fn fmt_lit(l: Lit) -> String {
    if l.is_pos() { format!("v{}", l.var().as_u32()) } else { format!("¬v{}", l.var().as_u32()) }
}

/// Dumps a bounded Reason DAG rooted at `root` to Graphviz DOT.
///
/// Nodes:
/// - Reason::And => box
/// - Reason::Atom => ellipse
///
/// Edges are directed parent -> child.
pub fn reason_to_dot(arena: &ReasonArena, root: ReasonId, limits: DotLimits) -> String {
    // BFS over ReasonId graph
    let mut queue = std::collections::VecDeque::new();
    let mut seen: HashSet<ReasonId, FxBuild> = HashSet::default();

    queue.push_back(root);
    seen.insert(root);

    let mut order = Vec::<ReasonId>::new();

    while let Some(r) = queue.pop_front() {
        order.push(r);
        if order.len() >= limits.max_reason_nodes {
            break;
        }

        match arena.get(r) {
            Reason::Atom(_) => {}
            Reason::And(kids) => {
                for &k in kids {
                    if seen.insert(k) {
                        queue.push_back(k);
                    }
                }
            }
        }
    }

    // Assign stable node names: r0, r1, ...
    let mut name: HashMap<ReasonId, String, FxBuild> = HashMap::default();
    for (i, rid) in order.iter().copied().enumerate() {
        name.insert(rid, format!("r{i}"));
    }

    let mut out = String::new();
    writeln!(&mut out, "digraph Reason {{").ok();
    writeln!(&mut out, "  rankdir=LR;").ok();
    writeln!(&mut out, "  node [fontname=\"Helvetica\"];").ok();

    // Nodes
    for rid in &order {
        let nid = &name[rid];
        match arena.get(*rid) {
            Reason::Atom(l) => {
                let mut lab = fmt_lit(*l);
                if lab.len() > limits.max_lit_label_len {
                    lab.truncate(limits.max_lit_label_len);
                }
                writeln!(
                    &mut out,
                    "  {nid} [shape=ellipse,label=\"{lab}\"];"
                ).ok();
            }
            Reason::And(kids) => {
                writeln!(
                    &mut out,
                    "  {nid} [shape=box,label=\"AND ({})\"];",
                    kids.len()
                ).ok();
            }
        }
    }

    // Edges
    for rid in &order {
        let src = &name[rid];
        if let Reason::And(kids) = arena.get(*rid) {
            for &k in kids {
                if let Some(dst) = name.get(&k) {
                    writeln!(&mut out, "  {src} -> {dst};").ok();
                }
            }
        }
    }

    // If truncated, add a warning node
    if seen.len() > order.len() {
        writeln!(&mut out, "  truncated [shape=note,label=\"TRUNCATED: max_reason_nodes reached\"];").ok();
        writeln!(&mut out, "  {} -> truncated [style=dashed];", name[&root]).ok();
    }

    writeln!(&mut out, "}}").ok();
    out
}
```

### Add `ReasonArena::get`

In `crates/smt-engine/src/reason.rs`, add:

```rust
impl ReasonArena {
    pub fn get(&self, rid: ReasonId) -> &Reason {
        &self.reasons[rid.0 as usize]
    }
}
```

---

# 2) Engine hook: dump conflict reason on UNSAT (debug-only)

Add a method to engine:

### `crates/smt-engine/src/engine_debug.rs`

```rust
#![forbid(unsafe_code)]

use crate::reason::ReasonId;

impl<K: crate::sat_iface::SatKernel> crate::engine::SmtEngine<K> {
    pub fn dump_conflict_reason_dot(&self, root: ReasonId) -> String {
        crate::reason_dot::reason_to_dot(
            &self.reasons,
            root,
            crate::reason_dot::DotLimits::default(),
        )
    }
}
```

Then, in the code path where you detect a theory conflict (right before returning / raising UNSAT), if debug enabled:

```rust
if self.config.debug_eq.enabled {
    let dot = self.dump_conflict_reason_dot(conf.explain);
    eprintln!("--- REASON DOT BEGIN ---\n{dot}\n--- REASON DOT END ---");
}
```

For tests, use `--nocapture` and redirect to a file, or better: write to `target/` with a unique name per test.

---

# 3) Nice CI behavior: write to file with deterministic name

Example snippet (in engine, behind debug flag):

```rust
let path = format!("target/reason_conflict_epoch_{}.dot", self.export_epoch);
if let Ok(()) = std::fs::write(&path, dot.as_bytes()) {
    eprintln!("[eqshare] wrote conflict reason dot to {path}");
}
```

If you’re running multiple tests in parallel, include test name or PID.

---

# 4) (Optional) Show term-equality context next to the reason

Sometimes you want to know “this conflict was DL negative cycle vs UF diseq”. You can put a “header” node:

* add an extra node with label like `Conflict: DL (negative cycle)`
* connect it to root

This is easy to add in `reason_to_dot` if you pass a `title: Option<String>`.

---

# 5) How to use

Run:

```bash
SMT_EQSHARE_DEBUG=1 cargo test -p smt-tests ping_pong -- --nocapture
```

Then render:

```bash
dot -Tsvg target/reason_conflict_epoch_42.dot > reason.svg
open reason.svg
```

---

If you want, I can also add a *second DOT view* that includes the **equality-sharing graph** (nodes are terms, edges are exported/imported equalities annotated with the exporting theory and reason root), which is extremely good for debugging “why didn’t this equality get shared?”.
