Here are two small macros (plus tiny helpers) that make the trace assertions read like English:

* `assert_eqshare_hop!(events, UF => DL, a, b);`
* `assert_eqshare_dir!(events, DL => UF);`

They use `TheoryId(0)` for UF and `TheoryId(1)` for DL by default (matching your setup), and give good failure messages.

---

## 1) Put this in a test-only module

### `crates/smt-tests/src/eqshare_macros.rs`

```rust
#![forbid(unsafe_code)]

use smt_core::TermId;
use smt_engine::atoms::TheoryId;
use smt_engine::eqshare_trace::EqShareEvent;

/// Helper: do we have an event with direction + unordered pair?
fn has_pair(events: &[EqShareEvent], src: TheoryId, dst: TheoryId, a: TermId, b: TermId) -> bool {
    events.iter().any(|e| {
        e.src == src
            && e.dst == dst
            && ((e.a == a && e.b == b) || (e.a == b && e.b == a))
    })
}

/// Helper: do we have any event with the direction?
fn has_dir(events: &[EqShareEvent], src: TheoryId, dst: TheoryId) -> bool {
    events.iter().any(|e| e.src == src && e.dst == dst)
}

/// Pretty-ish dump of first few events for panic messages.
fn dump(events: &[EqShareEvent]) -> String {
    events
        .iter()
        .take(40)
        .map(|e| format!("epoch={} {:?}->{:?} a={:?} b={:?} reason={:?}", e.epoch, e.src, e.dst, e.a, e.b, e.explain))
        .collect::<Vec<_>>()
        .join("\n")
}

/// Map symbolic UF/DL identifiers used by macros to TheoryId.
/// Adjust these if you change theory ordering.
pub const UF: TheoryId = TheoryId(0);
pub const DL: TheoryId = TheoryId(1);

#[macro_export]
macro_rules! assert_eqshare_dir {
    ($events:expr, UF => DL $(,)?) => {{
        let events = $events;
        if !$crate::eqshare_macros::has_dir(events, $crate::eqshare_macros::UF, $crate::eqshare_macros::DL) {
            panic!(
                "missing eqshare direction UF=>DL\nfirst events:\n{}",
                $crate::eqshare_macros::dump(events)
            );
        }
    }};
    ($events:expr, DL => UF $(,)?) => {{
        let events = $events;
        if !$crate::eqshare_macros::has_dir(events, $crate::eqshare_macros::DL, $crate::eqshare_macros::UF) {
            panic!(
                "missing eqshare direction DL=>UF\nfirst events:\n{}",
                $crate::eqshare_macros::dump(events)
            );
        }
    }};
}

#[macro_export]
macro_rules! assert_eqshare_hop {
    ($events:expr, UF => DL, $a:expr, $b:expr $(,)?) => {{
        let events = $events;
        let a = $a;
        let b = $b;
        if !$crate::eqshare_macros::has_pair(events, $crate::eqshare_macros::UF, $crate::eqshare_macros::DL, a, b) {
            panic!(
                "missing eqshare hop UF=>DL for pair {:?} = {:?}\nfirst events:\n{}",
                a, b, $crate::eqshare_macros::dump(events)
            );
        }
    }};
    ($events:expr, DL => UF, $a:expr, $b:expr $(,)?) => {{
        let events = $events;
        let a = $a;
        let b = $b;
        if !$crate::eqshare_macros::has_pair(events, $crate::eqshare_macros::DL, $crate::eqshare_macros::UF, a, b) {
            panic!(
                "missing eqshare hop DL=>UF for pair {:?} = {:?}\nfirst events:\n{}",
                a, b, $crate::eqshare_macros::dump(events)
            );
        }
    }};
}
```

> Note: the helpers (`has_pair`, `has_dir`, `dump`) must be `pub(crate)` or `pub` if you split modules; since macros expand in the caller’s module, using `$crate::...` is correct.

Add the module to your test crate root:

### `crates/smt-tests/src/lib.rs` (or `mod.rs`)

```rust
pub mod eqshare_macros;
```

---

## 2) Example usage in the ping-pong test

```rust
use smt_api::CheckSat;
use crate::{assert_eqshare_dir, assert_eqshare_hop};

#[test]
fn ping_pong_trace_has_both_hops() -> smt_core::Result<()> {
    let mut sess = common::make_session(SharingConfig { uf_to_dl: true, dl_to_uf: true });
    let inst = setup_ping_pong_instance(&mut sess)?;

    assert_eq!(sess.check_sat(), CheckSat::Unsat);

    let events = sess.take_eqshare_events();

    // At least one exchange in each direction
    assert_eqshare_dir!(&events, UF => DL);
    assert_eqshare_dir!(&events, DL => UF);

    // Stronger: exact key pairs
    assert_eqshare_hop!(&events, UF => DL, inst.fa, inst.fb);
    assert_eqshare_hop!(&events, DL => UF, inst.x, inst.y);

    Ok(())
}
```

---

## 3) If you ever reorder theories

Change just:

```rust
pub const UF: TheoryId = TheoryId(0);
pub const DL: TheoryId = TheoryId(1);
```

Everything else stays the same.

---

If you want, I can add a third macro `assert_eqshare_hop_any!(events, UF => DL, &[ (a,b), (c,d) ])` that passes if **any** of the candidate pairs appears—useful when the solver exports a different spanning-tree equality than the one you expected.
