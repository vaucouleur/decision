Below is **concrete code** for:

1. `SmtEngine::equality_sharing_round()` using the **SharedTermOracle** + **export_epoch**
2. UF and DL integration of `exported_pairs` with **checkpoint/rollback** for both user scopes and decision levels (so it stays correct under push/pop/backtracking)

I’ll keep it copy-pasteable and consistent with the earlier structures.

---

# 1) Engine: `equality_sharing_round()` with oracle + epoch

Assumptions:

* `self.shared_terms: SharedTermOracle`
* `self.export_epoch: u64`
* `self.uf_id: TheoryId`, `self.dl_id: TheoryId`
* `self.sharing: SharingConfig`
* `Theory::equality_sharing_mut() -> Option<&mut dyn EqualitySharing>`
* `EqualitySharing::export_equalities(oracle, export_epoch, tcx) -> Vec<SharedEq>`
* `EqualitySharing::import_equality(eq, tcx)`

### `crates/smt-engine/src/engine.rs` (method)

```rust
use crate::theory::{EqualitySharing, SharedEq};
use crate::theory_ctx::TheoryCtx;

impl<K: crate::sat_iface::SatKernel> crate::engine::SmtEngine<K> {
    /// Perform a single equality-sharing round (export then import), respecting SharingConfig.
    ///
    /// Call this after a theory fixpoint. Then run another theory fixpoint, since imports can
    /// trigger new propagations or conflicts.
    pub fn equality_sharing_round(&mut self) {
        // Ensure shared terms are up to date (call maybe_recompute_shared_terms() outside if you prefer).
        // self.maybe_recompute_shared_terms();

        let mut tcx = TheoryCtx::new(&mut self.reasons);

        // Collect (src_theory_id, eq)
        let mut exported: Vec<(crate::atoms::TheoryId, SharedEq)> = Vec::new();

        for (i, th) in self.theories.iter_mut().enumerate() {
            let src = crate::atoms::TheoryId(i);
            if let Some(sh) = th.equality_sharing_mut() {
                for eq in sh.export_equalities(&self.shared_terms, self.export_epoch, &mut tcx) {
                    exported.push((src, eq));
                }
            }
        }

        if exported.is_empty() {
            return;
        }

        // Broadcast with direction control.
        for (src, eq) in exported {
            for (j, th) in self.theories.iter_mut().enumerate() {
                let dst = crate::atoms::TheoryId(j);
                if dst == src {
                    continue;
                }

                let allow = match (src, dst) {
                    (s, d) if s == self.uf_id && d == self.dl_id => self.sharing.uf_to_dl,
                    (s, d) if s == self.dl_id && d == self.uf_id => self.sharing.dl_to_uf,
                    _ => true,
                };
                if !allow {
                    continue;
                }

                if let Some(sh) = th.equality_sharing_mut() {
                    sh.import_equality(eq.clone(), &mut tcx);
                }
            }
        }

        // Imports changed theory state => bump epoch so theories can re-export if needed.
        self.export_epoch = self.export_epoch.wrapping_add(1);
    }
}
```

### Update `EqualitySharing` trait signature

### `crates/smt-engine/src/theory.rs`

```rust
use crate::shared_terms::SharedTermOracle;

pub trait EqualitySharing {
    fn export_equalities(
        &mut self,
        oracle: &SharedTermOracle,
        export_epoch: u64,
        tcx: &mut crate::theory_ctx::TheoryCtx,
    ) -> Vec<SharedEq>;

    fn import_equality(&mut self, eq: SharedEq, tcx: &mut crate::theory_ctx::TheoryCtx);
}
```

---

# 2) UF: `exported_pairs` + checkpoints/rollback

In `UfTheory` add:

```rust
exported_pairs: hashbrown::HashSet<(TermId, TermId), FxBuild>,
exported_pairs_undo: Vec<usize>,     // checkpoint stack (sizes)
last_export_epoch: u64,              // throttle per engine epoch
```

### Patch in `UfTheory` struct

```rust
pub struct UfTheory {
    // ...
    exported_pairs: hashbrown::HashSet<(TermId, TermId), FxBuild>,
    exported_pairs_undo: Vec<usize>,
    last_export_epoch: u64,
}
```

### Init in `new()`

```rust
exported_pairs: hashbrown::HashSet::default(),
exported_pairs_undo: vec![0], // base checkpoint
last_export_epoch: 0,
```

### Add checkpoint/rollback hooks

In `checkpoint()`:

```rust
fn checkpoint(&mut self, which: &mut Vec<(usize, usize)>) {
    self.uf.push();
    which.push((self.atom_trail.len(), self.diseqs.len()));
    self.exported_pairs_undo.push(self.exported_pairs.len());
}
```

In `rollback()`:

```rust
fn rollback(&mut self, which: &mut Vec<(usize, usize)>, n: usize) {
    for _ in 0..n {
        if which.len() <= 1 { return; }
        let (tl, dl) = which.pop().unwrap();
        self.uf.pop(1);

        while self.atom_trail.len() > tl {
            let u = self.atom_trail.pop().unwrap();
            if let Some(a) = self.atoms.get_mut(&u.term) {
                a.value = u.prev_value;
                a.propagated_true = u.prev_prop;
            }
        }
        self.diseqs.truncate(dl);

        // rollback exported-pairs to checkpoint size
        if self.exported_pairs_undo.len() > 1 {
            let target = self.exported_pairs_undo.pop().unwrap();
            if self.exported_pairs.len() > target {
                // simplest: clear and rebuild is heavy; instead remove arbitrary extras not tracked.
                // For correctness, store the inserted pairs in a trail. We'll do that below.
                //
                // But if you want easy: clear fully on any rollback:
                self.exported_pairs.clear();
            }
        }
    }
}
```

The comment is important: a HashSet can’t “truncate”. The **correct** rollback is to keep a **trail of inserted keys**.

So do the proper approach:

### Proper export-pair trail

Replace `exported_pairs_undo: Vec<usize>` with:

```rust
exported_pairs_trail: Vec<(TermId, TermId)>,
exported_pairs_cp: Vec<usize>,
```

#### In struct:

```rust
exported_pairs: hashbrown::HashSet<(TermId, TermId), FxBuild>,
exported_pairs_trail: Vec<(TermId, TermId)>,
exported_pairs_cp: Vec<usize>,
last_export_epoch: u64,
```

#### In `new()`:

```rust
exported_pairs: hashbrown::HashSet::default(),
exported_pairs_trail: Vec::new(),
exported_pairs_cp: vec![0],
last_export_epoch: 0,
```

#### In checkpoint:

```rust
self.exported_pairs_cp.push(self.exported_pairs_trail.len());
```

#### In rollback:

```rust
let target = self.exported_pairs_cp.pop().unwrap();
while self.exported_pairs_trail.len() > target {
    let k = self.exported_pairs_trail.pop().unwrap();
    self.exported_pairs.remove(&k);
}
```

That’s correct and efficient.

### Add helper to record insert

```rust
fn mark_exported_pair(&mut self, a: TermId, b: TermId) -> bool {
    let (p, q) = if a < b { (a, b) } else { (b, a) };
    if self.exported_pairs.insert((p, q)) {
        self.exported_pairs_trail.push((p, q));
        true
    } else {
        false
    }
}
```

---

## UF `export_equalities` with oracle + epoch + dedup

### Patch UF `EqualitySharing` impl

```rust
impl EqualitySharing for UfTheory {
    fn export_equalities(
        &mut self,
        oracle: &crate::shared_terms::SharedTermOracle,
        export_epoch: u64,
        tcx: &mut TheoryCtx,
    ) -> Vec<SharedEq> {
        // Throttle within a stable engine epoch.
        if self.last_export_epoch == export_epoch {
            return Vec::new();
        }
        self.last_export_epoch = export_epoch;

        use hashbrown::HashMap;
        use crate::theories::uf_cc_reasoned::NodeId;

        let mut out = Vec::new();

        // Bucket shared UF-app terms by representative.
        let mut buckets: HashMap<NodeId, Vec<TermId>, FxBuild> = HashMap::default();

        for &t in oracle.shared_set().iter() {
            if !self.is_uf_app_term(t) {
                continue;
            }
            let nt = self.uf.ensure_term(t, tcx);
            let rep = self.uf.find(nt);
            buckets.entry(rep).or_default().push(t);
        }

        for (_rep, terms) in buckets {
            if terms.len() < 2 {
                continue;
            }
            let head = terms[0];
            let nhead = self.uf.ensure_term(head, tcx);

            for &other in &terms[1..] {
                if !self.mark_exported_pair(head, other) {
                    continue; // already exported in this branch/level
                }

                let nother = self.uf.ensure_term(other, tcx);
                if let Some(r) = self.uf.explain_eq(nhead, nother, tcx) {
                    out.push(SharedEq { a: head, b: other, explain: r });
                }
            }
        }

        out
    }

    fn import_equality(&mut self, eq: SharedEq, tcx: &mut TheoryCtx) {
        let na = self.uf.ensure_term(eq.a, tcx);
        let nb = self.uf.ensure_term(eq.b, tcx);
        self.uf.union_with_tcx(na, nb, eq.explain, tcx);

        // Imports may enable new exports; allow next epoch to export again.
        // (Engine already bumps export_epoch after imports, but harmless to reset too.)
        self.last_export_epoch = 0;
    }
}
```

---

# 3) DL: `exported_pairs` + checkpoint/rollback + epoch throttle

Do the same pattern in DL.

### Add to `DlTheory` struct

```rust
exported_pairs: hashbrown::HashSet<(TermId, TermId), FxBuild>,
exported_pairs_trail: Vec<(TermId, TermId)>,
exported_pairs_cp: Vec<usize>,
last_export_epoch: u64,
```

Init in `new()`:

```rust
exported_pairs: hashbrown::HashSet::default(),
exported_pairs_trail: Vec::new(),
exported_pairs_cp: vec![0],
last_export_epoch: 0,
```

Checkpoint/rollback:

In `checkpoint()` add:

```rust
self.exported_pairs_cp.push(self.exported_pairs_trail.len());
```

In `rollback()` add (inside each pop):

```rust
let target = self.exported_pairs_cp.pop().unwrap();
while self.exported_pairs_trail.len() > target {
    let k = self.exported_pairs_trail.pop().unwrap();
    self.exported_pairs.remove(&k);
}
```

Helper:

```rust
fn mark_exported_pair(&mut self, a: TermId, b: TermId) -> bool {
    let (p, q) = if a < b { (a, b) } else { (b, a) };
    if self.exported_pairs.insert((p, q)) {
        self.exported_pairs_trail.push((p, q));
        true
    } else {
        false
    }
}
```

### DL export with oracle + epoch + dedup

Patch `impl EqualitySharing for DlTheory`:

```rust
impl EqualitySharing for DlTheory {
    fn export_equalities(
        &mut self,
        oracle: &crate::shared_terms::SharedTermOracle,
        export_epoch: u64,
        tcx: &mut TheoryCtx,
    ) -> Vec<SharedEq> {
        if self.last_export_epoch == export_epoch {
            return Vec::new();
        }
        self.last_export_epoch = export_epoch;

        let (dist, pred, neg) = self.all_pairs_shortest_paths(tcx);
        if neg.is_some() {
            return Vec::new();
        }

        // Only consider DL nodes that are shared by oracle.
        let shared_terms: Vec<TermId> = self.nodes.iter().copied().filter(|t| oracle.is_shared(*t)).collect();

        let mut out = Vec::new();

        for i in 0..shared_terms.len() {
            for j in (i + 1)..shared_terms.len() {
                let a = shared_terms[i];
                let b = shared_terms[j];

                if !self.mark_exported_pair(a, b) {
                    continue;
                }

                let na = self.node(a);
                let nb = self.node(b);

                let ab = dist[na.0 as usize][nb.0 as usize];
                let ba = dist[nb.0 as usize][na.0 as usize];

                if ab.map_or(false, |d| d <= 0) && ba.map_or(false, |d| d <= 0) {
                    let r1 = self.reconstruct_path_reason(&pred, na, nb, tcx);
                    let r2 = self.reconstruct_path_reason(&pred, nb, na, tcx);
                    let explain = tcx.r_and(vec![r1, r2]);
                    out.push(SharedEq { a, b, explain });
                }
            }
        }

        out
    }

    fn import_equality(&mut self, eq: SharedEq, _tcx: &mut TheoryCtx) {
        self.add_edge(eq.b, eq.a, 0, eq.explain);
        self.add_edge(eq.a, eq.b, 0, eq.explain);
        self.last_export_epoch = 0;
    }
}
```

---

# 4) Wire checkpoints into DL existing checkpoint/rollback

In `DlTheory::checkpoint` and `rollback`, ensure the export pair checkpoints happen *in lockstep* with scope/level checkpoints.

Example:

```rust
fn checkpoint(&mut self, stack: &mut Vec<(usize, usize)>) {
    stack.push((self.atom_undo.len(), self.edge_undo.len()));
    self.exported_pairs_cp.push(self.exported_pairs_trail.len());
}
```

and in rollback (after popping `stack`):

```rust
let target = self.exported_pairs_cp.pop().unwrap();
while self.exported_pairs_trail.len() > target {
    let k = self.exported_pairs_trail.pop().unwrap();
    self.exported_pairs.remove(&k);
}
```

Same pattern for UF.

---

# 5) Result

With:

* SharedTermOracle centralized
* UF endpoints include UF app args
* UF exports shared UF-app equalities by rep buckets
* both theories dedup exported pairs with trail-based rollback
* epoch throttle

…your 3 regression tests (UF→DL, DL→UF, ping-pong) become stable and fast, and you don’t get repeated equalities every fixpoint step.

---

If you want, I can also give you a tiny “engine debug mode” hook that logs:

* which equalities are exported/imported per epoch
* which reasons (expanded lits) justify them
  That makes combination bugs *much* easier to chase.
