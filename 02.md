Here’s a solid “workspace + facade crate at repo root” setup (so you *can* have features in the **main** `Cargo.toml`), plus a clean `crates/smt-core/src/lib.rs` that is `no_std`-friendly and sets you up for a term-DAG core.

---

## 1) Repo-root `Cargo.toml` (workspace + main facade crate with features)

```toml
[package]
name = "smt"
version = "0.1.0"
edition = "2021"
rust-version = "1.76"
license = "MIT OR Apache-2.0"
description = "A modular SMT solver toolkit (core term DAG + optional CDCL(T) engine and theories)."
repository = "https://example.com/your/repo"
readme = "README.md"
keywords = ["smt", "solver", "sat", "theorem-proving"]
categories = ["algorithms", "science"]

[workspace]
members = [
  "crates/*",
]
resolver = "2"

# Centralize versions / feature policies for shared dependencies.
[workspace.dependencies]
thiserror = "2"
rustc-hash = "2"
hashbrown = "0.15"
smallvec = "1.13"
indexmap = "2.7"

# Optional (feature-gated) infra:
serde = { version = "1.0", features = ["derive"] }
tracing = "0.1"

[dependencies]
# Always available: core term DAG / sorts / context.
smt-core = { path = "crates/smt-core", default-features = false }

# Optional “stack” crates. The facade enables them via features.
smt-smt2      = { path = "crates/smt-smt2",      optional = true, default-features = false }
smt-preprocess= { path = "crates/smt-preprocess",optional = true, default-features = false }
smt-sat       = { path = "crates/smt-sat",       optional = true, default-features = false }
smt-engine    = { path = "crates/smt-engine",    optional = true, default-features = false }
smt-proof     = { path = "crates/smt-proof",     optional = true, default-features = false }

# Theories (each in its own crate, all optional)
smt-theory-uf   = { path = "crates/smt-theory-uf",   optional = true, default-features = false }
smt-theory-bv   = { path = "crates/smt-theory-bv",   optional = true, default-features = false }
smt-theory-lia  = { path = "crates/smt-theory-lia",  optional = true, default-features = false }
smt-quant       = { path = "crates/smt-quant",       optional = true, default-features = false }

# Optional deps re-exposed / propagated as convenience.
serde   = { workspace = true, optional = true }
tracing = { workspace = true, optional = true }

[features]
# Keep default small and predictable.
default = ["std"]

# ---- Platform / base capabilities ----
# Enable std across the stack.
std = [
  "smt-core/std",
  "dep:tracing",      # only if you want tracing to assume std
]

# If you want core to be usable in no_std + alloc environments,
# you can keep std off and still build with alloc-only crates.
alloc = [
  "smt-core/alloc",
]

# ---- Cross-cutting options ----
serde = [
  "dep:serde",
  "smt-core/serde",
]

tracing = [
  "dep:tracing",
  "smt-core/tracing",
]

proofs = [
  "dep:smt-proof",
  "smt-engine?/proofs",
]

# ---- Enable layers ----
smt2 = ["dep:smt-smt2"]
preprocess = ["dep:smt-preprocess"]

sat = ["dep:smt-sat"]

engine = [
  "dep:smt-engine",
  "sat",
  "preprocess",
]

# ---- Enable theories ----
theory-uf  = ["dep:smt-theory-uf",  "engine"]
theory-bv  = ["dep:smt-theory-bv",  "engine"]
theory-lia = ["dep:smt-theory-lia", "engine"]
quant      = ["dep:smt-quant",      "engine"]

# ---- Presets (nice UX) ----
# Very common “starter” logic.
preset-qf-uf = [
  "smt2",
  "engine",
  "theory-uf",
]

preset-qf-bv = [
  "smt2",
  "engine",
  "theory-uf",   # BV solvers typically need UF/equality engine anyway
  "theory-bv",
]

preset-qf-uf-lia = [
  "smt2",
  "engine",
  "theory-uf",
  "theory-lia",
]

[dev-dependencies]
proptest = "1"
insta = "1"

[lints.rust]
unsafe_code = "forbid"
missing_docs = "warn"

[lints.clippy]
all = "warn"
pedantic = "warn"
# You can relax a few that are noisy for systems code:
module_name_repetitions = "allow"
too_many_lines = "allow"
```

Notes:

* Workspace root contains a **real crate** (`smt`) so it can define features.
* The facade features simply “turn on” optional crates and propagate cross-cutting flags (serde/tracing/proofs).
* `smt-core` is always available and can be `no_std` if you want.

---

## 2) `crates/smt-core/src/lib.rs` (what the main file should look like)

```rust
//! `smt-core` — the stable kernel of the solver.
//!
//! This crate owns the **semantic invariants** shared by all solver components:
//!
//! - Interned, hash-consed term DAG (cheap `Copy` handles: [`TermId`], [`SortId`])
//! - Sort/type definitions
//! - A scoped [`Context`] with `push/pop` (incremental solving friendly)
//! - Common error / result types
//! - Small, reusable utilities (rewriting hooks, stats, etc.)
//!
//! Design goals:
//! - **Fast**: term nodes are interned; terms are IDs; cloning is cheap.
//! - **Composable**: SAT engine, theories, preprocessing, proofs live in other crates.
//! - **Portable**: optional `no_std` support (with `alloc`).
//!
//! Feature flags:
//! - `std` (default in the facade): enables `std` conveniences.
//! - `alloc`: enables `alloc` usage in `no_std` contexts.
//! - `serde`: implements `Serialize/Deserialize` for public IDs and some structures.
//! - `tracing`: emits tracing spans/events for debugging and performance analysis.

#![cfg_attr(not(feature = "std"), no_std)]
#![forbid(unsafe_code)]
#![warn(missing_docs)]

#[cfg(not(feature = "std"))]
extern crate alloc;

/// Common result type for `smt-core`.
pub type Result<T> = core::result::Result<T, Error>;

mod error;
mod ids;
mod sort;
mod term;

mod arena;
mod interner;

mod context;
mod op;
mod pretty;

pub use crate::error::Error;
pub use crate::ids::{SortId, TermId};
pub use crate::sort::{Sort, SortKind};
pub use crate::term::{Term, TermKind};
pub use crate::context::{Context, ContextStats};
pub use crate::op::{Op, OpKind};

/// A convenience prelude for typical users.
///
/// The facade crate (`smt`) may also define its own prelude that re-exports this one.
pub mod prelude {
    pub use crate::{
        Context, Error, Result,
        Op, OpKind,
        Sort, SortId, SortKind,
        Term, TermId, TermKind,
    };
}

#[cfg(feature = "serde")]
mod serde_impls;

#[cfg(feature = "tracing")]
mod trace;

/// Internal modules re-exported for other crates in the workspace.
/// These are not part of the stable public API: prefer `Context` methods and public types.
pub(crate) mod internal {
    pub(crate) use crate::arena::*;
    pub(crate) use crate::interner::*;
}

/// Small helpers for display/debug formatting.
///
/// Keep this separate from `pretty` so it stays lightweight and does not pull optional deps.
pub mod fmt {
    pub use crate::pretty::{PrettyTerm, PrettySort};
}
```

That’s the “main file” structure I’d keep: crisp crate docs, strict linting (including `unsafe_code` forbidden), clear module boundaries, and a single stable surface via `Context`, IDs, and term/sort types.

If you want, next I can also show:

* a minimal `Context` API (`mk_bool_sort`, `mk_var`, `mk_app`, `mk_eq`, `push/pop`, interning),
* and the `TermId/SortId` + `TermKind/SortKind` definitions that keep allocations under control.
