Below is a **complete UF theory wrapper** built on top of the incremental `UfCc` (rollbackable congruence closure), including:

* registration of equality atoms `(= lhs rhs)` with SAT `Var`
* `on_atom_assigned`: assert equality / store disequality
* `propagate`: generate **propagations** (implied equalities) and **conflicts** with explanations
* a tiny anti-spam mechanism so we don’t re-emit the same propagation forever

I’ll assume:

* you have `Theory`, `TheoryPropagation`, `TheoryConflict` as earlier in `smt-engine`
* the engine will turn `explain => implied` into a SAT lemma and enqueue the implied lit (with reason if possible)

---

# `crates/smt-engine/src/theories/uf_theory_inc.rs`

```rust
//! UF Theory (incremental congruence closure with rollback) for CDCL(T).
//!
//! Atoms supported:
//! - Bool terms of the form (= a b) where a,b are UF terms (uninterpreted sort / Uf apps).
//!
//! Assignments from SAT:
//! - atom = true  => assert equality in UF with justification `(+atom_lit)`
//! - atom = false => store a disequality constraint with justification `(-atom_lit)`
//!
//! Propagation:
//! - if UF implies (= a b) must be true and that atom is currently unassigned,
//!   emit TheoryPropagation { implied: +atom_lit, explain: ... }.
//!
//! Conflict:
//! - if a disequality is asserted but UF says a==b, emit TheoryConflict with explanation
//!   consisting of the equality explanation + the disequality literal.

#![forbid(unsafe_code)]
#![warn(missing_docs)]

use std::sync::Arc;

use hashbrown::HashMap;
use rustc_hash::FxHasher;
use core::hash::BuildHasherDefault;

use smt_core::{Context, TermId, TermKind};
use smt_sat::{Lit, Var};

use crate::atoms::TheoryId;
use crate::theory::{Theory, TheoryConflict, TheoryPropagation};

use crate::theories::uf_inc::{UfCc, NodeId};

type FxBuild = BuildHasherDefault<FxHasher>;

#[derive(Debug, Clone)]
struct EqAtom {
    var: Var,
    lhs: TermId,
    rhs: TermId,
    /// Current SAT assignment (as last notified by the engine).
    value: Option<bool>,
    /// Prevent repeated propagations.
    propagated_true: bool,
}

/// Stored disequality: lhs != rhs justified by `lit` (which is the SAT literal ¬(= lhs rhs)).
#[derive(Debug, Clone)]
struct Diseq {
    lhs: TermId,
    rhs: TermId,
    lit: Lit,
    /// Prevent repeated conflict checking work if it already conflicted.
    /// (Optional; safe to omit.)
    active: bool,
}

/// UF theory wrapper used by the engine.
pub struct UfTheoryInc {
    ctx: Arc<Context>,
    id: TheoryId,

    uf: UfCc,

    // term (= lhs rhs) -> atom info
    atoms: HashMap<TermId, EqAtom, FxBuild>,

    // Disequalities asserted (atom=false).
    diseqs: Vec<Diseq>,

    // Rollback checkpoints: counts for atoms flags and diseqs length.
    // UF itself has its own checkpoint stack internally.
    checkpoints: Vec<(usize, usize)>, // (diseqs_len, num_atoms_with_state_snap) - simplified
}

impl UfTheoryInc {
    /// Create UF theory.
    pub fn new(ctx: Arc<Context>, id: TheoryId) -> Self {
        Self {
            uf: UfCc::new(ctx.clone()),
            ctx,
            id,
            atoms: HashMap::default(),
            diseqs: Vec::new(),
            checkpoints: vec![(0, 0)],
        }
    }

    /// Register an equality atom `(= lhs rhs)` owned by UF with its SAT variable.
    pub fn register_eq_atom(&mut self, atom_term: TermId, var: Var) -> smt_core::Result<()> {
        let (lhs, rhs) = parse_eq_atom(&self.ctx, atom_term)?;

        // Ensure UF tracks endpoints (and any needed subterms).
        self.uf.ensure_term(lhs);
        self.uf.ensure_term(rhs);

        self.atoms.insert(atom_term, EqAtom {
            var,
            lhs,
            rhs,
            value: None,
            propagated_true: false,
        });

        Ok(())
    }

    /// Get equality explanation as SAT literals, if uf says equal; otherwise empty vec.
    fn explain_eq_lits(&mut self, lhs: TermId, rhs: TermId) -> Vec<Lit> {
        // Need NodeIds (ensure_term ensures interning).
        let a = self.uf.ensure_term(lhs);
        let b = self.uf.ensure_term(rhs);

        let Some(rid) = self.uf.explain_eq(a, b) else {
            return Vec::new();
        };
        self.uf.expand_reason_lits(rid)
    }

    /// Check whether UF currently entails lhs == rhs.
    fn uf_entails_eq(&mut self, lhs: TermId, rhs: TermId) -> bool {
        let a = self.uf.ensure_term(lhs);
        let b = self.uf.ensure_term(rhs);
        self.uf.find(a) == self.uf.find(b)
    }

    /// Produce propagations for any equality atoms now entailed by UF.
    fn collect_propagations(&mut self) -> Vec<TheoryPropagation> {
        let mut out = Vec::new();

        for (_term, atom) in self.atoms.iter_mut() {
            if atom.value.is_some() || atom.propagated_true {
                continue;
            }

            if self.uf_entails_eq(atom.lhs, atom.rhs) {
                let explain = self.explain_eq_lits(atom.lhs, atom.rhs);
                // If explanation is empty, it means UF thinks they are equal without reasons.
                // In SMT that usually means they are syntactically identical or merged via earlier reasons.
                out.push(TheoryPropagation {
                    implied: Lit::pos(atom.var),
                    explain,
                });
                atom.propagated_true = true;
            }
        }

        out
    }

    /// Check disequalities for conflicts; return first conflict found.
    fn check_diseq_conflict(&mut self) -> Option<TheoryConflict> {
        for d in self.diseqs.iter() {
            if !d.active {
                continue;
            }

            if self.uf_entails_eq(d.lhs, d.rhs) {
                let mut explain = self.explain_eq_lits(d.lhs, d.rhs);
                explain.push(d.lit); // the asserted disequality literal (¬eq)
                return Some(TheoryConflict { explain });
            }
        }
        None
    }
}

impl Theory for UfTheoryInc {
    fn name(&self) -> &'static str { "UF" }

    fn push(&mut self) {
        // rollback UF internals
        self.uf.push();

        // rollback our own state
        self.checkpoints.push((self.diseqs.len(), 0));

        // In a full incremental SMT, you may want to snapshot atom flags/values too.
        // For a starter, we assume engine rebuilds per solve() or does disciplined use.
    }

    fn pop(&mut self, n: usize) {
        for _ in 0..n {
            if self.checkpoints.len() <= 1 {
                return;
            }
            self.checkpoints.pop();
            self.uf.pop(1);

            // Restore diseqs list length
            let (dlen, _) = *self.checkpoints.last().unwrap();
            self.diseqs.truncate(dlen);

            // Conservative: clear derived flags/values (safe, can cause re-propagation, but correct).
            for (_t, a) in self.atoms.iter_mut() {
                a.value = None;
                a.propagated_true = false;
            }
        }
    }

    fn on_atom_assigned(&mut self, atom_term: TermId, value: bool) {
        let Some(atom) = self.atoms.get_mut(&atom_term) else { return };

        // Ignore if same value already known.
        if atom.value == Some(value) {
            return;
        }
        atom.value = Some(value);

        if value {
            // Assert equality in UF with justification: (+atom_lit)
            let lit = Lit::pos(atom.var);
            self.uf.assert_eq_atom(atom.lhs, atom.rhs, lit);
        } else {
            // Store disequality (lhs != rhs) justified by ¬atom
            let lit = Lit::neg(atom.var);
            self.diseqs.push(Diseq {
                lhs: atom.lhs,
                rhs: atom.rhs,
                lit,
                active: true,
            });
        }
    }

    fn propagate(&mut self) -> Result<Vec<TheoryPropagation>, TheoryConflict> {
        // 1) Check for immediate conflicts due to disequalities.
        if let Some(conf) = self.check_diseq_conflict() {
            return Err(conf);
        }

        // 2) Emit implied equalities.
        let props = self.collect_propagations();

        // 3) Conflicts may arise after we emit props and the SAT engine enqueues them,
        // but we can also re-check now (cheap):
        if let Some(conf) = self.check_diseq_conflict() {
            return Err(conf);
        }

        Ok(props)
    }
}

/// Parse a Bool equality term `(= lhs rhs)` into endpoints.
fn parse_eq_atom(ctx: &Context, t: TermId) -> smt_core::Result<(TermId, TermId)> {
    let (k, s) = ctx.term_node(t);
    if s != ctx.bool_sort() {
        return Err(smt_core::Error::SortError("expected Bool equality atom".into()));
    }
    let TermKind::App { op, args } = k else {
        return Err(smt_core::Error::SortError("expected application for equality atom".into()));
    };
    if !matches!(op.kind, smt_core::OpKind::Eq) || args.len() != 2 {
        return Err(smt_core::Error::SortError("expected (= a b)".into()));
    }
    Ok((args[0], args[1]))
}
```

### Notes

* This wrapper is intentionally conservative with rollback of `atoms` flags. In a real incremental SMT, you’d snapshot per atom assignment and restore precisely (easy to add later).
* `UfCc::find` is used in this wrapper; in my earlier `UfCc` skeleton it was private. Make it `pub(crate)` or add `are_equal(a,b)`.

---

# Anti-spam propagation: what it does

`propagated_true` prevents emitting the same implied equality repeatedly across theory fixpoint loops when SAT hasn’t yet assigned it.

A more robust variant uses “value became assigned by SAT” and clears `propagated_true` accordingly, but for a starter this is already good.

---

# How to use it in your demo

In the demo, instead of `UfTheory`:

```rust
use smt_engine::theories::uf_theory_inc::UfTheoryInc;

let uf_inner = UfTheoryInc::new(ctx.clone(), uf_id);
let mut uf = LoggingTheory::new(uf_inner);
```

and in registration:

```rust
uf.inner.register_eq_atom(term, var)?;
```

If you want to keep `LoggingTheory` generic (without accessing `.inner`), just register atoms before wrapping (or implement a small trait for “register atoms”).

---

# One important next fix (for real CDCL(T) performance)

Right now, your engine creates a new activation literal for *every* theory lemma. That’s correct but can be heavy. A common improvement:

* Keep theory lemmas **permanent** within a `solve()` call (no activation),
* only use activation literals for **push/pop scoped assertions** and for lemmas that depend on scoped assumptions.

But correctness-wise, what you have is fine.

---

If you say **yes**, I’ll show the precise incremental rollback of atom assignments (so `push/pop` works perfectly without “clearing all atom states”), and how to integrate that with SAT trail notifications (track which atoms were assigned at each scope).
