Below is a **straight code-level “diff guide”** for the three things you asked:

1. updated `Theory` trait signatures (now using `TheoryCtx` + `ReasonId`)
2. engine call sites (notify + propagate loops)
3. minimal UF theory wrapper updated to use the engine’s `ReasonArena` (no UF-local reason DAG)

I’ll write it as complete files/blocks you can paste, with comments where you’ll likely need to adapt names.

---

## 1) `Theory` trait + `TheoryCtx` + `ReasonArena`

### `crates/smt-engine/src/reason.rs`

```rust
#![forbid(unsafe_code)]

use hashbrown::HashSet;
use rustc_hash::FxHasher;
use core::hash::BuildHasherDefault;

use smt_sat::Lit;

type FxBuild = BuildHasherDefault<FxHasher>;

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ReasonId(pub u32);

#[derive(Debug, Clone)]
pub enum Reason {
    Atom(Lit),
    And(Vec<ReasonId>),
}

#[derive(Default)]
pub struct ReasonArena {
    reasons: Vec<Reason>,
}

impl ReasonArena {
    pub fn new() -> Self {
        Self { reasons: Vec::new() }
    }

    pub fn atom(&mut self, lit: Lit) -> ReasonId {
        let id = ReasonId(self.reasons.len() as u32);
        self.reasons.push(Reason::Atom(lit));
        id
    }

    pub fn and(&mut self, kids: Vec<ReasonId>) -> ReasonId {
        let id = ReasonId(self.reasons.len() as u32);
        self.reasons.push(Reason::And(kids));
        id
    }

    pub fn expand_lits(&self, rid: ReasonId) -> Vec<Lit> {
        let mut out = Vec::new();
        let mut seen: HashSet<Lit, FxBuild> = HashSet::default();
        self.expand_rec(rid, &mut seen, &mut out);
        out
    }

    fn expand_rec(&self, rid: ReasonId, seen: &mut HashSet<Lit, FxBuild>, out: &mut Vec<Lit>) {
        match &self.reasons[rid.0 as usize] {
            Reason::Atom(l) => {
                if seen.insert(*l) {
                    out.push(*l);
                }
            }
            Reason::And(kids) => {
                for &k in kids {
                    self.expand_rec(k, seen, out);
                }
            }
        }
    }
}
```

### `crates/smt-engine/src/theory_ctx.rs`

```rust
#![forbid(unsafe_code)]

use smt_sat::Lit;

use crate::reason::{ReasonArena, ReasonId};

/// Context passed to theories so they can allocate and combine explanations.
pub struct TheoryCtx<'a> {
    arena: &'a mut ReasonArena,
}

impl<'a> TheoryCtx<'a> {
    pub fn new(arena: &'a mut ReasonArena) -> Self {
        Self { arena }
    }

    pub fn r_atom(&mut self, lit: Lit) -> ReasonId {
        self.arena.atom(lit)
    }

    pub fn r_and(&mut self, kids: Vec<ReasonId>) -> ReasonId {
        self.arena.and(kids)
    }
}
```

### `crates/smt-engine/src/theory.rs`

```rust
#![forbid(unsafe_code)]

use smt_core::TermId;
use smt_sat::Lit;

use crate::reason::ReasonId;
use crate::theory_ctx::TheoryCtx;

#[derive(Debug, Clone)]
pub struct TheoryPropagation {
    pub implied: Lit,
    pub explain: ReasonId,
}

#[derive(Debug, Clone)]
pub struct TheoryConflict {
    pub explain: ReasonId,
}

#[derive(Debug, Clone)]
pub struct SharedEq {
    pub a: TermId,
    pub b: TermId,
    pub explain: ReasonId,
}

pub trait EqualitySharing {
    fn export_equalities(
        &mut self,
        shared: &hashbrown::HashSet<TermId, core::hash::BuildHasherDefault<rustc_hash::FxHasher>>,
        tcx: &mut TheoryCtx,
    ) -> Vec<SharedEq>;

    fn import_equality(&mut self, eq: SharedEq, tcx: &mut TheoryCtx);
}

pub trait Theory {
    fn name(&self) -> &'static str;

    // User scopes
    fn push_scope(&mut self);
    fn pop_scope(&mut self, n: usize);

    // Search levels
    fn push_level(&mut self);
    fn pop_levels(&mut self, n: usize);

    // Assignments / propagation
    fn on_atom_assigned(&mut self, atom_term: TermId, value: bool, tcx: &mut TheoryCtx);

    fn propagate(&mut self, tcx: &mut TheoryCtx) -> Result<Vec<TheoryPropagation>, TheoryConflict>;

    // Capability hooks
    fn equality_sharing_mut(&mut self) -> Option<&mut dyn EqualitySharing> { None }

    fn atom_endpoints(&self, _atom_term: TermId) -> Vec<TermId> { Vec::new() }
}
```

---

## 2) Engine call sites: notify + propagate + lemma emission

Assuming your main engine is something like `SmtEngine<K>`, add a `ReasonArena` field:

```rust
reasons: crate::reason::ReasonArena,
```

### Engine: notify theories with `TheoryCtx`

Where you previously had:

```rust
theory.on_atom_assigned(atom.term, value);
```

Change to:

```rust
let mut tcx = crate::theory_ctx::TheoryCtx::new(&mut self.reasons);
theory.on_atom_assigned(atom.term, value, &mut tcx);
```

In practice, you don’t want to create `TheoryCtx` per atom. Create one per notify pass:

```rust
fn notify_theories_new_trail(&mut self) {
    let trail = self.sat.trail();
    let mut head = self.sat.trail_head();

    let mut tcx = crate::theory_ctx::TheoryCtx::new(&mut self.reasons);

    while head < trail.len() {
        let lit = trail[head];
        head += 1;

        if let Some(atom) = self.atoms.get(lit.var()) {
            let value = match self.sat.value_lit(lit) {
                smt_sat::kernel::LBool::True => true,
                smt_sat::kernel::LBool::False => false,
                smt_sat::kernel::LBool::Undef => continue,
            };
            self.theories[atom.theory.0].on_atom_assigned(atom.term, value, &mut tcx);
        }
    }

    self.sat.set_trail_head(head);
}
```

### Engine: propagate loop expands reasons into clause literals

Where you had:

```rust
let lemma = implication_clause(&p.explain, p.implied);
```

Now:

```rust
let explain_lits = self.reasons.expand_lits(p.explain);
let lemma = crate::engine_ctx::implication_clause(&explain_lits, p.implied);
```

Same for conflict:

```rust
let explain_lits = self.reasons.expand_lits(conf.explain);
let lemma = crate::engine_ctx::conflict_clause(&explain_lits);
```

### Engine: theory fixpoint passes `TheoryCtx`

```rust
fn theory_fixpoint(&mut self) -> Result<(), ()> {
    loop {
        let mut any = false;

        let mut tcx = crate::theory_ctx::TheoryCtx::new(&mut self.reasons);

        for th in self.theories.iter_mut() {
            match th.propagate(&mut tcx) {
                Ok(props) => {
                    for p in props {
                        any = true;
                        let explain_lits = self.reasons.expand_lits(p.explain);
                        let lemma = crate::engine_ctx::implication_clause(&explain_lits, p.implied);
                        let cidx = self.sat.add_clause_return_index(lemma);
                        let _ = self.sat.enqueue(p.implied, Some(cidx));
                    }
                }
                Err(conf) => {
                    any = true;
                    let explain_lits = self.reasons.expand_lits(conf.explain);
                    let lemma = crate::engine_ctx::conflict_clause(&explain_lits);
                    let _ = self.sat.add_clause_return_index(lemma);
                    return Err(());
                }
            }
        }

        if !any {
            return Ok(());
        }

        if self.sat.propagate().is_err() {
            return Err(());
        }
        self.sync_levels_with_sat();
        self.notify_theories_new_trail();
    }
}
```

### Engine: equality-sharing fixpoint now uses `TheoryCtx`

```rust
fn equality_sharing_fixpoint(&mut self) {
    let shared = crate::engine_shared::compute_shared_terms(&self.atoms, &mut self.theories);

    let mut tcx = crate::theory_ctx::TheoryCtx::new(&mut self.reasons);

    let mut exported = Vec::new();
    for th in self.theories.iter_mut() {
        if let Some(sh) = th.equality_sharing_mut() {
            exported.extend(sh.export_equalities(&shared, &mut tcx));
        }
    }

    if exported.is_empty() {
        return;
    }

    for eq in exported {
        for th in self.theories.iter_mut() {
            if let Some(sh) = th.equality_sharing_mut() {
                sh.import_equality(eq.clone(), &mut tcx);
            }
        }
    }
}
```

---

## 3) Minimal UF theory updated to engine reasons

The simplest approach is:

* UF congruence closure still uses union-find + signature table (as you have)
* it stores `ReasonId` on UF links (instead of its own local `Reason` DAG)
* `explain_eq` returns `ReasonId` built using `tcx.r_and(path_reason_ids)`

### `crates/smt-engine/src/theories/uf_cc_reasoned.rs`

This is a compact UF-CC core focused on *reason handles*. (It omits some optimizations but shows the correct shape.)

```rust
#![forbid(unsafe_code)]

use std::sync::Arc;

use hashbrown::HashMap;
use rustc_hash::FxHasher;
use core::hash::BuildHasherDefault;

use smt_core::{Context, TermId, TermKind};
use smt_sat::Lit;

use crate::reason::ReasonId;
use crate::theory_ctx::TheoryCtx;

type FxBuild = BuildHasherDefault<FxHasher>;

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NodeId(pub u32);

#[derive(Debug, Clone)]
struct AppNode {
    f: smt_core::SymbolId,
    args: Vec<NodeId>,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct Sig {
    f: smt_core::SymbolId,
    reps: Vec<NodeId>,
}

#[derive(Debug, Clone)]
enum Undo {
    Link { node: NodeId, old_parent: NodeId, old_rank_parent: u8, old_edge_reason: Option<ReasonId> },
    ParentsMoved { from: NodeId, to: NodeId, moved: usize },
    SigTable { key: Sig, prev: Option<NodeId> },
    AppSig { app: NodeId, prev: Sig },
}

#[derive(Debug, Clone, Copy)]
struct Cp { trail_len: usize }

pub struct UfCc {
    ctx: Arc<Context>,

    term_to_node: HashMap<TermId, NodeId, FxBuild>,
    node_to_term: Vec<TermId>,

    apps: HashMap<NodeId, AppNode, FxBuild>,

    parent: Vec<NodeId>,
    rank: Vec<u8>,
    edge_reason: Vec<Option<ReasonId>>,

    class_parents: Vec<Vec<NodeId>>,

    app_sig: HashMap<NodeId, Sig, FxBuild>,
    sig_table: HashMap<Sig, NodeId, FxBuild>,

    trail: Vec<Undo>,
    cps: Vec<Cp>,
}

impl UfCc {
    pub fn new(ctx: Arc<Context>) -> Self {
        Self {
            ctx,
            term_to_node: HashMap::default(),
            node_to_term: Vec::new(),
            apps: HashMap::default(),
            parent: Vec::new(),
            rank: Vec::new(),
            edge_reason: Vec::new(),
            class_parents: Vec::new(),
            app_sig: HashMap::default(),
            sig_table: HashMap::default(),
            trail: Vec::new(),
            cps: vec![Cp { trail_len: 0 }],
        }
    }

    pub fn push(&mut self) {
        self.cps.push(Cp { trail_len: self.trail.len() });
    }

    pub fn pop(&mut self, n: usize) {
        for _ in 0..n {
            if self.cps.len() <= 1 { return; }
            let cp = self.cps.pop().unwrap();
            while self.trail.len() > cp.trail_len {
                self.undo_one();
            }
        }
    }

    fn undo_one(&mut self) {
        match self.trail.pop().unwrap() {
            Undo::Link { node, old_parent, old_rank_parent, old_edge_reason } => {
                let i = node.0 as usize;
                let new_parent = self.parent[i];
                self.parent[i] = old_parent;
                self.edge_reason[i] = old_edge_reason;
                self.rank[new_parent.0 as usize] = old_rank_parent;
            }
            Undo::ParentsMoved { from, to, moved } => {
                let to_list = &mut self.class_parents[to.0 as usize];
                let from_list = &mut self.class_parents[from.0 as usize];
                for _ in 0..moved {
                    if let Some(x) = to_list.pop() {
                        from_list.push(x);
                    }
                }
            }
            Undo::SigTable { key, prev } => {
                match prev {
                    Some(v) => { self.sig_table.insert(key, v); }
                    None => { self.sig_table.remove(&key); }
                }
            }
            Undo::AppSig { app, prev } => {
                self.app_sig.insert(app, prev);
            }
        }
    }

    pub fn ensure_term(&mut self, t: TermId, tcx: &mut TheoryCtx) -> NodeId {
        if let Some(&n) = self.term_to_node.get(&t) {
            return n;
        }

        let nid = NodeId(self.node_to_term.len() as u32);
        self.term_to_node.insert(t, nid);
        self.node_to_term.push(t);

        self.parent.push(nid);
        self.rank.push(0);
        self.edge_reason.push(None);
        self.class_parents.push(Vec::new());

        // UF app registration
        let (k, _) = self.ctx.term_node(t);
        if let TermKind::App { op, args } = k {
            if let smt_core::OpKind::Uf(f) = op.kind {
                let arg_nodes: Vec<NodeId> = args.iter().map(|&a| self.ensure_term(a, tcx)).collect();
                self.apps.insert(nid, AppNode { f, args: arg_nodes });

                for &a in self.apps[&nid].args.iter() {
                    let ra = self.find(a);
                    self.class_parents[ra.0 as usize].push(nid);
                }

                self.recompute_sig_and_register(nid, tcx);
            }
        }

        nid
    }

    pub fn find(&self, mut x: NodeId) -> NodeId {
        while self.parent[x.0 as usize] != x {
            x = self.parent[x.0 as usize];
        }
        x
    }

    fn path_reasons(&self, mut x: NodeId) -> Vec<ReasonId> {
        let mut out = Vec::new();
        while self.parent[x.0 as usize] != x {
            if let Some(r) = self.edge_reason[x.0 as usize] {
                out.push(r);
            }
            x = self.parent[x.0 as usize];
        }
        out
    }

    pub fn explain_eq(&mut self, a: NodeId, b: NodeId, tcx: &mut TheoryCtx) -> Option<ReasonId> {
        if self.find(a) != self.find(b) {
            return None;
        }
        let mut ra = self.path_reasons(a);
        let mut rb = self.path_reasons(b);
        ra.append(&mut rb);
        Some(tcx.r_and(ra))
    }

    pub fn union(&mut self, a: NodeId, b: NodeId, reason: ReasonId) {
        let mut ra = self.find(a);
        let mut rb = self.find(b);
        if ra == rb { return; }

        let (rka, rkb) = (self.rank[ra.0 as usize], self.rank[rb.0 as usize]);
        if rka > rkb {
            core::mem::swap(&mut ra, &mut rb);
        }

        let rb_idx = rb.0 as usize;

        self.trail.push(Undo::Link {
            node: ra,
            old_parent: self.parent[ra.0 as usize],
            old_rank_parent: self.rank[rb_idx],
            old_edge_reason: self.edge_reason[ra.0 as usize],
        });

        self.parent[ra.0 as usize] = rb;
        self.edge_reason[ra.0 as usize] = Some(reason);

        if rka == rkb {
            self.rank[rb_idx] = self.rank[rb_idx].saturating_add(1);
        }

        // merge parents lists
        let moved = self.class_parents[ra.0 as usize].len();
        if moved > 0 {
            self.trail.push(Undo::ParentsMoved { from: ra, to: rb, moved });
            let mut tmp = Vec::new();
            core::mem::swap(&mut tmp, &mut self.class_parents[ra.0 as usize]);
            self.class_parents[rb.0 as usize].extend(tmp);
        }

        self.reconsider_class_parents(rb, tcx_dummy());
    }

    // NOTE: union() above needs tcx for congruence merges in reconsider.
    // To keep this file self-contained, we’ll make union_with_tcx below and call that from theory wrapper.
    fn reconsider_class_parents(&mut self, rep: NodeId, tcx: &mut TheoryCtx) {
        let apps = self.class_parents[rep.0 as usize].clone();
        for app in apps {
            self.recompute_sig_and_register(app, tcx);
        }
    }

    fn recompute_sig_and_register(&mut self, app: NodeId, tcx: &mut TheoryCtx) {
        let Some(appnode) = self.apps.get(&app) else { return };
        let reps: Vec<NodeId> = appnode.args.iter().map(|&a| self.find(a)).collect();
        let new_sig = Sig { f: appnode.f, reps };

        if let Some(old) = self.app_sig.get(&app).cloned() {
            if old == new_sig {
                return;
            }
            self.trail.push(Undo::AppSig { app, prev: old });
        }
        self.app_sig.insert(app, new_sig.clone());

        let prev = self.sig_table.get(&new_sig).copied();
        self.trail.push(Undo::SigTable { key: new_sig.clone(), prev });

        match prev {
            None => { self.sig_table.insert(new_sig, app); }
            Some(other) => {
                self.sig_table.insert(new_sig, other);

                // Congruence reason: AND(explain(arg_i(app)=arg_i(other)))
                let mut kids = Vec::new();
                let a_args = &self.apps[&app].args;
                let b_args = &self.apps[&other].args;

                for (&aa, &bb) in a_args.iter().zip(b_args.iter()) {
                    if let Some(r) = self.explain_eq(aa, bb, tcx) {
                        kids.push(r);
                    }
                }
                let r = tcx.r_and(kids);
                self.union_with_tcx(app, other, r, tcx);
            }
        }
    }

    pub fn union_with_tcx(&mut self, a: NodeId, b: NodeId, reason: ReasonId, tcx: &mut TheoryCtx) {
        let mut ra = self.find(a);
        let mut rb = self.find(b);
        if ra == rb { return; }

        let (rka, rkb) = (self.rank[ra.0 as usize], self.rank[rb.0 as usize]);
        if rka > rkb {
            core::mem::swap(&mut ra, &mut rb);
        }

        let rb_idx = rb.0 as usize;

        self.trail.push(Undo::Link {
            node: ra,
            old_parent: self.parent[ra.0 as usize],
            old_rank_parent: self.rank[rb_idx],
            old_edge_reason: self.edge_reason[ra.0 as usize],
        });

        self.parent[ra.0 as usize] = rb;
        self.edge_reason[ra.0 as usize] = Some(reason);

        if rka == rkb {
            self.rank[rb_idx] = self.rank[rb_idx].saturating_add(1);
        }

        let moved = self.class_parents[ra.0 as usize].len();
        if moved > 0 {
            self.trail.push(Undo::ParentsMoved { from: ra, to: rb, moved });
            let mut tmp = Vec::new();
            core::mem::swap(&mut tmp, &mut self.class_parents[ra.0 as usize]);
            self.class_parents[rb.0 as usize].extend(tmp);
        }

        self.reconsider_class_parents(rb, tcx);
    }

    pub fn assert_eq_atom(&mut self, a: TermId, b: TermId, atom_lit: Lit, tcx: &mut TheoryCtx) {
        let na = self.ensure_term(a, tcx);
        let nb = self.ensure_term(b, tcx);
        let r = tcx.r_atom(atom_lit);
        self.union_with_tcx(na, nb, r, tcx);
    }
}

// Dummy helper to avoid compile error in the earlier union(); delete if you remove union().
fn tcx_dummy<'a>() -> &'a mut TheoryCtx<'a> {
    panic!("use union_with_tcx instead of union()");
}
```

**What to actually do**: remove the old `union()` method and only keep `union_with_tcx()`.

---

## 4) UF theory wrapper uses `ReasonId` end-to-end

### `crates/smt-engine/src/theories/uf_theory_reasoned.rs`

```rust
#![forbid(unsafe_code)]

use std::sync::Arc;

use hashbrown::HashMap;
use rustc_hash::FxHasher;
use core::hash::BuildHasherDefault;

use smt_core::{Context, TermId, TermKind};
use smt_sat::{Lit, Var};

use crate::atoms::TheoryId;
use crate::theory::{Theory, TheoryConflict, TheoryPropagation, EqualitySharing, SharedEq};
use crate::theory_ctx::TheoryCtx;
use crate::reason::ReasonId;

use crate::theories::uf_cc_reasoned::UfCc;

type FxBuild = BuildHasherDefault<FxHasher>;

#[derive(Debug, Clone)]
struct EqAtom {
    var: Var,
    lhs: TermId,
    rhs: TermId,
    value: Option<bool>,
    propagated_true: bool,
}

#[derive(Debug, Clone)]
struct Diseq {
    lhs: TermId,
    rhs: TermId,
    lit: Lit,      // ¬(= lhs rhs)
}

#[derive(Debug, Clone)]
struct AtomUndo {
    term: TermId,
    prev_value: Option<bool>,
    prev_prop: bool,
}

pub struct UfTheory {
    ctx: Arc<Context>,
    id: TheoryId,
    uf: UfCc,

    atoms: HashMap<TermId, EqAtom, FxBuild>,
    diseqs: Vec<Diseq>,

    atom_trail: Vec<AtomUndo>,
    scope_cp: Vec<(usize, usize)>, // (atom_trail_len, diseqs_len)
    level_cp: Vec<(usize, usize)>, // (atom_trail_len, diseqs_len)
}

impl UfTheory {
    pub fn new(ctx: Arc<Context>, id: TheoryId) -> Self {
        Self {
            uf: UfCc::new(ctx.clone()),
            ctx,
            id,
            atoms: HashMap::default(),
            diseqs: Vec::new(),
            atom_trail: Vec::new(),
            scope_cp: vec![(0, 0)],
            level_cp: vec![(0, 0)],
        }
    }

    pub fn register_eq_atom(&mut self, atom_term: TermId, var: Var, tcx: &mut TheoryCtx) -> smt_core::Result<()> {
        let (lhs, rhs) = parse_eq_atom(&self.ctx, atom_term)?;
        self.uf.ensure_term(lhs, tcx);
        self.uf.ensure_term(rhs, tcx);

        self.atoms.insert(atom_term, EqAtom {
            var, lhs, rhs, value: None, propagated_true: false
        });
        Ok(())
    }

    fn entails_eq(&mut self, a: TermId, b: TermId, tcx: &mut TheoryCtx) -> Option<ReasonId> {
        let na = self.uf.ensure_term(a, tcx);
        let nb = self.uf.ensure_term(b, tcx);
        self.uf.explain_eq(na, nb, tcx)
    }

    fn check_diseq_conflict(&mut self, tcx: &mut TheoryCtx) -> Option<TheoryConflict> {
        for d in &self.diseqs {
            if let Some(eq_r) = self.entails_eq(d.lhs, d.rhs, tcx) {
                // conflict reason: AND(eq_r, Atom(¬eq_atom))
                let r_d = tcx.r_atom(d.lit);
                let r = tcx.r_and(vec![eq_r, r_d]);
                return Some(TheoryConflict { explain: r });
            }
        }
        None
    }

    fn collect_props(&mut self, tcx: &mut TheoryCtx) -> Vec<TheoryPropagation> {
        let mut out = Vec::new();
        for (_t, a) in self.atoms.iter_mut() {
            if a.value.is_some() || a.propagated_true {
                continue;
            }
            if let Some(r) = self.entails_eq(a.lhs, a.rhs, tcx) {
                out.push(TheoryPropagation { implied: Lit::pos(a.var), explain: r });
                a.propagated_true = true;
            }
        }
        out
    }

    fn checkpoint(&mut self, which: &mut Vec<(usize, usize)>) {
        self.uf.push();
        which.push((self.atom_trail.len(), self.diseqs.len()));
    }

    fn rollback(&mut self, which: &mut Vec<(usize, usize)>, n: usize) {
        for _ in 0..n {
            if which.len() <= 1 { return; }
            let (tl, dl) = which.pop().unwrap();
            self.uf.pop(1);
            while self.atom_trail.len() > tl {
                let u = self.atom_trail.pop().unwrap();
                if let Some(a) = self.atoms.get_mut(&u.term) {
                    a.value = u.prev_value;
                    a.propagated_true = u.prev_prop;
                }
            }
            self.diseqs.truncate(dl);
        }
    }
}

impl Theory for UfTheory {
    fn name(&self) -> &'static str { "UF" }

    fn push_scope(&mut self) { self.checkpoint(&mut self.scope_cp); }
    fn pop_scope(&mut self, n: usize) { self.rollback(&mut self.scope_cp, n); }

    fn push_level(&mut self) { self.checkpoint(&mut self.level_cp); }
    fn pop_levels(&mut self, n: usize) { self.rollback(&mut self.level_cp, n); }

    fn on_atom_assigned(&mut self, atom_term: TermId, value: bool, tcx: &mut TheoryCtx) {
        let Some(a) = self.atoms.get_mut(&atom_term) else { return; };
        if a.value == Some(value) { return; }

        self.atom_trail.push(AtomUndo {
            term: atom_term,
            prev_value: a.value,
            prev_prop: a.propagated_true,
        });

        a.value = Some(value);
        a.propagated_true = false;

        if value {
            self.uf.assert_eq_atom(a.lhs, a.rhs, Lit::pos(a.var), tcx);
        } else {
            self.diseqs.push(Diseq { lhs: a.lhs, rhs: a.rhs, lit: Lit::neg(a.var) });
        }
    }

    fn propagate(&mut self, tcx: &mut TheoryCtx) -> Result<Vec<TheoryPropagation>, TheoryConflict> {
        if let Some(c) = self.check_diseq_conflict(tcx) {
            return Err(c);
        }
        Ok(self.collect_props(tcx))
    }

    fn equality_sharing_mut(&mut self) -> Option<&mut dyn EqualitySharing> { Some(self) }

    fn atom_endpoints(&self, atom_term: TermId) -> Vec<TermId> {
        self.atoms.get(&atom_term).map(|a| vec![a.lhs, a.rhs]).unwrap_or_default()
    }
}

impl EqualitySharing for UfTheory {
    fn export_equalities(
        &mut self,
        shared: &hashbrown::HashSet<TermId, core::hash::BuildHasherDefault<rustc_hash::FxHasher>>,
        tcx: &mut TheoryCtx,
    ) -> Vec<SharedEq> {
        let mut out = Vec::new();
        for (_t, a) in self.atoms.iter_mut() {
            if !shared.contains(&a.lhs) || !shared.contains(&a.rhs) {
                continue;
            }
            if let Some(r) = self.entails_eq(a.lhs, a.rhs, tcx) {
                out.push(SharedEq { a: a.lhs, b: a.rhs, explain: r });
            }
        }
        out
    }

    fn import_equality(&mut self, eq: SharedEq, tcx: &mut TheoryCtx) {
        // Import as union with the provided reason handle.
        let na = self.uf.ensure_term(eq.a, tcx);
        let nb = self.uf.ensure_term(eq.b, tcx);
        self.uf.union_with_tcx(na, nb, eq.explain, tcx);
    }
}

/// Parse `(= lhs rhs)` bool atom.
fn parse_eq_atom(ctx: &Context, t: TermId) -> smt_core::Result<(TermId, TermId)> {
    let (k, s) = ctx.term_node(t);
    if s != ctx.bool_sort() {
        return Err(smt_core::Error::SortError("expected Bool".into()));
    }
    let TermKind::App { op, args } = k else {
        return Err(smt_core::Error::SortError("expected app".into()));
    };
    if !matches!(op.kind, smt_core::OpKind::Eq) || args.len() != 2 {
        return Err(smt_core::Error::SortError("expected (= a b)".into()));
    }
    Ok((args[0], args[1]))
}
```

---

## What to do next (tiny but important)

* Update DL to store `ReasonId` on edges instead of `Lit`
* When reconstructing paths/cycles, collect `ReasonId`s and return `tcx.r_and(reasons)`
* Engine expands `ReasonId` only when emitting SAT clauses

That’s when UF+DL equality exchange becomes fully sound and clean.

If you want, say **yes** and I’ll give you the analogous `DlTheory` patch (edges store `ReasonId`, path reconstruction returns `ReasonId`, exports/imports equalities with `ReasonId`).
