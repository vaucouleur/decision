Below is the **concrete next step**: DL (difference logic) with **real explanations**:

1. **Propagation explanations**: a path in the shortest-path closure, turned into a deduped list of `Lit` reasons.
2. **Conflict explanations**: a **negative cycle**, reconstructed and explained as the lits on the cycle.
3. A simple **shared-term filter** so UF/DL only exchange equalities about terms that are actually shared.

I’ll keep it implementable and “toy but correct”.

---

# 1) Fix the DL rollback bookkeeping for edges

In my previous DL skeleton I left a TODO: we must undo edges from the correct adjacency list. Store `(from_node, count)` in the edge undo stack.

Replace:

```rust
edge_undo: Vec<usize>,
```

with:

```rust
edge_undo: Vec<(NodeId, usize)>, // (from, how_many_edges_appended_to_adj[from])
```

And update `add_edge`:

```rust
fn add_edge(&mut self, from: TermId, to: TermId, w: i64, why: Lit) {
    let f = self.node(from);
    let t = self.node(to);
    self.adj[f.0 as usize].push(Edge { to: t, w, why });
    self.edge_undo.push((f, 1));
}
```

Rollback edges:

```rust
while self.edge_undo.len() > eu {
    let (from, k) = self.edge_undo.pop().unwrap();
    let list = &mut self.adj[from.0 as usize];
    for _ in 0..k {
        list.pop();
    }
}
```

This now rollbacks edges correctly.

---

# 2) APSP with predecessor edges (for path reconstruction)

We’ll use Floyd–Warshall, but we also store the **last edge used** for each `(i,j)` so we can reconstruct the path and collect `why` literals.

### Represent predecessor as “an incoming edge to j”

We store:

```rust
pred[i][j] = Some((k, why)) meaning:
the best path i->j ends with an edge k->j justified by `why`
```

Then we can reconstruct the path by walking backwards:

* start at `(i,j)`
* take `(k, why)` from pred[i][j]
* then continue with `(i,k)` until `i==j`

### Implement it

Add:

```rust
#[derive(Clone, Copy, Debug)]
struct Pred {
    prev: NodeId, // predecessor node k in edge k->j
    why: Lit,     // reason literal for that last edge
}
```

Update `all_pairs_shortest_paths()`:

```rust
fn all_pairs_shortest_paths(&self) -> (
    Vec<Vec<Option<i64>>>,
    Vec<Vec<Option<Pred>>>,
    Option<(NodeId, Vec<Lit>)>, // (cycle_start, lits) if neg cycle found (optional explanation)
) {
    let n = self.nodes.len();
    let mut dist = vec![vec![None; n]; n];
    let mut pred = vec![vec![None; n]; n];

    for i in 0..n {
        dist[i][i] = Some(0);
    }

    // init from edges
    for (i, edges) in self.adj.iter().enumerate() {
        for e in edges {
            let j = e.to.0 as usize;
            if dist[i][j].map_or(true, |cur| e.w < cur) {
                dist[i][j] = Some(e.w);
                pred[i][j] = Some(Pred { prev: NodeId(i as u32), why: e.why });
            }
        }
    }

    // Floyd–Warshall
    for k in 0..n {
        for i in 0..n {
            let dik = dist[i][k];
            if dik.is_none() { continue; }
            for j in 0..n {
                let dkj = dist[k][j];
                if dkj.is_none() { continue; }
                let cand = dik.unwrap() + dkj.unwrap();
                if dist[i][j].map_or(true, |cur| cand < cur) {
                    dist[i][j] = Some(cand);
                    // Path i->j goes i->k then k->j, so predecessor of (i,j) is predecessor of (k,j)
                    pred[i][j] = pred[k][j];
                }
            }
        }
    }

    // Negative cycle: dist[v][v] < 0. Reconstruct a cycle explanation.
    for v in 0..n {
        if let Some(d) = dist[v][v] {
            if d < 0 {
                let start = NodeId(v as u32);
                let lits = self.reconstruct_cycle_lits(&pred, start);
                return (dist, pred, Some((start, lits)));
            }
        }
    }

    (dist, pred, None)
}
```

---

# 3) Reconstruct path explanation (for propagation)

We need: explanation of why `dist[y][x] <= c` holds — i.e., a path from `y` to `x`.

### Path reconstruction to lits

```rust
fn reconstruct_path_lits(&self, pred: &[Vec<Option<Pred>>], from: NodeId, to: NodeId) -> Vec<Lit> {
    let n = self.nodes.len();
    let i = from.0 as usize;
    let mut j = to.0 as usize;

    let mut out = Vec::new();
    let mut seen = HashSet::<Lit, FxBuild>::default();

    // Walk backwards using pred[i][j]
    // Stop when we reach `from`.
    let mut safety = 0;
    while j != i {
        safety += 1;
        if safety > n + 5 {
            break; // prevent infinite loop in broken pred (shouldn't happen)
        }
        let Some(p) = pred[i][j] else {
            break;
        };
        if seen.insert(p.why) {
            out.push(p.why);
        }
        j = p.prev.0 as usize;
    }

    out
}
```

This returns a (deduped) list of reason literals along the path.

---

# 4) Reconstruct negative cycle explanation (for conflict)

Given a node `v` where `dist[v][v] < 0`, we want lits on a cycle from `v` to itself.

With Floyd–Warshall’s `pred[v][v]`, we can walk backward around the cycle. To ensure we’re in the cycle, we can do the standard trick: follow predecessors `n` times to enter the cycle.

### Cycle reconstruction

```rust
fn reconstruct_cycle_lits(&self, pred: &[Vec<Option<Pred>>], start: NodeId) -> Vec<Lit> {
    let n = self.nodes.len();
    let s = start.0 as usize;

    // Step 1: move `cur` backward n times to ensure we are inside the cycle
    let mut cur = s;
    for _ in 0..n {
        if let Some(p) = pred[s][cur] {
            cur = p.prev.0 as usize;
        } else {
            return Vec::new();
        }
    }

    // Step 2: now traverse until we revisit a node
    let mut visited = vec![false; n];
    let mut out = Vec::new();
    let mut seen_lit = HashSet::<Lit, FxBuild>::default();

    let mut v = cur;
    while !visited[v] {
        visited[v] = true;
        if let Some(p) = pred[s][v] {
            if seen_lit.insert(p.why) {
                out.push(p.why);
            }
            v = p.prev.0 as usize;
        } else {
            break;
        }
    }

    out
}
```

This produces a subset explanation (lits on some predecessor chain) that’s typically good enough.

---

# 5) Put explanations into DL propagation/conflict

Modify `propagate()`:

```rust
fn propagate(&mut self) -> Result<Vec<TheoryPropagation>, TheoryConflict> {
    let (dist, pred, neg) = self.all_pairs_shortest_paths();

    if let Some((_start, mut explain)) = neg {
        if explain.is_empty() {
            // fallback: all assigned DL atoms (sound)
            explain = self.atoms.values()
                .filter_map(|a| a.value.map(|v| if v { Lit::pos(a.var) } else { Lit::neg(a.var) }))
                .collect();
        }
        return Err(TheoryConflict { explain });
    }

    let mut props = Vec::new();
    for (_t, a) in self.atoms.iter_mut() {
        if a.value.is_some() { continue; }

        let x = self.node(a.x);
        let y = self.node(a.y);

        // Must be TRUE if dist[y][x] <= c
        if self.implies_true(&dist, x, y, a.c) && a.propagated != Some(true) {
            a.propagated = Some(true);
            let explain = self.reconstruct_path_lits(&pred, y, x);
            props.push(TheoryPropagation { implied: Lit::pos(a.var), explain });
            continue;
        }

        // Must be FALSE if dist[x][y] <= -c-1
        if self.implies_false(&dist, x, y, a.c) && a.propagated != Some(false) {
            a.propagated = Some(false);
            let explain = self.reconstruct_path_lits(&pred, x, y);
            props.push(TheoryPropagation { implied: Lit::neg(a.var), explain });
        }
    }

    Ok(props)
}
```

Now DL produces tight-ish explanations.

---

# 6) Shared-term detection to avoid equality spam

You don’t want UF and DL to export/import equalities for every term they know. You only want terms that are:

* **shared** across theories (appear in atoms of multiple theories), or
* explicitly marked as “shared” by the engine.

### Minimal engine-side shared set

In your engine, build a `HashSet<TermId>` of “shared terms” from registered atoms:

* For UF equality atoms `(= a b)`, shared candidates are `a` and `b`
* For DL atoms `(x - y <= c)`, shared candidates are `x` and `y`

Then, a term is “shared” if it appears in >=2 theories, or appears in one theory but contains subterms from another (start simple: >=2 theories).

Implement in engine once per `check_sat` call:

```rust
fn compute_shared_terms(&self) -> hashbrown::HashSet<smt_core::TermId, FxBuild> {
    let mut owners: HashMap<smt_core::TermId, u32, FxBuild> = HashMap::default();

    for atom in self.atoms.iter_atoms() {
        // atom.term is Bool term; extract its endpoint terms for that theory
        // Provide per-theory "shared endpoints" hook:
        // theory.shared_terms_of_atom(atom.term) -> Vec<TermId>
    }

    let mut shared = hashbrown::HashSet::default();
    for (t, mask) in owners {
        // If multiple bits set, it's shared.
        if mask.count_ones() >= 2 {
            shared.insert(t);
        }
    }
    shared
}
```

### Simpler (first cut): keep a *manual shared* list

For baby steps, you can implement shared filtering inside export functions by only exporting equalities whose endpoints are in `engine.shared_terms`.

So extend export API to accept shared set:

```rust
fn export_equalities(&mut self, shared: &HashSet<TermId>) -> Vec<SharedEq>;
```

Then UF exports equalities where both endpoints are in `shared`.

DL exports equalities discovered where both endpoints are in `shared`.

That’s enough to prevent “spam”.

---

# 7) DL exporting equalities (for combination)

DL can export `a=b` when it can prove:

* `a - b <= 0` and `b - a <= 0`

Using closure:

```rust
if dist[b][a] <= 0 && dist[a][b] <= 0
```

Explanation:

* path lits for b->a plus path lits for a->b

So DL’s export is:

```rust
let explain1 = reconstruct_path_lits(pred, b, a);
let explain2 = reconstruct_path_lits(pred, a, b);
let explain = union_dedup(explain1, explain2);
SharedEq { a, b, explain }
```

UF imports with `union(term(a), term(b), reason(explain))` (using Reason DAG or just flatten).

---

## If you want one more “tightening” improvement

Right now Floyd–Warshall is O(n³). You can switch to:

* incremental Bellman–Ford from a super-source per propagate call, or
* maintain potentials incrementally (more complex)

But for a solver architecture demo, Floyd–Warshall is fine.

---

If you say **yes** again, I’ll provide the full `EqualitySharing` trait-object “capability” pattern in Rust (no downcast needed), plus concrete `UfTheoryInc::export_equalities/import_equality` and `DlTheory::export_equalities/import_equality` implementations that use the shared-term filter.
