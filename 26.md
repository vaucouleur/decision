Below is a compact, **SMT-LIB-ish front-end** you can put on top of your `Context` + `Solver`, plus the **right architecture hook** for combining theories later (UF + LIA) without painting yourself into a corner.

I’ll give you:

1. an ergonomic builder API (`declare_sort`, `declare_fun`, `term builders`)
2. `assert`, `check_sat`, `get_unsat_core` in the same façade
3. the *theory-combination seam*: a shared-equalities channel you can implement incrementally

---

# 1) Minimal SMT-LIB-ish facade

Create a new crate `smt-api` (or put in `crates/smt/src/` if you prefer).

### `crates/smt-api/src/lib.rs`

```rust
#![forbid(unsafe_code)]
#![warn(missing_docs)]

use std::sync::Arc;

use smt_core::{BoolTerm, Context, SortId, TermId};
use smt_sat::ToyCdcl;

use smt_engine::{AtomClassifier, SmtEngine, SolveResult};
use smt::Label; // reuse from your `smt` facade crate if you made it

/// Public check-sat result.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CheckSat {
    Sat,
    Unsat,
}

/// A minimal SMT-LIB-like session:
/// - owns an SMT context
/// - owns a solver engine
/// - provides builders for terms and declarations
pub struct Session {
    ctx: Arc<Context>,
    solver: smt::Solver, // your facade wrapper from previous step

    classifier: Box<dyn AtomClassifier>,
}

impl Session {
    /// Build a session with a pre-configured engine + classifier.
    ///
    /// In practice you'll have a `Session::with_uf()` or `with_default_theories()` constructor.
    pub fn new(ctx: Arc<Context>, engine: SmtEngine<ToyCdcl>, classifier: Box<dyn AtomClassifier>) -> Self {
        let solver = smt::Solver::new(ctx.clone(), engine);
        Self { ctx, solver, classifier }
    }

    pub fn ctx(&self) -> &Context {
        &self.ctx
    }

    // ----------------------------
    // SMT-LIB-like declarations
    // ----------------------------

    /// (declare-sort U 0)
    pub fn declare_uninterpreted_sort(&mut self, name: &str) -> SortId {
        let mut_ctx = Arc::get_mut(&mut self.ctx).expect("Session owns the only Arc<Context> in this minimal API");
        let sym = mut_ctx.intern_sym(name);
        mut_ctx.mk_uninterpreted_sort(sym)
    }

    /// (declare-fun a () U)
    pub fn declare_const(&mut self, name: &str, sort: SortId) -> TermId {
        let mut_ctx = Arc::get_mut(&mut self.ctx).expect("Session owns the only Arc<Context> in this minimal API");
        mut_ctx.mk_var(name, sort)
    }

    /// (declare-fun f (U) U)
    ///
    /// Returns the function symbol id (you apply it with `app_uf` below).
    pub fn declare_ufun(&mut self, name: &str) -> smt_core::SymbolId {
        let mut_ctx = Arc::get_mut(&mut self.ctx).expect("Session owns the only Arc<Context> in this minimal API");
        mut_ctx.intern_sym(name)
    }

    // ----------------------------
    // Term builders
    // ----------------------------

    pub fn bool(&self, name: &str) -> TermId {
        // Pure boolean variable (as SMT bool sort).
        // If your smt-core has mk_bool_var, call that; otherwise mk_var(name, bool_sort()).
        let mut_ctx = self.ctx.clone();
        let mut_ctx = Arc::get_mut(&mut_ctx).expect("use a mutable session ctx in real code");
        mut_ctx.mk_var(name, mut_ctx.bool_sort())
    }

    pub fn eq(&self, a: TermId, b: TermId) -> smt_core::Result<BoolTerm> {
        self.ctx.eq(a, b)
    }

    pub fn not(&self, a: BoolTerm) -> smt_core::Result<BoolTerm> {
        self.ctx.not(a)
    }

    pub fn and<I>(&self, it: I) -> smt_core::Result<BoolTerm>
    where
        I: IntoIterator<Item = BoolTerm>,
    {
        self.ctx.and(it)
    }

    pub fn or<I>(&self, it: I) -> smt_core::Result<BoolTerm>
    where
        I: IntoIterator<Item = BoolTerm>,
    {
        self.ctx.or(it)
    }

    /// Apply an uninterpreted function `f` to args; you specify the result sort.
    pub fn app_uf(&self, f: smt_core::SymbolId, args: &[TermId], res_sort: SortId) -> smt_core::Result<TermId> {
        self.ctx.mk_app(smt_core::Op::new(smt_core::OpKind::Uf(f)), args.iter().copied(), res_sort)
    }

    // ----------------------------
    // SMT-LIB-like solver commands
    // ----------------------------

    pub fn push(&mut self) {
        self.solver.push();
    }

    pub fn pop(&mut self, n: usize) {
        self.solver.pop(n);
    }

    /// (assert φ) with optional label to appear in UNSAT core.
    pub fn assert(&mut self, term: BoolTerm, label: Option<&str>) -> smt_core::Result<()> {
        let lab = label.map(|s| Label(s.to_string()));
        self.solver.assert(term, lab, self.classifier.as_ref())
    }

    pub fn check_sat(&mut self) -> CheckSat {
        match self.solver.check_sat() {
            smt::CheckSat::Sat => CheckSat::Sat,
            smt::CheckSat::Unsat => CheckSat::Unsat,
        }
    }

    pub fn get_unsat_core(&self) -> Vec<Label> {
        self.solver.get_unsat_core()
    }
}
```

### Note about `Arc::get_mut`

For a real library, you’d wrap `Context` behind interior mutability (e.g. `RwLock`) or build all declarations up front and then freeze it. The demo keeps it simple.

---

# 2) A nice constructor: `Session::with_uf()`

Here’s a practical “batteries included” function that wires:

* SAT kernel `ToyCdcl`
* UF theory (`UfTheoryInc` with incremental CC)
* default classifier that recognizes UF equalities

### `crates/smt-api/src/with_uf.rs`

```rust
use std::sync::Arc;

use smt_core::Context;
use smt_engine::{SmtEngine, DefaultClassifier, TheoryId};
use smt_engine::theories::uf_theory_inc::UfTheoryInc;
use smt_sat::ToyCdcl;

use crate::Session;

pub fn session_with_uf(ctx: Arc<Context>) -> Session {
    let uf_id = TheoryId(0);

    // UF theory
    let uf = UfTheoryInc::new(ctx.clone(), uf_id);

    // Engine atoms table starts empty; incremental encoding will populate it.
    let atoms = smt_engine::atoms::AtomTable::default();

    let sat = ToyCdcl::new();
    let eng = SmtEngine::new(sat, atoms, vec![Box::new(uf)]);

    let classifier: Box<dyn smt_engine::AtomClassifier> = Box::new(DefaultClassifier::new(uf_id));

    Session::new(ctx, eng, classifier)
}
```

---

# 3) Example usage (SMT-LIB-ish)

### `crates/smt-demo/src/main.rs` (new style)

```rust
use std::sync::Arc;

use smt_api::with_uf::session_with_uf;

fn main() -> smt_core::Result<()> {
    let ctx = Arc::new(smt_core::Context::default());
    let mut sess = session_with_uf(ctx);

    // (declare-sort U 0)
    let u = sess.declare_uninterpreted_sort("U");

    // (declare-fun a () U), (declare-fun b () U)
    let a = sess.declare_const("a", u);
    let b = sess.declare_const("b", u);

    // (declare-fun f (U) U)
    let f = sess.declare_ufun("f");

    let fa = sess.app_uf(f, &[a], u)?;
    let fb = sess.app_uf(f, &[b], u)?;

    // assert: (= a b) labeled "A"
    let eq_ab = sess.eq(a, b)?;
    sess.assert(eq_ab, Some("A"))?;

    // assert: (not (= (f a) (f b))) labeled "B"
    let eq_f = sess.eq(fa, fb)?;
    let neq_f = sess.not(eq_f)?;
    sess.assert(neq_f, Some("B"))?;

    match sess.check_sat() {
        smt_api::CheckSat::Sat => println!("SAT"),
        smt_api::CheckSat::Unsat => {
            println!("UNSAT");
            println!("core: {:?}", sess.get_unsat_core());
        }
    }

    Ok(())
}
```

You should get UNSAT and core should include `A` and `B` (typically).

---

# 4) The theory-combination seam (UF + LIA later)

To combine theories properly (Nelson–Oppen style), you need one explicit “shared equalities” channel:

* The Boolean abstraction already gives you equality atoms.
* For combination, you need to **detect equalities between shared terms** and exchange them between theories.

A clean architecture hook is:

### `crates/smt-engine/src/shared.rs`

```rust
use smt_core::TermId;

/// A shared-equality event between theories.
#[derive(Debug, Clone)]
pub struct SharedEq {
    pub a: TermId,
    pub b: TermId,
}

/// Shared terms are those that appear in atoms owned by multiple theories.
pub trait SharedEqualitySink {
    fn add_shared_eq(&mut self, eq: SharedEq);
}

/// The engine can offer a sink to theories (or call a method on each theory).
```

Then extend `Theory` with an optional method:

```rust
fn export_equalities(&mut self, out: &mut dyn SharedEqualitySink);
fn import_equalities(&mut self, eqs: &[SharedEq]);
```

**Minimal combo strategy (first step):**

* Only export *equalities implied* by each theory among shared terms
* Import them as additional asserted equalities (with explanations)
* Use the same clause mechanism (explain => implied equality atom) to keep it sound

This is how you scale from UF-only to UF+LIA without rewriting your engine.

---

# 5) A very practical “combo-ready” atom classifier

Instead of a single classifier, have a registry:

```rust
pub struct Classifier {
  uf: TheoryId,
  lia: TheoryId,
  // ...
}

impl AtomClassifier for Classifier {
  fn classify_bool_term(&self, ctx: &Context, t: TermId) -> Option<TheoryId> {
    // 1) if (= over Int) => LIA
    // 2) if (<, <= over Int) => LIA
    // 3) if (= over uninterpreted sort / UF apps) => UF
    // ...
  }
}
```

That way your Boolean abstraction remains stable while you add theories.

---

If you say **yes** again, I’ll sketch the simplest **LIA “theory”** that’s still meaningful (difference constraints / Bellman-Ford style, so you can do `<` and `<=` propagation/conflicts), and then show the *exact* interface points where UF+LIA start sharing equalities (Nelson–Oppen in baby steps).
