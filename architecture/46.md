Below is a clean **cross-crate** setup so the **same test debug guard** can enable UNSAT bundles for:

* integration tests in `smt-tests`
* unit tests inside `smt-engine` (or any crate that builds an `SmtEngine`)

The idea: put the global toggle in **smt-engine** behind `cfg(test)` *and* behind a feature `test-debug`, then both `smt-engine` tests and external test crates can flip it.

---

# 1) Add a `test-debug` feature to `smt-engine`

### `crates/smt-engine/Cargo.toml`

```toml
[features]
default = []
test-debug = []
```

In your workspace, make sure `smt-tests` depends on `smt-engine` with `features = ["test-debug"]`.

---

# 2) Put the global toggle in `smt-engine` (feature-gated)

### `crates/smt-engine/src/test_debug.rs`

```rust
#![forbid(unsafe_code)]

#[cfg(feature = "test-debug")]
mod inner {
    use std::sync::atomic::{AtomicBool, Ordering};

    static EQSHARE_DEBUG_ENABLED: AtomicBool = AtomicBool::new(false);

    /// Enable eq-sharing debug output (UNSAT bundle) for the current process.
    ///
    /// Intended for tests. External crates can call this when `smt-engine/test-debug` is enabled.
    pub fn set_eqshare_debug_enabled(enabled: bool) {
        EQSHARE_DEBUG_ENABLED.store(enabled, Ordering::SeqCst);
    }

    /// Read the current debug-enabled flag.
    pub fn eqshare_debug_enabled() -> bool {
        EQSHARE_DEBUG_ENABLED.load(Ordering::SeqCst)
    }
}

#[cfg(feature = "test-debug")]
pub use inner::{eqshare_debug_enabled, set_eqshare_debug_enabled};

#[cfg(not(feature = "test-debug"))]
pub fn eqshare_debug_enabled() -> bool { false }

#[cfg(not(feature = "test-debug"))]
pub fn set_eqshare_debug_enabled(_enabled: bool) {
    // no-op when feature is disabled
}
```

Export it from `lib.rs`:

### `crates/smt-engine/src/lib.rs`

```rust
pub mod test_debug;
```

---

# 3) Engine builder reads the toggle (in all tests)

Where you create the engine config (in the engine constructor or Session builder), do:

```rust
if crate::test_debug::eqshare_debug_enabled() {
    self.config.debug_eq.enabled = true;
    self.config.debug_eq.max_reason_lits = 16;
}
```

Best place: inside `SmtEngine::new(...)` after config initialization, or in `Session::new(...)`.

Example in `SmtEngine::new`:

```rust
pub fn new(/* ... */) -> Self {
    let mut eng = Self {
        // ...
        config: EngineConfig::default(),
        // ...
    };

    if crate::test_debug::eqshare_debug_enabled() {
        eng.config.debug_eq.enabled = true;
        eng.config.debug_eq.max_reason_lits = 16;
    }

    eng
}
```

So every test-created engine automatically honors the toggle.

---

# 4) RAII guard lives in `smt-tests` but calls into `smt-engine`

Now `smt-tests` doesn’t need its own atomic; it uses the engine’s.

### `crates/smt-tests/src/test_debug_guard.rs`

```rust
#![forbid(unsafe_code)]

/// RAII guard to enable eq-sharing debug output (UNSAT bundle) for the lifetime of the guard.
pub struct EnableEqShareDebug {
    prev: bool,
}

impl EnableEqShareDebug {
    pub fn new() -> Self {
        let prev = smt_engine::test_debug::eqshare_debug_enabled();
        smt_engine::test_debug::set_eqshare_debug_enabled(true);
        Self { prev }
    }
}

impl Drop for EnableEqShareDebug {
    fn drop(&mut self) {
        smt_engine::test_debug::set_eqshare_debug_enabled(self.prev);
    }
}
```

---

# 5) Make `smt-tests` enable the feature

### `crates/smt-tests/Cargo.toml`

```toml
[dependencies]
smt-engine = { path = "../smt-engine", features = ["test-debug"] }
```

Now:

* `cargo test -p smt-tests` can flip the toggle
* `cargo test -p smt-engine` can also flip it from inside its own tests (since feature can be enabled in dev-deps)

If you want `smt-engine`’s own unit tests to have the feature by default, add in `crates/smt-engine/Cargo.toml`:

```toml
[dev-dependencies]
smt-engine = { path = ".", features = ["test-debug"] }
```

(This self-dev-dep pattern is common for enabling test-only features.)

---

# 6) Where the bundle is written

Since the engine writes to `target/smt-debug-<pid>/...`, both unit tests and integration tests will write to the same predictable location.

If you want to include the test name, you can add:

* `SMT_TEST_NAME` env var in the test, and append it to the directory name.

---

# 7) Usage in any test crate

```rust
#[test]
fn ping_pong_regression_matrix() {
    let _dbg = EnableEqShareDebug::new();
    // run test; on UNSAT engine writes bundle
}
```

---

If you want, I can also show a lightweight “bundle-on-failure” wrapper: it enables debug only if `CHECK_SAT` returns UNSAT unexpectedly (e.g., you expected SAT), so the suite stays quiet unless something goes wrong.
