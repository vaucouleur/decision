Cool — here’s the **negative-information demo** (propagation → conflict) that’s a great sanity check for explanations.

We’ll build a formula that is *not* immediately contradictory syntactically, but becomes contradictory once UF propagates congruence:

* `a = b`
* `f(a) != f(b)`  (i.e., `(not (= (f a) (f b)))`)
* plus a “mask” disjunction so SAT might try to avoid setting some atoms, but UF will still force it

A clean version is simply:

> `a = b ∧ ¬(f(a)=f(b))`

That’s already UNSAT and you already have it.
To make it “propagation then conflict” visibly, we’ll use:

> `a = b ∧ ( (f(a)=f(b)) ∨ r ) ∧ ¬(f(a)=f(b))`

SAT can satisfy `(eq_fafb ∨ r)` by setting `r=true`, but the last conjunct forces `eq_fafb=false`. UF then propagates `eq_fafb=true` from `a=b`, causing a conflict with explanation that includes both:

* `a=b` (why eq_fafb must be true)
* `¬eq_fafb` (the asserted disequality)

Your `LoggingTheory` wrapper will print the **propagation** and then the **conflict**.

---

## 1) Add the formula builder

### `crates/smt-demo/src/main.rs` (add this helper)

```rust
/// Build formula:
///   (and
///     (= a b)
///     (or (= (f a) (f b)) r)
///     (not (= (f a) (f b))))
///
/// Expectation:
/// - SAT asserts ¬eq_fafb from the third conjunct.
/// - UF propagates eq_fafb from a=b.
/// - UF reports a conflict with explanation containing:
///     [ (= a b), ¬(= f(a) f(b)) ]  (plus any internal reasons)
fn mk_propagation_then_conflict_formula(
    ctx: &mut Context,
    u: SortId,
    a: TermId,
    b: TermId,
    f_sym: smt_core::SymbolId,
) -> BoolTerm {
    let fa = mk_f_app(ctx, f_sym, a, u);
    let fb = mk_f_app(ctx, f_sym, b, u);

    let eq_ab = ctx.eq(a, b).expect("eq");
    let eq_fafb = ctx.eq(fa, fb).expect("eq");
    let neq_fafb = ctx.not(eq_fafb).expect("not");

    let r = ctx.mk_bool_var("r");
    let disj = ctx.or([eq_fafb, r]).expect("or");

    ctx.and([eq_ab, disj, neq_fafb]).expect("and")
}
```

---

## 2) Add the demo block

### `crates/smt-demo/src/main.rs` (add in `main()`)

Add this after the propagation demo:

```rust
    // ---------- PROPAGATION -> CONFLICT demo ----------
    {
        let mut ctx = Context::default();
        let (u, a, b, _c, f_sym) = build_uf_terms(&mut ctx);

        let root = mk_propagation_then_conflict_formula(&mut ctx, u, a, b, f_sym);

        println!("PROP->CONFLICT instance: {}", ctx.pretty_term(root.id()));
        println!("(Expect UF to propagate (= (f a) (f b)) true, then conflict with its negation)\n");

        let res = solve_with_uf(Arc::new(ctx), root)?;
        println!("Result: {:?}\n", res);
        assert_eq!(res, SolveResult::Unsat);
    }
```

When you run:

```bash
cargo run -p smt-demo
```

You should see something like:

```
[UF] propagate: implied=vN explain=[vM]
[UF] conflict: explain=[..., ¬vN]
Result: Unsat
```

The exact literal list depends on your explanation construction, but it should definitely include:

* the assumption/atom literal for `a=b` (positive)
* the literal for `¬(f(a)=f(b))` (negative)

---

## 3) Small note about “why does UF see both sides?”

For this to work, the UF theory must be notified of:

* the atom `(= a b)` assigned true
* the atom `(= f(a) f(b))` assigned false (because of `not eq_fafb`)

Your `AtomClassifier` must classify both of these equality terms as UF atoms (it should, since `=` over uninterpreted sort).

---

## 4) If you want the conflict explanation to be *cleaner*

Right now `explain_eq()` may include some duplicated literals. A simple polish (still readable) is to **deduplicate** explanation literals before returning:

* in UF `explain_eq` and in conflict construction, run a `FxHashSet<Lit>` to keep unique ones.

This doesn’t change correctness, just makes logs nicer and learned clauses smaller.

---

If you say **yes** again, I’ll show the next “serious” step for UF: a **proper e-graph style congruence closure** (still rollbackable) where function application merges are incremental (not rebuild-per-propagate), plus more precise explanations (closer to what cvc5/z3 do).
