Below are the **two concrete code patches** that make the **DL→UF** and **ping-pong** tests pass reliably:

1. UF `atom_endpoints` must include **UF-app arguments** (so `x` and `y` count as shared when they appear inside `g(x)` / `g(y)`)
2. UF `export_equalities` must export **congruence equalities between shared UF-app terms** (so `f(a)=f(b)` gets exported even if it’s not an explicit asserted atom)

I’ll show both as drop-in additions to your reasoned UF theory (`UfTheory`).

---

# 1) UF `atom_endpoints`: include UF app args (direct or recursive)

### Patch in `crates/smt-engine/src/theories/uf_theory_reasoned.rs`

Add this helper inside `impl UfTheory`:

```rust
impl UfTheory {
    /// Collect arguments of UF applications appearing inside `t`.
    ///
    /// For shared-term detection, we want `x` to be considered shared if it appears
    /// as an argument of a UF app in a UF atom (e.g. g(x) != g(y)).
    fn collect_uf_app_args(&self, t: TermId, out: &mut Vec<TermId>) {
        let (k, _) = self.ctx.term_node(t);
        match k {
            TermKind::App { op, args } => {
                if matches!(op.kind, smt_core::OpKind::Uf(_)) {
                    for &a in args {
                        out.push(a);
                        // Optional recursion: uncomment if you want deeper shared terms
                        // self.collect_uf_app_args(a, out);
                    }
                } else {
                    // Recurse through non-UF apps too (optional, but useful if you have wrappers)
                    for &a in args {
                        self.collect_uf_app_args(a, out);
                    }
                }
            }
            _ => {}
        }
    }
}
```

Now update UF’s `atom_endpoints` implementation:

```rust
fn atom_endpoints(&self, atom_term: TermId) -> Vec<TermId> {
    let Some(a) = self.atoms.get(&atom_term) else { return Vec::new(); };

    let mut out = vec![a.lhs, a.rhs];

    // Include UF app arguments to make Int vars shared with DL when used in UF apps.
    self.collect_uf_app_args(a.lhs, &mut out);
    self.collect_uf_app_args(a.rhs, &mut out);

    // Optional: dedup here (not strictly required; engine's shared computation can dedup)
    out
}
```

✅ This is the key that makes DL export `x=y` in the DL→UF regression, because now `x` and `y` are “shared terms”.

---

# 2) UF export: bucket shared UF-app terms by representative and export equalities

Your current UF export likely only iterates over **UF atoms**. That’s not enough for UF→DL or ping-pong because `f(a)=f(b)` is *derived by congruence*, not explicitly asserted.

We’ll export equalities among **shared UF-app terms** that are currently in the same UF equivalence class.

## 2.1 Helper: “is UF app term?”

Add inside `impl UfTheory`:

```rust
impl UfTheory {
    fn is_uf_app_term(&self, t: TermId) -> bool {
        let (k, _) = self.ctx.term_node(t);
        matches!(k, TermKind::App { op, .. } if matches!(op.kind, smt_core::OpKind::Uf(_)))
    }
}
```

## 2.2 Export bucket logic (spanning-tree per class)

Replace/extend your `impl EqualitySharing for UfTheory` export method:

```rust
impl EqualitySharing for UfTheory {
    fn export_equalities(
        &mut self,
        shared: &hashbrown::HashSet<TermId, core::hash::BuildHasherDefault<rustc_hash::FxHasher>>,
        tcx: &mut TheoryCtx,
    ) -> Vec<SharedEq> {
        use hashbrown::HashMap;
        use crate::theories::uf_cc_reasoned::NodeId;

        // 1) Keep your existing export of entailed UF atoms if you want (fine but optional).
        let mut out = Vec::new();

        // 2) NEW: Export congruence equalities among shared UF-app terms.
        //
        // Collect shared UF-app terms and bucket them by UF representative.
        let mut buckets: HashMap<NodeId, Vec<TermId>, core::hash::BuildHasherDefault<rustc_hash::FxHasher>> =
            HashMap::default();

        for &t in shared.iter() {
            if !self.is_uf_app_term(t) {
                continue;
            }
            let nt = self.uf.ensure_term(t, tcx);
            let rep = self.uf.find(nt);
            buckets.entry(rep).or_default().push(t);
        }

        // For each bucket, export a spanning tree of equalities: head = others.
        for (_rep, terms) in buckets {
            if terms.len() < 2 {
                continue;
            }
            let head = terms[0];

            // Ensure head is in UF
            let nhead = self.uf.ensure_term(head, tcx);

            for &other in &terms[1..] {
                let nother = self.uf.ensure_term(other, tcx);

                // Explain why head = other (should be Some since same rep)
                if let Some(r) = self.uf.explain_eq(nhead, nother, tcx) {
                    out.push(SharedEq { a: head, b: other, explain: r });
                }
            }
        }

        out
    }

    fn import_equality(&mut self, eq: SharedEq, tcx: &mut TheoryCtx) {
        let na = self.uf.ensure_term(eq.a, tcx);
        let nb = self.uf.ensure_term(eq.b, tcx);
        self.uf.union_with_tcx(na, nb, eq.explain, tcx);
    }
}
```

✅ This ensures UF exports equalities like `f(a)=f(b)` (Int-returning UF apps) once `a=b` is asserted.
That’s exactly what the UF→DL test and ping-pong test need.

---

# 3) One more tiny but important classifier note

For the ping-pong and DL→UF tests, your classifier must treat:

* `Eq` where either side contains a UF app → UF
* `Le/Lt` on Int → DL

You already have that `contains_uf_app` heuristic; keep it.

---

# 4) Why these patches are “solid”

* **Shared-term detection** now matches the Nelson–Oppen idea: shared variables are those that occur in both theories, even if one theory sees them only as **arguments** inside its function terms.
* UF export by representative yields a **bounded** number of equalities (spanning tree per class), preventing quadratic blowups.

---

If you say **yes**, I’ll show the last “cleanup polish” that makes this feel production-ready:

* a `SharedTermOracle` in the engine (so theories don’t need to guess what’s shared),
* plus a small throttle/epoch mechanism so `export_equalities` doesn’t keep re-exporting the same equalities every loop iteration.
