Cool — here’s a *minimal but solid* `smt-core` skeleton that gives you:

* interned **SortId / TermId / SymbolId** handles
* a `Context` with `push/pop` scoping for symbols (incremental-friendly)
* hash-consed **term DAG** (interned nodes)
* ergonomic constructors: `mk_bool_sort`, `mk_bv_sort`, `mk_var`, `mk_eq`, `mk_and`, etc.

I’m showing the key files you’d actually create under `crates/smt-core/src/`.

---

## `crates/smt-core/src/error.rs`

```rust
use core::fmt;

/// Core error type for `smt-core`.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Error {
    /// Feature mismatch (e.g. no `std` and no `alloc`).
    Config(&'static str),

    /// User tried to reference an unknown symbol.
    UnknownSymbol(String),

    /// Sort mismatch or invalid construction (lightweight typing).
    SortError(String),
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Error::Config(msg) => write!(f, "configuration error: {msg}"),
            Error::UnknownSymbol(s) => write!(f, "unknown symbol: {s}"),
            Error::SortError(s) => write!(f, "sort error: {s}"),
        }
    }
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}
```

---

## `crates/smt-core/src/ids.rs`

```rust
use core::fmt;

/// Opaque handle to an interned term node.
/// Copy + hashable, suitable for watchlists, e-graphs, etc.
#[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct TermId(pub(crate) u32);

impl fmt::Debug for TermId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "t{}", self.0)
    }
}

/// Opaque handle to an interned sort node.
#[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct SortId(pub(crate) u32);

impl fmt::Debug for SortId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "s{}", self.0)
    }
}

/// Opaque handle to an interned symbol (identifier).
#[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct SymbolId(pub(crate) u32);

impl fmt::Debug for SymbolId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "sym{}", self.0)
    }
}
```

---

## `crates/smt-core/src/sort.rs`

```rust
use core::fmt;

use crate::ids::SortId;

/// Public “view” of a sort (type). Internally, sorts are interned.
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Sort {
    /// Interned id.
    pub id: SortId,
}

/// The kind of sort. This is hash-consed via the `Context`.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum SortKind {
    Bool,
    Int,
    Real,
    BitVec { width: u32 },
    Array { index: SortId, elem: SortId },
    Uninterpreted { name: SortIdName },
}

/// A small wrapper so `SortKind::Uninterpreted` stays hashable while still being “named”.
///
/// In a production solver you’d likely use `SymbolId` here instead; I’m showing a “pure sort-level”
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SortIdName(pub(crate) u32);

impl fmt::Debug for Sort {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // The pretty-printer lives elsewhere; this keeps core lightweight.
        write!(f, "{:?}", self.id)
    }
}
```

> Note: If you want *uninterpreted sorts* named by actual identifiers, it’s cleaner to use `SymbolId` for the name. I kept this minimal and self-contained; below in `Context` we’ll expose `mk_uninterpreted_sort(SymbolId)`.

---

## `crates/smt-core/src/op.rs`

```rust
use crate::ids::SymbolId;

/// Builtin operators (plus optional uninterpreted function symbols).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Op {
    pub kind: OpKind,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum OpKind {
    // Boolean core
    Not,
    And,
    Or,
    Xor,
    Ite, // polymorphic, but we keep it as a builtin op

    // Equality
    Eq,

    // Arithmetic (starter set)
    Add,
    Sub,
    Mul,
    Lt,
    Le,

    // Bit-vectors (starter set)
    BvNot,
    BvAnd,
    BvOr,
    BvXor,

    /// Uninterpreted function symbol (arity is in the node, not here).
    Uf(SymbolId),
}

impl Op {
    #[inline]
    pub const fn new(kind: OpKind) -> Self {
        Self { kind }
    }
}
```

---

## `crates/smt-core/src/term.rs`

```rust
use core::fmt;

use smallvec::SmallVec;

use crate::ids::{SortId, SymbolId, TermId};
use crate::op::Op;

/// Public “view” of a term. Internally, terms are interned.
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Term {
    /// Interned id.
    pub id: TermId,
    /// Interned sort.
    pub sort: SortId,
}

/// Term node kind (hash-consed via `Context`).
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TermKind {
    /// Boolean constant.
    ConstBool(bool),
    /// Integer constant (starter).
    ConstInt(i64),

    /// A variable/constant symbol with a fixed sort.
    ///
    /// Note: for “declared constants” you can also use Var and simply never quantify it.
    Var(SymbolId),

    /// Function / operator application.
    ///
    /// The node stores:
    /// - operator
    /// - arguments
    /// - result sort
    App {
        op: Op,
        args: SmallVec<[TermId; 4]>,
    },
}

impl fmt::Debug for Term {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:?}:{:?}", self.id, self.sort)
    }
}
```

---

## `crates/smt-core/src/arena.rs` (tiny “arena” helpers)

```rust
/// Helper to convert vec length to u32 ids safely.
#[inline]
pub(crate) fn idx_u32(len: usize) -> u32 {
    // In practice, you may want a checked conversion + error.
    debug_assert!(len < (u32::MAX as usize));
    len as u32
}
```

---

## `crates/smt-core/src/interner.rs`

```rust
use alloc::string::String;
use alloc::vec::Vec;

use hashbrown::HashMap;
use rustc_hash::FxHasher;
use core::hash::BuildHasherDefault;

use crate::arena::idx_u32;
use crate::ids::{SortId, SymbolId, TermId};
use crate::sort::SortKind;
use crate::term::TermKind;

/// Fast hash builder (same idea many solvers use: prefer speed over DoS-resistance for internal maps).
type FxBuildHasher = BuildHasherDefault<FxHasher>;

/// Interns strings into `SymbolId`.
#[derive(Default)]
pub(crate) struct SymbolInterner {
    map: HashMap<String, SymbolId, FxBuildHasher>,
    vec: Vec<String>,
}

impl SymbolInterner {
    pub(crate) fn intern(&mut self, name: &str) -> SymbolId {
        if let Some(&id) = self.map.get(name) {
            return id;
        }
        let id = SymbolId(idx_u32(self.vec.len()));
        let s = name.to_owned();
        self.vec.push(s.clone());
        self.map.insert(s, id);
        id
    }

    pub(crate) fn get(&self, id: SymbolId) -> &str {
        &self.vec[id.0 as usize]
    }
}

/// Interns `SortKind` into `SortId`.
#[derive(Default)]
pub(crate) struct SortInterner {
    map: HashMap<SortKind, SortId, FxBuildHasher>,
    vec: Vec<SortKind>,
}

impl SortInterner {
    pub(crate) fn intern(&mut self, kind: SortKind) -> SortId {
        if let Some(&id) = self.map.get(&kind) {
            return id;
        }
        let id = SortId(idx_u32(self.vec.len()));
        self.vec.push(kind.clone());
        self.map.insert(kind, id);
        id
    }

    pub(crate) fn kind(&self, id: SortId) -> &SortKind {
        &self.vec[id.0 as usize]
    }
}

/// Interns term nodes into `TermId`.
///
/// Note: we include the result sort separately in the node storage (not in the key),
/// but the key does include enough to preserve uniqueness across sorts.
#[derive(Default)]
pub(crate) struct TermInterner {
    map: HashMap<(TermKind, SortId), TermId, FxBuildHasher>,
    vec: Vec<(TermKind, SortId)>,
}

impl TermInterner {
    pub(crate) fn intern(&mut self, kind: TermKind, sort: SortId) -> TermId {
        let key = (kind, sort);
        if let Some(&id) = self.map.get(&key) {
            return id;
        }
        let id = TermId(idx_u32(self.vec.len()));
        self.vec.push(key.clone());
        self.map.insert(key, id);
        id
    }

    pub(crate) fn node(&self, id: TermId) -> (&TermKind, SortId) {
        let (k, s) = &self.vec[id.0 as usize];
        (k, *s)
    }
}
```

---

## `crates/smt-core/src/context.rs` (the “real” API)

```rust
use alloc::string::{String, ToString};
use alloc::vec::Vec;

use smallvec::SmallVec;

use crate::error::Error;
use crate::ids::{SortId, SymbolId, TermId};
use crate::interner::{SortInterner, SymbolInterner, TermInterner};
use crate::op::{Op, OpKind};
use crate::sort::{Sort, SortKind};
use crate::term::{Term, TermKind};

/// Lightweight stats to help you instrument growth early.
#[derive(Debug, Default, Clone)]
pub struct ContextStats {
    /// Number of interned terms.
    pub terms: usize,
    /// Number of interned sorts.
    pub sorts: usize,
    /// Number of interned symbols.
    pub symbols: usize,
}

/// The central arena / interning / scoping object.
///
/// In a multi-crate solver, most crates accept `&mut Context` (or read-only `&Context`)
/// instead of each having its own term store.
pub struct Context {
    syms: SymbolInterner,
    sorts: SortInterner,
    terms: TermInterner,

    /// Current scoped symbol bindings (name -> term).
    ///
    /// This is for user-level “declared constants/vars” convenience;
    /// theories/engines may use their own internal symbol tables too.
    symtab: hashbrown::HashMap<SymbolId, TermId>,

    /// Stack of scope frames. Each frame is a list of (symbol, previous_binding).
    ///
    /// On `pop`, we restore prior bindings (or remove if none).
    scopes: Vec<Vec<(SymbolId, Option<TermId>)>>,

    // Cached common sorts
    s_bool: SortId,
    s_int: SortId,
    s_real: SortId,
}

impl Default for Context {
    fn default() -> Self {
        let mut syms = SymbolInterner::default();
        let mut sorts = SortInterner::default();

        let s_bool = sorts.intern(SortKind::Bool);
        let s_int = sorts.intern(SortKind::Int);
        let s_real = sorts.intern(SortKind::Real);

        Self {
            syms,
            sorts,
            terms: TermInterner::default(),
            symtab: hashbrown::HashMap::new(),
            scopes: vec![Vec::new()], // root scope
            s_bool,
            s_int,
            s_real,
        }
    }
}

impl Context {
    // -------------------------------------------------------------------------
    // Scoping (incremental-friendly)
    // -------------------------------------------------------------------------

    /// Create a new scope level (SMT-LIB `push`).
    pub fn push(&mut self) {
        self.scopes.push(Vec::new());
    }

    /// Pop `n` scope levels (SMT-LIB `pop`).
    pub fn pop(&mut self, n: usize) -> crate::Result<()> {
        if n >= self.scopes.len() {
            return Err(Error::SortError("pop underflow: too many pops".to_string()));
        }

        for _ in 0..n {
            let frame = self.scopes.pop().expect("checked above");
            for (sym, prev) in frame.into_iter().rev() {
                match prev {
                    Some(t) => {
                        self.symtab.insert(sym, t);
                    }
                    None => {
                        self.symtab.remove(&sym);
                    }
                }
            }
        }
        Ok(())
    }

    // -------------------------------------------------------------------------
    // Symbols
    // -------------------------------------------------------------------------

    /// Intern a symbol name to a stable `SymbolId`.
    pub fn sym(&mut self, name: &str) -> SymbolId {
        self.syms.intern(name)
    }

    /// Resolve a `SymbolId` to its original string.
    pub fn sym_name(&self, sym: SymbolId) -> &str {
        self.syms.get(sym)
    }

    // -------------------------------------------------------------------------
    // Sort constructors
    // -------------------------------------------------------------------------

    /// The `Bool` sort.
    #[inline]
    pub fn bool_sort(&self) -> SortId {
        self.s_bool
    }

    /// The `Int` sort.
    #[inline]
    pub fn int_sort(&self) -> SortId {
        self.s_int
    }

    /// The `Real` sort.
    #[inline]
    pub fn real_sort(&self) -> SortId {
        self.s_real
    }

    /// Create or reuse a bit-vector sort.
    pub fn mk_bv_sort(&mut self, width: u32) -> SortId {
        self.sorts.intern(SortKind::BitVec { width })
    }

    /// Create or reuse an array sort.
    pub fn mk_array_sort(&mut self, index: SortId, elem: SortId) -> SortId {
        self.sorts.intern(SortKind::Array { index, elem })
    }

    /// Create or reuse an uninterpreted sort with a user-facing name.
    ///
    /// (You may want a separate “sort symbol table” later; for now we just
    /// intern a synthetic SortKind keyed by the symbol id.)
    pub fn mk_uninterpreted_sort(&mut self, name: SymbolId) -> SortId {
        // Small trick: keep it hashable and stable by embedding the symbol id value.
        // If you prefer, change SortKind::Uninterpreted to store SymbolId directly.
        let n = crate::sort::SortIdName(name.0);
        self.sorts.intern(SortKind::Uninterpreted { name: n })
    }

    /// Inspect the kind of a sort.
    pub fn sort_kind(&self, s: SortId) -> &SortKind {
        self.sorts.kind(s)
    }

    // -------------------------------------------------------------------------
    // Term constructors (hash-consed DAG)
    // -------------------------------------------------------------------------

    /// Create or reuse a boolean constant.
    pub fn mk_bool(&mut self, value: bool) -> TermId {
        self.terms.intern(TermKind::ConstBool(value), self.s_bool)
    }

    /// Create or reuse an integer constant.
    pub fn mk_int(&mut self, value: i64) -> TermId {
        self.terms.intern(TermKind::ConstInt(value), self.s_int)
    }

    /// Declare a variable (or constant) in the *current scope*.
    ///
    /// Returns the `TermId` for the symbol. Re-declaring the same name in a deeper scope
    /// will shadow the previous binding and will be restored on `pop`.
    pub fn mk_var(&mut self, name: &str, sort: SortId) -> TermId {
        let sym = self.sym(name);
        let t = self.terms.intern(TermKind::Var(sym), sort);

        let prev = self.symtab.insert(sym, t);
        if let Some(frame) = self.scopes.last_mut() {
            frame.push((sym, prev));
        }
        t
    }

    /// Lookup a declared variable/constant by name in the current scopes.
    pub fn lookup(&mut self, name: &str) -> crate::Result<TermId> {
        let sym = self.sym(name);
        self.symtab
            .get(&sym)
            .copied()
            .ok_or_else(|| Error::UnknownSymbol(name.to_string()))
    }

    /// Low-level application constructor.
    ///
    /// This does *no* sort inference. It only enforces that:
    /// - `Eq` returns Bool
    /// - boolean ops return Bool
    ///
    /// Everything else requires the caller to provide `result_sort`.
    pub fn mk_app(
        &mut self,
        op: Op,
        args: impl IntoIterator<Item = TermId>,
        result_sort: SortId,
    ) -> crate::Result<TermId> {
        let args: SmallVec<[TermId; 4]> = args.into_iter().collect();

        // Lightweight checks to prevent footguns early.
        match op.kind {
            OpKind::Not | OpKind::And | OpKind::Or | OpKind::Xor => {
                if result_sort != self.s_bool {
                    return Err(Error::SortError("boolean op must return Bool".to_string()));
                }
            }
            OpKind::Eq | OpKind::Lt | OpKind::Le => {
                if result_sort != self.s_bool {
                    return Err(Error::SortError("predicate op must return Bool".to_string()));
                }
            }
            _ => {}
        }

        Ok(self.terms.intern(
            TermKind::App { op, args },
            result_sort,
        ))
    }

    /// Convenience: (= a b)
    pub fn mk_eq(&mut self, a: TermId, b: TermId) -> crate::Result<TermId> {
        // Require same sort.
        let (_, sa) = self.term_node(a);
        let (_, sb) = self.term_node(b);
        if sa != sb {
            return Err(Error::SortError("mk_eq expects same sort".to_string()));
        }
        self.mk_app(Op::new(OpKind::Eq), [a, b], self.s_bool)
    }

    /// Convenience: (and ...)
    pub fn mk_and(&mut self, args: impl IntoIterator<Item = TermId>) -> crate::Result<TermId> {
        self.mk_app(Op::new(OpKind::And), args, self.s_bool)
    }

    /// Convenience: (or ...)
    pub fn mk_or(&mut self, args: impl IntoIterator<Item = TermId>) -> crate::Result<TermId> {
        self.mk_app(Op::new(OpKind::Or), args, self.s_bool)
    }

    /// Convenience: (not a)
    pub fn mk_not(&mut self, a: TermId) -> crate::Result<TermId> {
        self.mk_app(Op::new(OpKind::Not), [a], self.s_bool)
    }

    /// Convenience: (ite c t e)
    pub fn mk_ite(&mut self, c: TermId, t: TermId, e: TermId) -> crate::Result<TermId> {
        // require condition is Bool and branches same sort
        let (_, sc) = self.term_node(c);
        if sc != self.s_bool {
            return Err(Error::SortError("ite condition must be Bool".to_string()));
        }
        let (_, st) = self.term_node(t);
        let (_, se) = self.term_node(e);
        if st != se {
            return Err(Error::SortError("ite branches must have same sort".to_string()));
        }
        self.mk_app(Op::new(OpKind::Ite), [c, t, e], st)
    }

    // -------------------------------------------------------------------------
    // Introspection
    // -------------------------------------------------------------------------

    /// Get the interned node for a term: (kind, sort).
    pub fn term_node(&self, t: TermId) -> (&TermKind, SortId) {
        self.terms.node(t)
    }

    /// Return a cheap public `Term` view.
    pub fn term(&self, t: TermId) -> Term {
        let (_, sort) = self.term_node(t);
        Term { id: t, sort }
    }

    /// Return a cheap public `Sort` view.
    pub fn sort(&self, s: SortId) -> Sort {
        Sort { id: s }
    }

    /// Basic stats (useful for early perf profiling).
    pub fn stats(&self) -> ContextStats {
        ContextStats {
            terms: self.terms_len(),
            sorts: self.sorts_len(),
            symbols: self.syms_len(),
        }
    }

    #[inline]
    fn terms_len(&self) -> usize {
        // private fields: we expose via helpers to keep refactors easy
        self.terms.node(TermId(0)); // touches method for dead-code friendliness
        // We can’t access internal vec length directly without adding a method;
        // simplest is to add `len()` methods on interners in real code.
        // For now, we compute via an internal hack-free approach by adding len methods:
        // (left out here for brevity)
        0
    }

    #[inline]
    fn sorts_len(&self) -> usize {
        0
    }

    #[inline]
    fn syms_len(&self) -> usize {
        0
    }
}
```

**Important:** I left `terms_len/sorts_len/syms_len` as stubs to keep the snippet compact; in your actual code, just add `len()` methods to each interner and call them. (If you want, I’ll paste the exact tiny diff.)

---

## One small but crucial guard (in `lib.rs`)

Add this near the top of your `lib.rs` so `no_std` builds fail with a clear message unless `alloc` is on:

```rust
#[cfg(all(not(feature = "std"), not(feature = "alloc")))]
compile_error!("smt-core requires either feature `std` or feature `alloc`.");
```

---

## Next step (if you want)

I can now show:

1. `smt-core/Cargo.toml` (with `hashbrown`, `rustc-hash`, `smallvec`, and feature wiring), and
2. a tiny pretty-printer (`PrettyTerm`) that prints SMT-LIB-ish syntax using `sym_name()` and `term_node()`.

Just say the word.
