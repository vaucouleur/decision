Here’s a compact, **high-signal debug mode** for equality sharing that won’t drown you in logs, but will make combination bugs obvious:

* logs **per epoch**:

  * shared-term count
  * exported equalities (src→dst, pretty-printed terms, and a short reason summary)
* optionally logs **expanded literal reasons** (bounded to N lits)
* includes a **“first time seen”** filter so you don’t spam the same equality repeatedly across epochs

I’ll show: config + engine integration + pretty-print hooks.

---

# 1) Add debug config

### `crates/smt-engine/src/config.rs`

```rust
#[derive(Debug, Clone, Copy)]
pub struct DebugEqSharing {
    pub enabled: bool,
    pub max_reason_lits: usize,     // cap reason expansion
    pub log_imports: bool,
    pub log_exports: bool,
    pub log_shared_stats: bool,
}

impl Default for DebugEqSharing {
    fn default() -> Self {
        Self {
            enabled: false,
            max_reason_lits: 8,
            log_imports: true,
            log_exports: true,
            log_shared_stats: true,
        }
    }
}
```

Extend your engine config:

```rust
#[derive(Debug, Clone, Copy, Default)]
pub struct EngineConfig {
    pub sharing: SharingConfig,
    pub debug_eq: DebugEqSharing,
}
```

Or keep as separate fields on `SmtEngine`.

---

# 2) Engine: store a “seen equality log” set

To avoid repeated logs across epochs, keep a `HashSet` of `(src, dst, min(a,b), max(a,b))`.

### `crates/smt-engine/src/engine.rs` fields

```rust
use hashbrown::HashSet;
use rustc_hash::FxHasher;
use core::hash::BuildHasherDefault;

type FxBuild = BuildHasherDefault<FxHasher>;

pub struct SmtEngine<K: SatKernel> {
    // ...
    pub export_epoch: u64,
    pub shared_terms: SharedTermOracle,
    pub config: EngineConfig,

    eq_log_seen: HashSet<(TheoryId, TheoryId, TermId, TermId), FxBuild>,
}
```

Init in `new()`:

```rust
eq_log_seen: HashSet::default(),
```

Reset it on full reset / new solve if you want.

---

# 3) Pretty-printing helper (terms + lits)

You likely have a `Context` that can render terms. If not, just print `TermId` and sort.

### `crates/smt-engine/src/debug_fmt.rs`

```rust
#![forbid(unsafe_code)]

use smt_core::{Context, TermId};
use smt_sat::Lit;

pub fn fmt_term(ctx: &Context, t: TermId) -> String {
    // If you have a real pretty printer, use it here.
    // Otherwise: a stable-ish fallback
    format!("{t:?}")
}

pub fn fmt_lit(l: Lit) -> String {
    // Customize based on your SAT var formatting
    if l.is_pos() { format!("v{}", l.var().as_u32()) } else { format!("¬v{}", l.var().as_u32()) }
}
```

---

# 4) Engine: log exports/imports in `equality_sharing_round()`

Drop-in replacement with logging. This assumes:

* engine has access to `self.ctx: Arc<Context>` (or any `&Context`)
* `self.reasons.expand_lits(ReasonId) -> Vec<Lit>`

```rust
pub fn equality_sharing_round(&mut self) {
    use crate::theory::EqualitySharing;
    use crate::theory_ctx::TheoryCtx;

    let dbg = self.config.debug_eq;
    let enabled = dbg.enabled;

    let mut tcx = TheoryCtx::new(&mut self.reasons);

    if enabled && dbg.log_shared_stats {
        eprintln!(
            "[eqshare][epoch={}]: shared_terms={}",
            self.export_epoch,
            self.shared_terms.shared_set().len()
        );
    }

    let mut exported: Vec<(TheoryId, SharedEq)> = Vec::new();

    for (i, th) in self.theories.iter_mut().enumerate() {
        let src = TheoryId(i);
        if let Some(sh) = th.equality_sharing_mut() {
            for eq in sh.export_equalities(&self.shared_terms, self.export_epoch, &mut tcx) {
                exported.push((src, eq));
            }
        }
    }

    if exported.is_empty() {
        return;
    }

    for (src, eq) in exported {
        for (j, th) in self.theories.iter_mut().enumerate() {
            let dst = TheoryId(j);
            if dst == src { continue; }

            let allow = match (src, dst) {
                (s, d) if s == self.uf_id && d == self.dl_id => self.config.sharing.uf_to_dl,
                (s, d) if s == self.dl_id && d == self.uf_id => self.config.sharing.dl_to_uf,
                _ => true,
            };
            if !allow { continue; }

            // log (first time seen)
            if enabled && (dbg.log_exports || dbg.log_imports) {
                let (p, q) = if eq.a < eq.b { (eq.a, eq.b) } else { (eq.b, eq.a) };
                let key = (src, dst, p, q);

                if self.eq_log_seen.insert(key) {
                    let a_str = crate::debug_fmt::fmt_term(&self.ctx, eq.a);
                    let b_str = crate::debug_fmt::fmt_term(&self.ctx, eq.b);

                    let mut msg = String::new();
                    if dbg.log_exports {
                        msg.push_str(&format!(
                            "[eqshare][epoch={}]: {} -> {} export {} = {}",
                            self.export_epoch, self.theories[src.0].name(), self.theories[dst.0].name(), a_str, b_str
                        ));
                    } else {
                        msg.push_str(&format!(
                            "[eqshare][epoch={}]: {} -> {} import {} = {}",
                            self.export_epoch, self.theories[src.0].name(), self.theories[dst.0].name(), a_str, b_str
                        ));
                    }

                    // reason (bounded)
                    let lits = self.reasons.expand_lits(eq.explain);
                    if !lits.is_empty() && dbg.max_reason_lits > 0 {
                        msg.push_str("  because ");
                        for (idx, l) in lits.iter().take(dbg.max_reason_lits).enumerate() {
                            if idx > 0 { msg.push_str(", "); }
                            msg.push_str(&crate::debug_fmt::fmt_lit(*l));
                        }
                        if lits.len() > dbg.max_reason_lits {
                            msg.push_str(", ...");
                        }
                    }

                    eprintln!("{msg}");
                }
            }

            if let Some(sh) = th.equality_sharing_mut() {
                sh.import_equality(eq.clone(), &mut tcx);
            }
        }
    }

    self.export_epoch = self.export_epoch.wrapping_add(1);
}
```

### Two practical notes

* `self.theories[src.0].name()` requires `theories` indexing by `TheoryId`; adapt if needed.
* If you don’t store `self.ctx` in engine, pass it in (or use the Session’s ctx).

---

# 5) Make it easy to enable in tests

In your test builder:

```rust
let mut sess = make_session(SharingConfig { uf_to_dl: true, dl_to_uf: true });
sess.engine_mut().config.debug_eq.enabled = true;
sess.engine_mut().config.debug_eq.max_reason_lits = 16;
```

Or set via env var:

```rust
let enabled = std::env::var("SMT_EQSHARE_DEBUG").is_ok();
eng.config.debug_eq.enabled = enabled;
```

Then run:

```bash
SMT_EQSHARE_DEBUG=1 cargo test -p smt-tests ping_pong -- --nocapture
```

---

# 6) What you’ll see (typical)

For ping-pong:

* UF exports `f(a)=f(b)` “because vAB”
* DL exports `x=y` “because vX_LE_FA, vFA_LE_X, vY_LE_FB, vFB_LE_Y, vAB, ...”
* UF conflicts on `g(x) != g(y)` after importing `x=y`

You’ll immediately know which hop is missing if the logs don’t appear.

---

If you want, I can also show a “graphviz dump” of the reason DAG for a single conflict (still bounded, no huge output), but this textual logger is usually enough to iterate quickly.
