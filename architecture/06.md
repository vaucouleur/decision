Below is a clean **typed layer** you can drop into `smt-core` (or into a small `smt-typed` crate if you prefer). It gives you:

* `BoolTerm`, `IntTerm`, `BvTerm<W>`-ish ergonomics (runtime width for BV, since SMT widths are dynamic)
* constructors that return typed wrappers
* conversions back to `TermId` are cheap
* no runtime overhead besides the checks at construction time

Iâ€™ll show it as `crates/smt-core/src/typed.rs`, plus the small `lib.rs` additions.

---

## 1) `crates/smt-core/src/typed.rs`

```rust
//! Typed term wrappers for safer construction.
//!
//! These newtypes help keep higher layers (preprocess, SAT+theories, engine)
//! from repeatedly re-checking sorts everywhere.
//!
//! - They are zero-cost wrappers around `TermId`.
//! - Construction performs sort checks once.
//! - They improve API clarity and reduce â€œwrong-sortâ€ bugs early.

use crate::context::Context;
use crate::error::Error;
use crate::ids::{SortId, TermId};
use crate::op::{Op, OpKind};
use crate::sort::SortKind;

/// A term known to have sort Bool.
#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
pub struct BoolTerm(TermId);

impl BoolTerm {
    /// Wrap a raw term id after checking it is Bool.
    pub fn try_from_term(ctx: &Context, t: TermId) -> crate::Result<Self> {
        ctx.ensure_bool(t)?;
        Ok(Self(t))
    }

    /// Get the underlying term id.
    #[inline]
    pub fn id(self) -> TermId {
        self.0
    }
}

/// A term known to have sort Int.
#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
pub struct IntTerm(TermId);

impl IntTerm {
    /// Wrap a raw term id after checking it is Int.
    pub fn try_from_term(ctx: &Context, t: TermId) -> crate::Result<Self> {
        ctx.ensure_sort(t, ctx.int_sort())?;
        Ok(Self(t))
    }

    /// Get the underlying term id.
    #[inline]
    pub fn id(self) -> TermId {
        self.0
    }
}

/// A term known to have a bit-vector sort, with runtime width.
#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
pub struct BvTerm {
    id: TermId,
    width: u32,
}

impl BvTerm {
    /// Wrap a raw term id after checking it is BitVec, capturing its width.
    pub fn try_from_term(ctx: &Context, t: TermId) -> crate::Result<Self> {
        match ctx.sort_kind(ctx.term_sort(t)) {
            SortKind::BitVec { width } => Ok(Self { id: t, width: *width }),
            _ => Err(Error::SortError("expected BitVec term".to_string())),
        }
    }

    /// Get the underlying term id.
    #[inline]
    pub fn id(self) -> TermId {
        self.id
    }

    /// Bit-width of the term.
    #[inline]
    pub fn width(self) -> u32 {
        self.width
    }
}

/// Small â€œtyped constructorsâ€ implemented as methods on `Context`.
///
/// Keeping this in `smt-core` makes it easy for other crates in the workspace
/// to use typed building blocks without copying sort checks everywhere.
impl Context {
    // -------------------------------------------------------------------------
    // Typed literals / vars
    // -------------------------------------------------------------------------

    /// Create a Bool constant (typed).
    pub fn mk_bool_t(&mut self, value: bool) -> BoolTerm {
        BoolTerm(self.mk_bool(value))
    }

    /// Create an Int constant (typed).
    pub fn mk_int_t(&mut self, value: i64) -> IntTerm {
        IntTerm(self.mk_int(value))
    }

    /// Declare a Bool variable (typed) in the current scope.
    pub fn mk_bool_var(&mut self, name: &str) -> BoolTerm {
        let t = self.mk_var(name, self.bool_sort());
        BoolTerm(t)
    }

    /// Declare an Int variable (typed) in the current scope.
    pub fn mk_int_var(&mut self, name: &str) -> IntTerm {
        let t = self.mk_var(name, self.int_sort());
        IntTerm(t)
    }

    /// Declare a BitVec variable (typed) in the current scope.
    pub fn mk_bv_var(&mut self, name: &str, width: u32) -> BvTerm {
        let s = self.mk_bv_sort(width);
        let t = self.mk_var(name, s);
        BvTerm { id: t, width }
    }

    // -------------------------------------------------------------------------
    // Typed boolean connectives
    // -------------------------------------------------------------------------

    /// (not a)
    pub fn not(&mut self, a: BoolTerm) -> crate::Result<BoolTerm> {
        let t = self.mk_app(Op::new(OpKind::Not), [a.id()], self.bool_sort())?;
        Ok(BoolTerm(t))
    }

    /// (and a b)
    pub fn and2(&mut self, a: BoolTerm, b: BoolTerm) -> crate::Result<BoolTerm> {
        let t = self.mk_app(Op::new(OpKind::And), [a.id(), b.id()], self.bool_sort())?;
        Ok(BoolTerm(t))
    }

    /// (or a b)
    pub fn or2(&mut self, a: BoolTerm, b: BoolTerm) -> crate::Result<BoolTerm> {
        let t = self.mk_app(Op::new(OpKind::Or), [a.id(), b.id()], self.bool_sort())?;
        Ok(BoolTerm(t))
    }

    /// N-ary (and ...)
    pub fn and(&mut self, args: impl IntoIterator<Item = BoolTerm>) -> crate::Result<BoolTerm> {
        let ids = args.into_iter().map(|t| t.id());
        let t = self.mk_app(Op::new(OpKind::And), ids, self.bool_sort())?;
        Ok(BoolTerm(t))
    }

    /// N-ary (or ...)
    pub fn or(&mut self, args: impl IntoIterator<Item = BoolTerm>) -> crate::Result<BoolTerm> {
        let ids = args.into_iter().map(|t| t.id());
        let t = self.mk_app(Op::new(OpKind::Or), ids, self.bool_sort())?;
        Ok(BoolTerm(t))
    }

    // -------------------------------------------------------------------------
    // Typed equality / ite
    // -------------------------------------------------------------------------

    /// Typed equality: (= a b) where both sides have the same sort.
    ///
    /// Works for Bool/Int/BV/UF/Arrays, etc. We only enforce same-sort.
    pub fn eq(&mut self, a: TermId, b: TermId) -> crate::Result<BoolTerm> {
        self.ensure_same_sort(a, b)?;
        let t = self.mk_app(Op::new(OpKind::Eq), [a, b], self.bool_sort())?;
        Ok(BoolTerm(t))
    }

    /// Typed ite over Bool condition and same-sort branches.
    pub fn ite(&mut self, c: BoolTerm, t: TermId, e: TermId) -> crate::Result<TermId> {
        let s = self.ensure_same_sort(t, e)?;
        self.mk_app(Op::new(OpKind::Ite), [c.id(), t, e], s)
    }

    // -------------------------------------------------------------------------
    // Typed integer arithmetic (starter)
    // -------------------------------------------------------------------------

    /// (+ a b) for Int terms.
    pub fn add_int(&mut self, a: IntTerm, b: IntTerm) -> crate::Result<IntTerm> {
        let t = self.mk_app(Op::new(OpKind::Add), [a.id(), b.id()], self.int_sort())?;
        Ok(IntTerm(t))
    }

    /// (< a b) for Int terms.
    pub fn lt_int(&mut self, a: IntTerm, b: IntTerm) -> crate::Result<BoolTerm> {
        let t = self.mk_app(Op::new(OpKind::Lt), [a.id(), b.id()], self.bool_sort())?;
        Ok(BoolTerm(t))
    }

    // -------------------------------------------------------------------------
    // Typed BV ops (starter)
    // -------------------------------------------------------------------------

    /// (bvand a b) where widths match.
    pub fn bvand(&mut self, a: BvTerm, b: BvTerm) -> crate::Result<BvTerm> {
        if a.width() != b.width() {
            return Err(Error::SortError("bvand expects same width".to_string()));
        }
        let s = self.mk_bv_sort(a.width());
        let t = self.mk_app(Op::new(OpKind::BvAnd), [a.id(), b.id()], s)?;
        Ok(BvTerm { id: t, width: a.width() })
    }

    /// (bvnot a)
    pub fn bvnot(&mut self, a: BvTerm) -> crate::Result<BvTerm> {
        let s = self.mk_bv_sort(a.width());
        let t = self.mk_app(Op::new(OpKind::BvNot), [a.id()], s)?;
        Ok(BvTerm { id: t, width: a.width() })
    }

    // -------------------------------------------------------------------------
    // Adapters: try to wrap raw term ids
    // -------------------------------------------------------------------------

    /// Attempt to view `t` as a BoolTerm.
    pub fn as_bool(&self, t: TermId) -> crate::Result<BoolTerm> {
        BoolTerm::try_from_term(self, t)
    }

    /// Attempt to view `t` as an IntTerm.
    pub fn as_int(&self, t: TermId) -> crate::Result<IntTerm> {
        IntTerm::try_from_term(self, t)
    }

    /// Attempt to view `t` as a BvTerm (captures width).
    pub fn as_bv(&self, t: TermId) -> crate::Result<BvTerm> {
        BvTerm::try_from_term(self, t)
    }
}
```

### Why this shape works well

* Itâ€™s â€œopt-inâ€: you can still use raw `TermId` everywhere.
* Higher layers can progressively adopt typed wrappers where it helps (e.g., Boolean layer for SAT, BV layer for bit-blasting, etc.).
* For BV, widths are dynamic in SMT, so the wrapper keeps `width: u32` at runtime.

---

## 2) Wire it into `lib.rs`

In `crates/smt-core/src/lib.rs`:

Add:

```rust
mod typed;
pub use crate::typed::{BoolTerm, IntTerm, BvTerm};
```

And optionally add them to your `prelude`:

```rust
pub mod prelude {
    pub use crate::{
        Context, Error, Result,
        Op, OpKind,
        Sort, SortId, SortKind,
        Term, TermId, TermKind,
        BoolTerm, IntTerm, BvTerm,
    };
}
```

---

## 3) Update `pretty.rs` uninterpreted sorts (reminder)

In `fmt_sort`, ensure you have:

```rust
SortKind::Uninterpreted { name } => write!(f, "{}", ctx.sym_name(*name)),
```

---

## 4) Tiny example usage (sanity check)

```rust
use smt_core::prelude::*;

fn demo() -> Result<()> {
    let mut ctx = Context::default();

    let x = ctx.mk_bool_var("x");
    let y = ctx.mk_bool_var("y");

    let f = ctx.and([x, y])?;          // (and x y)
    let g = ctx.not(f)?;               // (not (and x y))

    // Pretty print
    println!("{}", ctx.pretty_term(g.id()));

    Ok(())
}
```

---

If you say â€œyesâ€ again ğŸ™‚, next Iâ€™ll show a **minimal SAT-facing boolean literal layer** that bridges:

* `BoolTerm` â†” CNF variables (`Var`) / literals (`Lit`),
* plus a tiny Tseitin encoder in `smt-preprocess` that only needs `Context` + `BoolTerm` API.
