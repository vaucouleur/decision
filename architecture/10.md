Below are three upgrades that are still “pretty” and don’t explode complexity:

1. **Assumptions at their own decision level** + extract an **UNSAT core** (subset of assumptions)
2. **Clause minimization** (a simple, readable version)
3. **VSIDS-lite + phase saving** (small but meaningful)

I’ll show these as *incremental patches* to your `ToyCdcl` so you can integrate step-by-step.

---

# 1) Assumptions + UNSAT core (MiniSAT-style)

### What changes?

* In `solve(assumptions)`:

  * push to decision level 1
  * enqueue each assumption as a **decision** literal (reason = None)
  * if conflict happens, analyze it; if UNSAT at level 1, return an UNSAT core

### Add to `SatSolver` trait (optional extension)

If you want UNSAT cores, extend `SatSolver` with:

```rust
/// Optional: after `solve()` returns `Unsat`, return an UNSAT core
/// (subset of assumptions that are inconsistent).
fn unsat_core(&self) -> Option<&[Lit]> { None }
```

But since you already have a fixed trait, easiest is: implement it only on `ToyCdcl` as an extra method.

### Patch: store last UNSAT core

Add fields to `ToyCdcl`:

```rust
    // If the last solve was UNSAT under assumptions, store a core (subset of assumptions).
    last_unsat_core: Vec<Lit>,

    // Track which trail entries are assumptions (decision literals at assumption levels).
    // We'll keep it simple: store the assumption literals in order.
    cur_assumptions: Vec<Lit>,
```

Initialize them in `new()`:

```rust
            last_unsat_core: Vec::new(),
            cur_assumptions: Vec::new(),
```

Reset them in `reset_search_state()`:

```rust
        self.last_unsat_core.clear();
        self.cur_assumptions.clear();
```

### Patch: solve() assumption handling

Replace the “apply assumptions at level 0” block with:

```rust
        // Apply assumptions at a dedicated decision level (level 1).
        if !assumptions.is_empty() {
            self.new_decision_level(); // enter assumption level
            for &a in assumptions {
                self.cur_assumptions.push(a);

                // Treat assumption as a decision literal: reason=None
                if !self.enqueue_with_reason(a, None) {
                    // Immediate contradiction: core is trivially {a}
                    self.last_unsat_core = vec![a];
                    return SatResult::Unsat;
                }

                if let Some(conflict) = self.propagate() {
                    // UNSAT under assumptions. Extract a core.
                    self.last_unsat_core = self.analyze_unsat_core(conflict);
                    return SatResult::Unsat;
                }
            }
        }
```

### Add: `analyze_unsat_core(conflict)` (simple & effective)

This computes a core by collecting the assumptions that appear in the learned clause when resolving to level 0/1 boundary. A readable approach:

* Run normal `analyze_conflict` to get a learned clause.
* Any literal in the learned clause whose variable was set by an assumption (decision at assumption level) contributes to the core.

We need a helper to test “was this var assigned as an assumption decision?”. We can do it by checking:

* `reason[var] == None` and `level[var] == 1` and the assigned literal equals one of `cur_assumptions` (or same var).

Add this method:

```rust
    /// Extract an UNSAT core as a subset of current assumptions.
    ///
    /// Simple strategy:
    /// - Analyze the conflict, get a learned clause.
    /// - Core = assumptions whose vars appear in the learned clause.
    ///
    /// This is not necessarily minimal, but it's sound and often small.
    fn analyze_unsat_core(&self, conflict: ClauseRef) -> Vec<Lit> {
        let (learned, _backjump, _asserting) = self.analyze_conflict(conflict);

        // Mark assumption vars for O(1) membership.
        let mut is_assumption_var = vec![false; self.num_vars as usize];
        for &a in &self.cur_assumptions {
            is_assumption_var[a.var().as_u32() as usize] = true;
        }

        let mut core = Vec::new();
        for &lit in learned.iter() {
            if is_assumption_var[lit.var().as_u32() as usize] {
                // Put the assumption literal with the polarity that was assumed.
                // Find the original assumption literal for this var.
                if let Some(&a) = self.cur_assumptions.iter().find(|x| x.var() == lit.var()) {
                    core.push(a);
                }
            }
        }

        // Fallback if empty (shouldn't happen often): return all assumptions.
        if core.is_empty() {
            core.extend_from_slice(&self.cur_assumptions);
        }
        core
    }

    /// After an UNSAT result, return the last extracted unsat core (if any).
    pub fn last_unsat_core(&self) -> &[Lit] {
        &self.last_unsat_core
    }
```

That’s enough for CDCL(T) integration later (assumptions = theory lemmas / activation literals).

---

# 2) Clause minimization (simple, readable)

This reduces learned clause size by removing literals that are implied by others via their reasons (a cheap version of MiniSAT’s “recursive minimization”).

### Add inside `analyze_conflict`, right before returning learned clause

After constructing `learned` and before computing backjump, call:

```rust
                self.minimize_learned_clause(&mut learned);
```

But `analyze_conflict` currently takes `&self` and returns `learned`. Minimization needs only read access, so it’s fine.

### Add method:

```rust
    /// Try to remove redundant literals from a learned clause.
    ///
    /// Very simple criterion:
    /// - A literal `l` is removable if its variable has a reason clause and
    ///   all literals in that reason clause are already "seen" (reachable)
    ///   from the current learned clause variables.
    ///
    /// This is a readable approximation of MiniSAT minimization.
    fn minimize_learned_clause(&self, learned: &mut Clause) {
        if learned.len() <= 2 {
            return;
        }

        // We'll build a mark set of vars present in the clause.
        let mut in_clause = vec![false; self.num_vars as usize];
        for &lit in learned.iter() {
            in_clause[lit.var().as_u32() as usize] = true;
        }

        // Keep learned[0] = asserting literal always.
        let mut out: Clause = Vec::with_capacity(learned.len());
        out.push(learned[0]);

        'lit_loop: for &lit in learned.iter().skip(1) {
            let v = lit.var();

            // Decision literals (no reason) cannot be removed by this rule.
            let Some(r) = self.var_reason(v) else {
                out.push(lit);
                continue;
            };

            // If the reason clause is "covered" by vars already in the clause, drop `lit`.
            let reason_clause = &self.clauses[r];
            for &rl in reason_clause.iter() {
                let rv = rl.var();
                // ignore the literal corresponding to v itself
                if rv == v {
                    continue;
                }
                if !in_clause[rv.as_u32() as usize] {
                    // Not covered: cannot remove.
                    out.push(lit);
                    continue 'lit_loop;
                }
            }

            // Covered => we remove `lit` by not pushing it.
        }

        *learned = out;
    }
```

This will noticeably shrink learned clauses while staying easy to understand.

---

# 3) VSIDS-lite + phase saving (tiny, high impact)

### Add fields:

```rust
    // VSIDS-lite activity score per variable.
    activity: Vec<f32>,
    // Preferred polarity ("phase") per var: false => prefer negative, true => prefer positive.
    phase: Vec<bool>,
    // Activity bump amount.
    var_inc: f32,
```

Initialize in `new()`:

```rust
            activity: Vec::new(),
            phase: Vec::new(),
            var_inc: 1.0,
```

Resize in `reserve_vars`:

```rust
        self.activity.resize(self.num_vars as usize, 0.0);
        self.phase.resize(self.num_vars as usize, true);
```

Update phase when you assign a variable in `enqueue_with_reason`:

```rust
                // phase saving: remember the polarity that made the var true/false
                self.phase[idx] = !lit.is_neg();
```

### Activity bump on conflict (very simple)

After learning a clause (in `solve`, right after you computed `learned`), bump activity for vars in it:

```rust
                self.bump_activity(&learned);
```

Add method:

```rust
    /// Bump variable activity for literals in a learned clause.
    fn bump_activity(&mut self, learned: &Clause) {
        for &lit in learned.iter() {
            let idx = lit.var().as_u32() as usize;
            self.activity[idx] += self.var_inc;
        }

        // Optional: occasionally rescale to avoid float blowup.
        if self.var_inc > 1e20 {
            for a in &mut self.activity {
                *a *= 1e-20;
            }
            self.var_inc *= 1e-20;
        }

        // Increase bump for future conflicts (VSIDS-ish).
        self.var_inc *= 1.05;
    }
```

### Decision heuristic using activity + phase

Replace `pick_branch_lit()` with:

```rust
    /// Choose an unassigned variable with highest activity.
    fn pick_branch_lit(&self) -> Option<Lit> {
        let mut best: Option<(usize, f32)> = None;
        for i in 0..(self.num_vars as usize) {
            if self.assigns[i] != 0 {
                continue;
            }
            let a = self.activity[i];
            match best {
                None => best = Some((i, a)),
                Some((_bi, ba)) if a > ba => best = Some((i, a)),
                _ => {}
            }
        }

        let (i, _a) = best?;
        let v = Var::from_u32(i as u32);

        // phase saving: choose polarity that worked last time
        if self.phase[i] {
            Some(Lit::pos(v))
        } else {
            Some(Lit::neg(v))
        }
    }
```

That alone will make it dramatically less terrible on real CNFs.

---

# Minimal integration checklist

If you implement the above in order:

1. Add assumption level + `last_unsat_core()`
2. Add `minimize_learned_clause()` call inside `analyze_conflict()`
3. Add activity/phase fields + bump + new branching heuristic

…you’ll have a respectable “small CDCL” core that is still easy to read and serves as a stable boundary for CDCL(T).

---

If you say “yes” again: I’ll show how to connect this SAT core to **theory propagation** in a clean Rust way (activation literals for theory lemmas, `Theory::propagate()` returning implied literals + explanations, and how to feed them into SAT with reasons/explanation clauses).
