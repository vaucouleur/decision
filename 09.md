Below is a **readable, MiniSAT-style** reason-tracking + **1-UIP conflict analysis skeleton** that plugs into your existing `ToyCdcl`.

It upgrades the toy solver to:

* track `level[var]` and `reason[var] = Some(clause_idx)` for propagated assignments
* perform **1-UIP** analysis and learn a clause
* **non-chronological backjump** to the right level
* enqueue the learned clause’s **asserting literal** with the learned clause as its reason

This is still intentionally “reference-quality”: no VSIDS, no restarts, no clause minimization, no proof logging—just the core correctness plumbing.

---

# Updated `crates/smt-sat/src/toy_cdcl.rs` (full file)

```rust
//! Reference SAT solver (CDCL skeleton with 1-UIP learning).
//!
//! Implements:
//! - watched literals
//! - unit propagation
//! - decisions + backtracking
//! - reason tracking (reason[var] = clause index)
//! - 1-UIP conflict analysis + clause learning + non-chronological backjump
//!
//! Still missing (by design, to stay readable):
//! - VSIDS / activity
//! - restarts
//! - clause database reduction
//! - proof logging (DRAT/LRAT)
//! - assumptions as proper temporary literals with UNSAT cores

#[cfg(feature = "alloc")]
use alloc::{vec, vec::Vec};

use crate::{Clause, Lit, SatResult, SatSolver, SatStats, Var};

/// Clause reference (index into `clauses`).
type ClauseRef = usize;

/// A tiny CDCL solver skeleton.
pub struct ToyCdcl {
    num_vars: u32,
    clauses: Vec<Clause>,

    // Two watched literals per clause (by index into clause).
    watch_a: Vec<usize>,
    watch_b: Vec<usize>,

    // For each literal (var*2 + sign), list of clause indices watching it.
    watches: Vec<Vec<ClauseRef>>,

    // Assignment state
    //
    // assigns: i8 (-1 = false, 0 = unassigned, 1 = true)
    assigns: Vec<i8>,
    // level[var] = decision level at which var was assigned (0..)
    levels: Vec<u32>,
    // reason[var] = Some(clause_idx) if implied by unit propagation, None if decision (or assumption)
    reasons: Vec<Option<ClauseRef>>,

    // Trail of assigned literals in assignment order.
    trail: Vec<Lit>,
    // Trail indices where each decision level begins.
    trail_lim: Vec<usize>,
    // Propagation queue head.
    qhead: usize,

    inconsistent: bool,
    stats: SatStats,
    has_model: bool,
}

impl Default for ToyCdcl {
    fn default() -> Self {
        Self::new()
    }
}

impl ToyCdcl {
    /// Create a new empty solver.
    pub fn new() -> Self {
        Self {
            num_vars: 0,
            clauses: Vec::new(),
            watch_a: Vec::new(),
            watch_b: Vec::new(),
            watches: Vec::new(),
            assigns: Vec::new(),
            levels: Vec::new(),
            reasons: Vec::new(),
            trail: Vec::new(),
            trail_lim: Vec::new(),
            qhead: 0,
            inconsistent: false,
            stats: SatStats::default(),
            has_model: false,
        }
    }

    /// Current decision level.
    #[inline]
    fn decision_level(&self) -> usize {
        self.trail_lim.len()
    }

    /// Map literal -> watch list index.
    #[inline]
    fn lit_index(l: Lit) -> usize {
        (l.var().as_u32() as usize) * 2 + (l.is_neg() as usize)
    }

    #[inline]
    fn var_value(&self, v: Var) -> i8 {
        self.assigns[v.as_u32() as usize]
    }

    /// Literal value in current partial assignment: -1 false, 0 unassigned, 1 true.
    #[inline]
    fn lit_value(&self, l: Lit) -> i8 {
        let vv = self.var_value(l.var());
        if vv == 0 {
            0
        } else {
            let is_true = (vv == 1) ^ l.is_neg();
            if is_true { 1 } else { -1 }
        }
    }

    #[inline]
    fn var_level(&self, v: Var) -> u32 {
        self.levels[v.as_u32() as usize]
    }

    #[inline]
    fn var_reason(&self, v: Var) -> Option<ClauseRef> {
        self.reasons[v.as_u32() as usize]
    }

    /// Enqueue an assignment with an optional reason clause.
    ///
    /// - `reason = None` for decisions/assumptions
    /// - `reason = Some(cidx)` for propagated assignments
    fn enqueue_with_reason(&mut self, lit: Lit, reason: Option<ClauseRef>) -> bool {
        let v = lit.var();
        let idx = v.as_u32() as usize;
        let desired = if lit.is_neg() { -1 } else { 1 };

        match self.assigns[idx] {
            0 => {
                self.assigns[idx] = desired;
                self.levels[idx] = self.decision_level() as u32;
                self.reasons[idx] = reason;
                self.trail.push(lit);
                true
            }
            cur if cur == desired => true,
            _ => false,
        }
    }

    /// Start a new decision level.
    fn new_decision_level(&mut self) {
        self.trail_lim.push(self.trail.len());
    }

    /// Backtrack to the given decision level.
    fn backtrack(&mut self, level: usize) {
        while self.decision_level() > level {
            let start = self.trail_lim.pop().expect("non-empty");
            for lit in self.trail.drain(start..) {
                let idx = lit.var().as_u32() as usize;
                self.assigns[idx] = 0;
                self.levels[idx] = 0;
                self.reasons[idx] = None;
            }
        }
        self.qhead = self.trail.len();
    }

    /// Pick the next decision literal (very naive).
    fn pick_branch_lit(&self) -> Option<Lit> {
        for i in 0..(self.num_vars as usize) {
            if self.assigns[i] == 0 {
                return Some(Lit::pos(Var::from_u32(i as u32)));
            }
        }
        None
    }

    /// Add watchers for a clause.
    ///
    /// For unit clauses, we register only one watch entry (to avoid duplicates).
    fn init_clause_watches(&mut self, cidx: ClauseRef) {
        let clause = &self.clauses[cidx];
        debug_assert!(!clause.is_empty());

        let a = 0usize;
        let b = if clause.len() >= 2 { 1usize } else { 0usize };
        self.watch_a[cidx] = a;
        self.watch_b[cidx] = b;

        let la = clause[a];
        let lb = clause[b];

        let ia = Self::lit_index(la);
        self.watches[ia].push(cidx);

        if la != lb {
            let ib = Self::lit_index(lb);
            self.watches[ib].push(cidx);
        }
    }

    /// Internal: add a clause (original or learned) assuming vars are reserved.
    fn add_clause_internal(&mut self, clause: Clause) -> ClauseRef {
        let cidx = self.clauses.len();
        self.clauses.push(clause);
        self.watch_a.push(0);
        self.watch_b.push(0);
        self.init_clause_watches(cidx);
        cidx
    }

    /// Enqueue all unit clauses at level 0.
    ///
    /// This keeps the watched-literals propagate loop simple; it expects a seed queue.
    fn enqueue_units_at_level0(&mut self) -> bool {
        // Ensure we are at decision level 0 for safety.
        debug_assert_eq!(self.decision_level(), 0);

        for (cidx, c) in self.clauses.iter().enumerate() {
            if c.len() == 1 {
                if !self.enqueue_with_reason(c[0], Some(cidx)) {
                    return false;
                }
            }
        }
        true
    }

    /// Propagate assignments using watched literals.
    ///
    /// Returns `Some(conflicting_clause_index)` on conflict.
    fn propagate(&mut self) -> Option<ClauseRef> {
        while self.qhead < self.trail.len() {
            let p = self.trail[self.qhead];
            self.qhead += 1;
            self.stats.propagations += 1;

            // Process clauses watching ¬p (since p became true).
            let negp = p.not();
            let widx = Self::lit_index(negp);

            let mut i = 0usize;
            while i < self.watches[widx].len() {
                let cidx = self.watches[widx][i];
                let clause = &self.clauses[cidx];

                // Unit clause special case: if its only lit is false => conflict; if unassigned => enqueue.
                if clause.len() == 1 {
                    let u = clause[0];
                    match self.lit_value(u) {
                        -1 => {
                            self.stats.conflicts += 1;
                            return Some(cidx);
                        }
                        0 => {
                            if !self.enqueue_with_reason(u, Some(cidx)) {
                                self.stats.conflicts += 1;
                                return Some(cidx);
                            }
                        }
                        _ => {}
                    }
                    i += 1;
                    continue;
                }

                let wa = self.watch_a[cidx];
                let wb = self.watch_b[cidx];

                let lit_a = clause[wa];
                let lit_b = clause[wb];

                // Identify which watch equals ¬p.
                let (watch_false_pos, watch_other_pos) = if lit_a == negp {
                    (wa, wb)
                } else if lit_b == negp {
                    (wb, wa)
                } else {
                    // Stale entry; skip.
                    i += 1;
                    continue;
                };

                let other_lit = clause[watch_other_pos];
                if self.lit_value(other_lit) == 1 {
                    // Satisfied by other watch.
                    i += 1;
                    continue;
                }

                // Try to find a new watch literal that is not false.
                let mut found_new_watch = None;
                for (pos, &lit) in clause.iter().enumerate() {
                    if pos == watch_other_pos || pos == watch_false_pos {
                        continue;
                    }
                    if self.lit_value(lit) != -1 {
                        found_new_watch = Some((pos, lit));
                        break;
                    }
                }

                if let Some((new_pos, new_lit)) = found_new_watch {
                    // Move watch from ¬p to new_lit.
                    if watch_false_pos == wa {
                        self.watch_a[cidx] = new_pos;
                    } else {
                        self.watch_b[cidx] = new_pos;
                    }

                    // Remove cidx from watches[¬p] by swap-remove.
                    let last = self.watches[widx].pop().expect("non-empty");
                    if i < self.watches[widx].len() {
                        self.watches[widx][i] = last;
                    }

                    // Add to watches[new_lit]
                    let new_idx = Self::lit_index(new_lit);
                    self.watches[new_idx].push(cidx);
                    continue;
                }

                // No new watch found => clause is unit or conflict relative to other_lit.
                match self.lit_value(other_lit) {
                    -1 => {
                        self.stats.conflicts += 1;
                        return Some(cidx);
                    }
                    0 => {
                        if !self.enqueue_with_reason(other_lit, Some(cidx)) {
                            self.stats.conflicts += 1;
                            return Some(cidx);
                        }
                        i += 1;
                    }
                    1 => i += 1,
                    _ => i += 1,
                }
            }
        }

        None
    }

    /// Analyze a conflict with the 1-UIP scheme.
    ///
    /// Returns:
    /// - learned clause (with asserting literal at index 0)
    /// - backjump level
    /// - asserting literal (same as learned[0])
    ///
    /// This is the classic MiniSAT loop:
    /// - start from the conflict clause
    /// - resolve away literals at current decision level until only one remains (the UIP)
    fn analyze_conflict(&self, conflict: ClauseRef) -> (Clause, usize, Lit) {
        let dl = self.decision_level() as u32;

        // seen[var] marks vars already included in the analysis frontier.
        let mut seen = vec![false; self.num_vars as usize];

        // Learned clause being built (excluding the final UIP literal until the end).
        // We will insert the asserting literal at position 0.
        let mut learned: Clause = Vec::new();

        // Number of literals at current decision level that remain to be resolved.
        let mut path_c = 0u32;

        // Clause currently being resolved (start with conflict clause).
        let mut cur_clause: &Clause = &self.clauses[conflict];

        // Traverse the trail backwards.
        let mut idx = self.trail.len();

        // The literal we pick from the trail at the current decision level.
        let mut p: Option<Lit> = None;

        loop {
            // Visit literals in the current clause.
            for &lit in cur_clause.iter() {
                let v = lit.var();
                let vi = v.as_u32() as usize;

                if !seen[vi] && self.var_level(v) > 0 {
                    seen[vi] = true;
                    if self.var_level(v) == dl {
                        path_c += 1;
                    } else {
                        // Keep this literal in the learned clause.
                        learned.push(lit);
                    }
                }
            }

            // Select next trail literal p at current decision level that is marked seen.
            loop {
                idx -= 1;
                let q = self.trail[idx];
                if seen[q.var().as_u32() as usize] {
                    p = Some(q);
                    break;
                }
            }

            let p_lit = p.expect("must pick a literal");
            let pv = p_lit.var();
            let pvi = pv.as_u32() as usize;

            // We will resolve on pv (remove it from frontier).
            seen[pvi] = false;
            path_c -= 1;

            if path_c == 0 {
                // 1-UIP reached. Asserting literal is ¬p.
                let asserting = p_lit.not();
                learned.insert(0, asserting);

                // Compute backjump level: max level among learned[1..]
                let mut backjump = 0u32;
                for &lit in learned.iter().skip(1) {
                    backjump = backjump.max(self.var_level(lit.var()));
                }

                return (learned, backjump as usize, asserting);
            }

            // Continue with reason clause for pv (must exist for implied assignments).
            // If pv is a decision, reason=None. In the 1-UIP scheme, we should not
            // need to dereference a decision reason before `path_c` becomes 0.
            let reason = self.var_reason(pv)
                .expect("unexpected decision literal before reaching UIP");
            cur_clause = &self.clauses[reason];
        }
    }

    /// Reset search state (keep clauses & watches).
    fn reset_search_state(&mut self) {
        self.assigns.fill(0);
        self.levels.fill(0);
        self.reasons.fill(None);
        self.trail.clear();
        self.trail_lim.clear();
        self.qhead = 0;
        self.has_model = false;
        self.stats = SatStats::default();
    }
}

impl SatSolver for ToyCdcl {
    fn reserve_vars(&mut self, num_vars: u32) {
        if num_vars <= self.num_vars {
            return;
        }
        self.num_vars = num_vars;

        self.assigns.resize(self.num_vars as usize, 0);
        self.levels.resize(self.num_vars as usize, 0);
        self.reasons.resize(self.num_vars as usize, None);

        // Two literals per variable.
        self.watches.resize((self.num_vars as usize) * 2, Vec::new());
    }

    fn add_clause(&mut self, clause: Clause) {
        if self.inconsistent {
            return;
        }
        if clause.is_empty() {
            self.inconsistent = true;
            return;
        }

        // Reserve vars.
        let mut maxv = 0u32;
        for lit in clause.iter() {
            maxv = maxv.max(lit.var().as_u32() + 1);
        }
        self.reserve_vars(maxv);

        self.add_clause_internal(clause);
    }

    fn solve(&mut self, assumptions: &[Lit]) -> SatResult {
        if self.inconsistent {
            return SatResult::Unsat;
        }

        // This toy solver restarts search each call but keeps clauses (incremental add_clause works).
        self.reset_search_state();

        // Level 0: enqueue all unit clauses.
        if !self.enqueue_units_at_level0() {
            return SatResult::Unsat;
        }

        // Apply assumptions at level 0 (treated as extra unit literals).
        // For UNSAT cores, you’d want assumptions to be tracked distinctly.
        for &a in assumptions {
            if !self.enqueue_with_reason(a, None) {
                return SatResult::Unsat;
            }
        }

        if self.propagate().is_some() {
            return SatResult::Unsat;
        }

        loop {
            // If all vars assigned => SAT.
            if self.pick_branch_lit().is_none() {
                self.has_model = true;
                return SatResult::Sat;
            }

            // Decision
            let decision = self.pick_branch_lit().expect("checked above");
            self.stats.decisions += 1;
            self.new_decision_level();

            if !self.enqueue_with_reason(decision, None) {
                // Should not happen for an unassigned variable.
                self.backtrack(0);
                return SatResult::Unknown;
            }

            // Propagate & handle conflicts (CDCL loop)
            loop {
                let conflict = self.propagate();
                if conflict.is_none() {
                    break;
                }

                let conflict = conflict.expect("some");
                if self.decision_level() == 0 {
                    return SatResult::Unsat;
                }

                // 1-UIP conflict analysis:
                let (learned, backjump_level, asserting) = self.analyze_conflict(conflict);

                // Learn the clause and attach watches.
                // Note: learned clauses never introduce new vars; but we keep it robust anyway.
                let mut maxv = 0u32;
                for lit in learned.iter() {
                    maxv = maxv.max(lit.var().as_u32() + 1);
                }
                self.reserve_vars(maxv);

                let learned_cidx = self.add_clause_internal(learned);

                // Backjump and assert the asserting literal with reason = learned clause.
                self.backtrack(backjump_level);

                if !self.enqueue_with_reason(asserting, Some(learned_cidx)) {
                    // If even the asserting literal conflicts, UNSAT.
                    return SatResult::Unsat;
                }

                // Continue; propagation will re-run and may create another conflict.
            }
        }
    }

    fn value_var(&self, var: Var) -> Option<bool> {
        if !self.has_model {
            return None;
        }
        match self.assigns.get(var.as_u32() as usize).copied().unwrap_or(0) {
            1 => Some(true),
            -1 => Some(false),
            _ => None,
        }
    }

    fn stats(&self) -> SatStats {
        self.stats
    }
}
```

---

## What this enables immediately

* Your `TseitinEncoder` can now generate CNF and you can actually run:

  * propagation
  * real CDCL learning (basic 1-UIP)
  * non-chronological backtracking

Even with the naive decision heuristic, this is already a *proper* CDCL core (just slow).

---

## Next “yes” step I recommend

If you say **yes**, I’ll add (still cleanly):

1. **Reason minimization / clause minimization** (cheap win, still readable)
2. A simple **activity heuristic** (VSIDS-lite) + phase saving
3. **Assumptions at their own level** + extraction of an UNSAT core for assumptions (useful for CDCL(T) explanations)
