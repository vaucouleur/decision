Below is a clean way to do it **without creating dependency cycles**:

* `smt-sat` stays “low-level” and defines:

  * `Var`, `Lit`, `Cnf`
  * **`SatSolver` trait**
  * a **toy CDCL-ish solver** implementation (watched literals + unit propagation + backtracking; learning hooks are stubbed)

Then `smt-engine` depends on `smt-sat` and can accept any `impl SatSolver`.

---

## 1) `crates/smt-sat/Cargo.toml`

```toml
[package]
name = "smt-sat"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "SAT types + SAT solver trait + reference (toy) solver implementation."
repository = "https://example.com/your/repo"

[features]
default = ["std"]
std = ["alloc"]

# Allow no_std + alloc builds.
alloc = []

# Enable the toy solver implementation.
toy = []

[dependencies]
# No dependencies required for the minimal SAT layer.
# (Keep it tiny and stable.)
```

---

## 2) `crates/smt-sat/src/lib.rs`

```rust
//! `smt-sat` — SAT-facing types and solver API.
//!
//! This crate provides:
//! - `Var`, `Lit`
//! - `Cnf`
//! - `SatSolver` trait (engine-facing boundary)
//! - optional reference implementation: `ToyCdcl` (feature = "toy")

#![cfg_attr(not(feature = "std"), no_std)]
#![forbid(unsafe_code)]
#![warn(missing_docs)]

#[cfg(feature = "alloc")]
extern crate alloc;

mod types;
mod solver;

pub use crate::types::{Clause, Cnf, Lit, Var};
pub use crate::solver::{SatResult, SatSolver, SatStats};

#[cfg(feature = "toy")]
mod toy_cdcl;

#[cfg(feature = "toy")]
pub use crate::toy_cdcl::ToyCdcl;
```

---

## 3) `crates/smt-sat/src/types.rs`

```rust
use core::fmt;

#[cfg(feature = "alloc")]
use alloc::vec::Vec;

/// SAT variable (0-based).
#[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct Var(u32);

impl Var {
    /// Create from raw index.
    #[inline]
    pub const fn from_u32(v: u32) -> Self {
        Self(v)
    }

    /// Raw index.
    #[inline]
    pub const fn as_u32(self) -> u32 {
        self.0
    }
}

impl fmt::Debug for Var {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "v{}", self.0)
    }
}

/// SAT literal.
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Lit {
    var: Var,
    neg: bool,
}

impl Lit {
    /// Positive literal.
    #[inline]
    pub const fn pos(var: Var) -> Self {
        Self { var, neg: false }
    }

    /// Negative literal.
    #[inline]
    pub const fn neg(var: Var) -> Self {
        Self { var, neg: true }
    }

    /// Underlying variable.
    #[inline]
    pub const fn var(self) -> Var {
        self.var
    }

    /// Whether the literal is negated.
    #[inline]
    pub const fn is_neg(self) -> bool {
        self.neg
    }

    /// Negate this literal.
    #[inline]
    pub const fn not(self) -> Self {
        Self {
            var: self.var,
            neg: !self.neg,
        }
    }
}

impl fmt::Debug for Lit {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if self.neg {
            write!(f, "¬{:?}", self.var)
        } else {
            write!(f, "{:?}", self.var)
        }
    }
}

/// A CNF clause: disjunction of literals.
pub type Clause = Vec<Lit>;

/// A CNF formula: conjunction of clauses.
#[derive(Debug, Default, Clone)]
pub struct Cnf {
    /// Number of variables used.
    pub num_vars: u32,
    /// Clauses.
    pub clauses: Vec<Clause>,
}

impl Cnf {
    /// Create empty CNF.
    pub fn new() -> Self {
        Self::default()
    }

    /// Allocate a fresh SAT variable.
    pub fn fresh_var(&mut self) -> Var {
        let v = Var::from_u32(self.num_vars);
        self.num_vars += 1;
        v
    }

    /// Add a clause.
    pub fn add_clause(&mut self, clause: Clause) {
        self.clauses.push(clause);
    }

    /// Add a unit clause.
    pub fn add_unit(&mut self, lit: Lit) {
        self.add_clause(vec![lit]);
    }
}
```

---

## 4) `crates/smt-sat/src/solver.rs` — the `SatSolver` trait

```rust
#[cfg(feature = "alloc")]
use alloc::vec::Vec;

use crate::{Clause, Lit, Var};

/// Result of SAT solving.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SatResult {
    /// Satisfiable; a model can be queried via `value_var` / `value_lit`.
    Sat,
    /// Unsatisfiable under the current clauses and assumptions.
    Unsat,
    /// Unknown (time limit, resource limit, unsupported feature, etc).
    Unknown,
}

/// Light stats (useful for instrumentation).
#[derive(Debug, Default, Clone, Copy)]
pub struct SatStats {
    /// Number of decisions.
    pub decisions: u64,
    /// Number of propagations.
    pub propagations: u64,
    /// Number of conflicts.
    pub conflicts: u64,
}

/// Minimal SAT solver interface used by `smt-engine`.
///
/// Design notes:
/// - Supports incremental `add_clause`.
/// - Supports per-call `solve(&assumptions)`.
/// - Model query APIs are best-effort; return `None` if no model is available.
///
/// You can extend this later with:
/// - clause deletion / push-pop
/// - proof logging (DRAT / LRAT)
/// - callbacks for theory propagation
pub trait SatSolver {
    /// Ensure internal storage can represent at least `num_vars` variables.
    fn reserve_vars(&mut self, num_vars: u32);

    /// Add a clause to the solver (incremental interface).
    ///
    /// Clauses are expected to reference variables < current reserved var count.
    fn add_clause(&mut self, clause: Clause);

    /// Solve under optional assumptions (temporary unit literals).
    fn solve(&mut self, assumptions: &[Lit]) -> SatResult;

    /// Query a variable value in the last SAT model (if any).
    fn value_var(&self, var: Var) -> Option<bool>;

    /// Query a literal value in the last SAT model (if any).
    #[inline]
    fn value_lit(&self, lit: Lit) -> Option<bool> {
        self.value_var(lit.var()).map(|v| if lit.is_neg() { !v } else { v })
    }

    /// Current stats snapshot.
    fn stats(&self) -> SatStats;
}
```

---

## 5) `crates/smt-sat/src/toy_cdcl.rs` — minimal “toy CDCL” skeleton

This one actually does:

* watched literals
* unit propagation
* chronological backtracking
* no learning yet (but clear “hooks” where it belongs)

```rust
//! Reference SAT solver (toy CDCL-ish).
//!
//! What it implements:
//! - watched literals
//! - unit propagation
//! - decisions + chronological backtracking
//! - incremental add-clause
//! - solve(assumptions)
//!
//! What it does NOT implement (yet):
//! - clause learning / 1-UIP analysis (hooks are marked)
//! - VSIDS, restarts, clause minimization
//! - proof logging
//!
//! This is intended as a *readable skeleton* and integration target.

#[cfg(feature = "alloc")]
use alloc::{vec, vec::Vec};

use crate::{Clause, Lit, SatResult, SatSolver, SatStats, Var};

/// A tiny CDCL-like solver.
///
/// Representation choices:
/// - assignments: i8 (-1 = false, 0 = unassigned, 1 = true)
/// - trail: stack of assigned literals
/// - trail_lim: indices into `trail` marking decision level boundaries
/// - watches: per literal, a list of clause indices watching that literal
pub struct ToyCdcl {
    num_vars: u32,
    clauses: Vec<Clause>,

    // Two watched literals per clause (by index into clause).
    // If clause size < 2, we store duplicates (unit) and handle specially.
    watch_a: Vec<usize>,
    watch_b: Vec<usize>,

    // For each literal (var*2 + sign), list of clause indices watching it.
    watches: Vec<Vec<usize>>,

    // Assignment state
    assigns: Vec<i8>,
    trail: Vec<Lit>,
    trail_lim: Vec<usize>,
    qhead: usize,

    // If we detect an empty clause, we are permanently inconsistent.
    inconsistent: bool,

    stats: SatStats,

    // Model availability flag: only valid after returning SAT.
    has_model: bool,
}

impl Default for ToyCdcl {
    fn default() -> Self {
        Self::new()
    }
}

impl ToyCdcl {
    /// Create a new empty solver.
    pub fn new() -> Self {
        Self {
            num_vars: 0,
            clauses: Vec::new(),
            watch_a: Vec::new(),
            watch_b: Vec::new(),
            watches: Vec::new(),
            assigns: Vec::new(),
            trail: Vec::new(),
            trail_lim: Vec::new(),
            qhead: 0,
            inconsistent: false,
            stats: SatStats::default(),
            has_model: false,
        }
    }

    /// Current decision level.
    #[inline]
    fn decision_level(&self) -> usize {
        self.trail_lim.len()
    }

    /// Map a literal to an index for watch lists: (var*2 + (neg?1:0)).
    #[inline]
    fn lit_index(l: Lit) -> usize {
        (l.var().as_u32() as usize) * 2 + (l.is_neg() as usize)
    }

    /// Read assignment of a variable.
    #[inline]
    fn var_value(&self, v: Var) -> i8 {
        self.assigns[v.as_u32() as usize]
    }

    /// Read assignment of a literal: -1 false, 0 unassigned, 1 true.
    #[inline]
    fn lit_value(&self, l: Lit) -> i8 {
        let vv = self.var_value(l.var());
        if vv == 0 {
            0
        } else {
            let is_true = (vv == 1) ^ l.is_neg();
            if is_true { 1 } else { -1 }
        }
    }

    /// Enqueue an assignment (no reason tracking in this toy).
    ///
    /// Returns `false` if immediate conflict (assigning both true and false).
    fn enqueue(&mut self, lit: Lit) -> bool {
        let v = lit.var();
        let idx = v.as_u32() as usize;
        let desired = if lit.is_neg() { -1 } else { 1 };

        match self.assigns[idx] {
            0 => {
                self.assigns[idx] = desired;
                self.trail.push(lit);
                true
            }
            cur if cur == desired => true,
            _ => false,
        }
    }

    /// Start a new decision level.
    fn new_decision_level(&mut self) {
        self.trail_lim.push(self.trail.len());
    }

    /// Backtrack to a given decision level.
    fn backtrack(&mut self, level: usize) {
        while self.decision_level() > level {
            let start = self.trail_lim.pop().expect("non-empty");
            // Unassign variables from trail[start..]
            for lit in self.trail.drain(start..) {
                let idx = lit.var().as_u32() as usize;
                self.assigns[idx] = 0;
            }
        }
        self.qhead = self.trail.len();
    }

    /// Choose the next decision variable (very naive heuristic).
    fn pick_branch_lit(&self) -> Option<Lit> {
        for i in 0..(self.num_vars as usize) {
            if self.assigns[i] == 0 {
                return Some(Lit::pos(Var::from_u32(i as u32)));
            }
        }
        None
    }

    /// Add watchers for a clause and its two watched literal positions.
    fn init_clause_watches(&mut self, cidx: usize) {
        let clause = &self.clauses[cidx];
        let a = 0usize;
        let b = if clause.len() >= 2 { 1usize } else { 0usize };
        self.watch_a[cidx] = a;
        self.watch_b[cidx] = b;

        let la = clause[a];
        let lb = clause[b];

        self.watches[Self::lit_index(la)].push(cidx);
        self.watches[Self::lit_index(lb)].push(cidx);
    }

    /// Propagate assignments using watched literals.
    ///
    /// Returns `Some(conflicting_clause_index)` on conflict.
    fn propagate(&mut self) -> Option<usize> {
        while self.qhead < self.trail.len() {
            let p = self.trail[self.qhead];
            self.qhead += 1;
            self.stats.propagations += 1;

            // We need to process clauses watching ¬p (because p became true).
            let negp = p.not();
            let widx = Self::lit_index(negp);

            // We’ll iterate and compact in-place (classic watched-literals trick).
            let mut i = 0usize;
            while i < self.watches[widx].len() {
                let cidx = self.watches[widx][i];
                let clause = &self.clauses[cidx];

                // Identify which watch corresponds to ¬p.
                let wa = self.watch_a[cidx];
                let wb = self.watch_b[cidx];

                let lit_a = clause[wa];
                let lit_b = clause[wb];

                // Ensure lit_a is the watched literal equal to ¬p; swap if needed.
                let (watch_false_pos, watch_other_pos) = if lit_a == negp {
                    (wa, wb)
                } else if lit_b == negp {
                    (wb, wa)
                } else {
                    // This can happen if the clause was moved between watch lists and
                    // we are seeing a stale entry; skip.
                    i += 1;
                    continue;
                };

                let other_lit = clause[watch_other_pos];
                if self.lit_value(other_lit) == 1 {
                    // Clause is already satisfied by the other watch.
                    i += 1;
                    continue;
                }

                // Try to find a new literal to watch that is not false.
                let mut found_new_watch = None;
                for (pos, &lit) in clause.iter().enumerate() {
                    if pos == watch_other_pos || pos == watch_false_pos {
                        continue;
                    }
                    if self.lit_value(lit) != -1 {
                        found_new_watch = Some((pos, lit));
                        break;
                    }
                }

                if let Some((new_pos, new_lit)) = found_new_watch {
                    // Move watch from ¬p to new_lit:
                    // - update watch pos
                    // - remove clause from watches[¬p], add to watches[new_lit]
                    if watch_false_pos == wa {
                        self.watch_a[cidx] = new_pos;
                    } else {
                        self.watch_b[cidx] = new_pos;
                    }

                    // Remove cidx from current watch list by swap-remove.
                    let last = self.watches[widx].pop().expect("non-empty");
                    if i < self.watches[widx].len() {
                        self.watches[widx][i] = last;
                    }

                    let new_idx = Self::lit_index(new_lit);
                    self.watches[new_idx].push(cidx);
                    continue; // don't increment i; we replaced current entry
                }

                // No new watch found: clause is unit or conflict.
                // If other_lit is false => conflict. If unassigned => enqueue.
                match self.lit_value(other_lit) {
                    -1 => {
                        self.stats.conflicts += 1;
                        return Some(cidx);
                    }
                    0 => {
                        // Unit propagation: force other_lit true.
                        if !self.enqueue(other_lit) {
                            self.stats.conflicts += 1;
                            return Some(cidx);
                        }
                        i += 1;
                    }
                    1 => {
                        // satisfied (handled earlier, but keep it safe)
                        i += 1;
                    }
                    _ => i += 1,
                }
            }
        }
        None
    }

    /// Reset assignment state (keep clauses).
    fn reset_search_state(&mut self) {
        self.assigns.fill(0);
        self.trail.clear();
        self.trail_lim.clear();
        self.qhead = 0;
        self.has_model = false;
        self.stats = SatStats::default();
    }
}

impl SatSolver for ToyCdcl {
    fn reserve_vars(&mut self, num_vars: u32) {
        if num_vars <= self.num_vars {
            return;
        }
        self.num_vars = num_vars;

        // assignments
        self.assigns.resize(self.num_vars as usize, 0);

        // 2 literals per var
        self.watches.resize((self.num_vars as usize) * 2, Vec::new());
    }

    fn add_clause(&mut self, clause: Clause) {
        if self.inconsistent {
            return;
        }

        // Basic sanity:
        if clause.is_empty() {
            self.inconsistent = true;
            return;
        }

        // Ensure variables are reserved.
        let mut maxv = 0u32;
        for lit in clause.iter() {
            maxv = maxv.max(lit.var().as_u32() + 1);
        }
        self.reserve_vars(maxv);

        let cidx = self.clauses.len();
        self.clauses.push(clause);

        // Prepare watch slots
        self.watch_a.push(0);
        self.watch_b.push(0);

        // Init watches
        self.init_clause_watches(cidx);
    }

    fn solve(&mut self, assumptions: &[Lit]) -> SatResult {
        if self.inconsistent {
            return SatResult::Unsat;
        }

        // For a toy solver, we restart from scratch each call but keep clauses (incremental add_clause).
        self.reset_search_state();

        // Apply assumptions as decisions at level 0 (common convention: “assumption level”).
        // If you want assumptions to backtrack cleanly, you can put them at level 1, etc.
        for &a in assumptions {
            if !self.enqueue(a) {
                return SatResult::Unsat;
            }
        }
        if self.propagate().is_some() {
            return SatResult::Unsat;
        }

        loop {
            // If all variables assigned => SAT
            if self.pick_branch_lit().is_none() {
                self.has_model = true;
                return SatResult::Sat;
            }

            // Decision
            let decision = self.pick_branch_lit().expect("checked above");
            self.stats.decisions += 1;
            self.new_decision_level();

            if !self.enqueue(decision) {
                // Shouldn't happen for unassigned var; treat as conflict
                self.backtrack(0);
                return SatResult::Unsat;
            }

            // Propagate / handle conflicts
            while let Some(_conflict_clause) = self.propagate() {
                // -----------------------------------------------------------------
                // Learning hook (TODO):
                // - analyze conflict (1-UIP)
                // - add learned clause
                // - compute backjump level
                // - enqueue asserting literal
                // -----------------------------------------------------------------

                if self.decision_level() == 0 {
                    return SatResult::Unsat;
                }

                // Toy behavior: chronological backtracking by one level,
                // and flip the last decision (very naive).
                let last_level = self.decision_level() - 1;
                self.backtrack(last_level);

                // Flip last decision literal at that level, if possible.
                // We recover it from the trail boundary.
                let start = self.trail_lim.get(last_level).copied().unwrap_or(0);
                if start >= self.trail.len() {
                    // Nothing to flip; give up.
                    return SatResult::Unknown;
                }
                let decided = self.trail[start];
                // Backtrack to that level (already), then try opposite.
                self.backtrack(last_level);
                self.new_decision_level();
                if !self.enqueue(decided.not()) {
                    // Can't flip; keep backtracking.
                    self.backtrack(last_level);
                    if self.decision_level() == 0 {
                        return SatResult::Unsat;
                    }
                    continue;
                }
            }
        }
    }

    fn value_var(&self, var: Var) -> Option<bool> {
        if !self.has_model {
            return None;
        }
        match self.assigns.get(var.as_u32() as usize).copied().unwrap_or(0) {
            1 => Some(true),
            -1 => Some(false),
            _ => None, // should not happen in full model, but keep it safe
        }
    }

    fn stats(&self) -> SatStats {
        self.stats
    }
}
```

---

## 6) `crates/smt-engine` minimal usage pattern

Now `smt-engine` can accept *any* SAT solver:

### `crates/smt-engine/Cargo.toml`

```toml
[package]
name = "smt-engine"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"

[features]
default = ["std"]
std = ["smt-sat/std"]

[dependencies]
smt-sat = { path = "../smt-sat", default-features = false }
```

### Example engine-side call

```rust
use smt_sat::{SatResult, SatSolver};

pub fn solve_cnf<S: SatSolver>(sat: &mut S, cnf: &smt_sat::Cnf) -> SatResult {
    sat.reserve_vars(cnf.num_vars);
    for c in &cnf.clauses {
        sat.add_clause(c.clone());
    }
    sat.solve(&[])
}
```

---

## What you get immediately

* You can already:

  * Tseitin-encode from `smt-preprocess`
  * feed CNF to `ToyCdcl`
  * query a model for Booleans

* You can now evolve the toy solver into “real CDCL” by filling the **learning hook**:

  * reason tracking (per implied assignment)
  * 1-UIP analysis
  * non-chronological backjump
  * learned clause database + restarts

If you say “yes” again, I’ll show the **minimal reason tracking layout + 1-UIP conflict analysis skeleton** (still readable, with doc comments), and how to store `reason[var] = clause_idx` without blowing up ownership/borrowing.
