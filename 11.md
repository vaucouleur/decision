Here’s a clean, **Rust-friendly CDCL(T) integration** that keeps boundaries crisp:

* `smt-sat` exposes a *kernel* API (not just `solve()`): enqueue, propagate, backtrack, add clause, query partial assignment.
* `smt-engine` owns the CDCL(T) orchestration and calls theory solvers on assignments of *theory atoms*.
* Explanations are just clauses (SAT-lemmas), so you reuse the SAT solver’s existing machinery.

Below is a concrete skeleton that works well with your current `ToyCdcl` direction.

---

## 1) Upgrade the SAT API: from “black box solve” to “CDCL kernel”

Create a **new trait** (keep `SatSolver` if you want; CDCL(T) needs the kernel-level interface):

### `crates/smt-sat/src/kernel.rs`

```rust
//! CDCL kernel API needed by CDCL(T).
//!
//! This is intentionally *lower level* than `SatSolver::solve()`:
//! the SMT engine drives the loop and interleaves theory propagation.

use crate::{Clause, Lit, SatStats, Var};

/// Partial assignment value for a literal/var during search.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LBool {
    /// Assigned true.
    True,
    /// Assigned false.
    False,
    /// Unassigned.
    Undef,
}

/// Conflict returned by propagation.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Conflict {
    /// Index of the clause that is falsified under the current assignment.
    pub clause: usize,
}

/// A CDCL kernel that can be driven by an SMT engine (CDCL(T)).
pub trait SatKernel {
    /// Ensure internal arrays are sized for `num_vars` vars.
    fn reserve_vars(&mut self, num_vars: u32);

    /// Add a clause permanently (original CNF, learned clause, theory lemma).
    fn add_clause(&mut self, clause: Clause);

    /// Create a new decision level.
    fn new_decision_level(&mut self);

    /// Backtrack to `level` (0..=current).
    fn backtrack(&mut self, level: usize);

    /// Current decision level.
    fn decision_level(&self) -> usize;

    /// Enqueue an assignment, with an optional reason clause index.
    ///
    /// - `reason=None` for decisions / assumptions
    /// - `reason=Some(cidx)` for implied assignments
    ///
    /// Returns `false` if this immediately contradicts the current assignment.
    fn enqueue(&mut self, lit: Lit, reason: Option<usize>) -> bool;

    /// Propagate until fixpoint or conflict.
    fn propagate(&mut self) -> Result<(), Conflict>;

    /// Value of a variable under the *current partial* assignment.
    fn value_var(&self, var: Var) -> LBool;

    /// Value of a literal under the *current partial* assignment.
    fn value_lit(&self, lit: Lit) -> LBool;

    /// Trail since the start (or you can expose a slice view).
    fn trail(&self) -> &[Lit];

    /// Stats snapshot.
    fn stats(&self) -> SatStats;
}
```

**Implementation note:** your `ToyCdcl` already has `enqueue_with_reason`, `new_decision_level`, `backtrack`, `propagate`, `decision_level`, `trail`. Expose them to implement `SatKernel`.

---

## 2) The core CDCL(T) idea: theories talk to SAT via clauses

A *theory propagation* “explaining `p` from antecedents `a,b,c`” becomes the SAT clause:

* `(!a ∨ !b ∨ !c ∨ p)`

A *theory conflict* explained by antecedents `a,b,c` becomes:

* `(!a ∨ !b ∨ !c)` (no `p`)

That’s it. This keeps theory ↔ SAT glue extremely clean.

We’ll wrap that into an “engine context” API.

---

## 3) Atom table: map SAT vars ↔ theory atoms (TermId)

You want to call theories only on assignments of **theory atoms** (e.g., `x < y`, `x = y`, `bvadd(...) = ...`), not on pure boolean structure.

### `crates/smt-engine/src/atoms.rs`

```rust
use hashbrown::HashMap;
use rustc_hash::FxHasher;
use core::hash::BuildHasherDefault;

use smt_core::TermId;
use smt_sat::Var;

type FxBuild = BuildHasherDefault<FxHasher>;

/// A theory atom known to be represented by a SAT variable.
#[derive(Debug, Clone, Copy)]
pub struct Atom {
    /// The SMT term of sort Bool that represents the atom (e.g. (= x y)).
    pub term: TermId,
    /// Which theory owns it (UF, LIA, BV, ...).
    pub theory: TheoryId,
}

/// Index into the engine’s theory list.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct TheoryId(pub usize);

/// Maps SAT variables to atoms (only for theory atoms; boolean structure vars may be absent).
#[derive(Default)]
pub struct AtomTable {
    var_to_atom: HashMap<Var, Atom, FxBuild>,
}

impl AtomTable {
    pub fn insert(&mut self, var: Var, atom: Atom) {
        self.var_to_atom.insert(var, atom);
    }

    pub fn get(&self, var: Var) -> Option<Atom> {
        self.var_to_atom.get(&var).copied()
    }
}
```

How do you populate this? In your “propositionalization / Tseitin” phase:

* you already map `TermId -> Var`
* when you encounter a `Bool` term that is a **theory predicate** (e.g. `Eq` where args are non-bool, or `Lt/Le` over Int), register it in `AtomTable` with the owning theory.

---

## 4) Theory interface for CDCL(T)

### `crates/smt-engine/src/theory.rs`

```rust
use smt_core::TermId;
use smt_sat::Lit;

/// A theory propagation: implied literal with an explanation.
#[derive(Debug, Clone)]
pub struct TheoryPropagation {
    /// The implied literal (SAT-level) that must hold.
    pub implied: Lit,
    /// Explanation as a set of currently-true literals.
    ///
    /// Semantics: (¬e1 ∨ ¬e2 ∨ ... ∨ implied)
    pub explain: Vec<Lit>,
}

/// A theory conflict with an explanation (all literals are assumed true currently).
#[derive(Debug, Clone)]
pub struct TheoryConflict {
    /// Explanation: (¬e1 ∨ ¬e2 ∨ ...)
    pub explain: Vec<Lit>,
}

/// Minimal theory API for CDCL(T).
///
/// The engine:
/// - notifies theories about assignments of atoms they own
/// - asks theories for propagations and conflicts
pub trait Theory {
    fn name(&self) -> &'static str;

    fn push(&mut self);
    fn pop(&mut self, n: usize);

    /// Notify the theory that its atom was assigned.
    ///
    /// - `atom_term` is the Bool term representing the theory predicate.
    /// - `value` is the SAT-level truth value for that atom.
    fn on_atom_assigned(&mut self, atom_term: TermId, value: bool);

    /// Ask the theory to produce propagations (and/or detect conflicts).
    ///
    /// Return:
    /// - `Ok(vec)` for propagations
    /// - `Err(conflict)` if inconsistent
    fn propagate(&mut self) -> Result<Vec<TheoryPropagation>, TheoryConflict>;
}
```

This is intentionally small. You can add `model_value()`, `check_final()`, etc. later.

---

## 5) Engine context: turn theory explanations into SAT clauses

### `crates/smt-engine/src/engine_ctx.rs`

```rust
use smt_sat::{Clause, Lit};

/// Build a clause representing `explain => implied`.
///
/// If `explain = [a,b,c]` and `implied = p`,
/// produces: (¬a ∨ ¬b ∨ ¬c ∨ p)
pub fn implication_clause(explain: &[Lit], implied: Lit) -> Clause {
    let mut c = Vec::with_capacity(explain.len() + 1);
    for &e in explain {
        c.push(e.not());
    }
    c.push(implied);
    c
}

/// Build a clause representing a theory conflict explanation.
///
/// If `explain = [a,b,c]`, produces: (¬a ∨ ¬b ∨ ¬c)
pub fn conflict_clause(explain: &[Lit]) -> Clause {
    let mut c = Vec::with_capacity(explain.len());
    for &e in explain {
        c.push(e.not());
    }
    c
}
```

---

## 6) The CDCL(T) loop in the engine

Key points:

* Drive SAT decisions/propagation.
* After each SAT propagation fixpoint, run theory propagation fixpoint:

  * theory may add lemmas and implied literals (with explanations)
  * those become clauses + enqueues in SAT
* If theory emits conflict: add conflict clause; SAT will conflict and learn/backjump.

### `crates/smt-engine/src/lib.rs`

```rust
//! `smt-engine` — CDCL(T) orchestration.

#![forbid(unsafe_code)]
#![warn(missing_docs)]

mod atoms;
mod engine_ctx;
mod theory;

pub use atoms::{Atom, AtomTable, TheoryId};
pub use theory::{Theory, TheoryConflict, TheoryPropagation};

use smt_sat::{Lit, SatStats};
use smt_sat::kernel::{LBool, SatKernel};

use crate::engine_ctx::{conflict_clause, implication_clause};

/// CDCL(T) engine.
///
/// `K` is a SAT kernel driven by the engine.
/// Theories are hosted as trait objects.
pub struct CdcltEngine<K: SatKernel> {
    sat: K,
    atoms: AtomTable,
    theories: Vec<Box<dyn Theory>>,

    /// Used to avoid re-notifying theories for trail prefix.
    notified_trail_len: usize,
}

impl<K: SatKernel> CdcltEngine<K> {
    /// Create a new engine from a SAT kernel, theories, and an atom table.
    pub fn new(sat: K, theories: Vec<Box<dyn Theory>>, atoms: AtomTable) -> Self {
        Self {
            sat,
            atoms,
            theories,
            notified_trail_len: 0,
        }
    }

    /// Add a CNF clause to SAT (e.g., from Tseitin).
    pub fn add_clause(&mut self, c: smt_sat::Clause) {
        self.sat.add_clause(c);
    }

    /// Solve under optional assumptions (SAT literals).
    ///
    /// This is a *minimal* CDCL(T) loop skeleton. A production engine will integrate:
    /// - assumptions with UNSAT cores
    /// - theory combination (Nelson–Oppen / sharing)
    /// - incremental push/pop coordinated with SAT levels
    pub fn solve(&mut self, assumptions: &[Lit]) -> SolveResult {
        // Seed assumptions as decisions at a new level (common pattern).
        if !assumptions.is_empty() {
            self.sat.new_decision_level();
            for &a in assumptions {
                if !self.sat.enqueue(a, None) {
                    return SolveResult::Unsat;
                }
            }
        }

        loop {
            // SAT propagate
            if self.sat.propagate().is_err() {
                // SAT-level conflict handling (learning/backjump) lives in the SAT kernel
                // if you embed full CDCL there. If SAT kernel is “dumb”, engine must do it.
                //
                // In your design, put CDCL learning in SAT kernel, so by the time
                // propagate() returns Err, the kernel can internally resolve it or expose
                // a conflict analysis API. For brevity, we assume kernel handles it.
                return SolveResult::Unsat;
            }

            // Notify theories about newly assigned atoms, then run theory propagation fixpoint.
            if let Err(_) = self.theory_fixpoint() {
                // A theory conflict was translated into a SAT clause; SAT will now conflict.
                // In a full integration, you would continue the loop and let SAT learn/backjump.
                return SolveResult::Unsat;
            }

            // If SAT has a complete assignment, we’re SAT (and theories are consistent by fixpoint).
            if self.is_complete_assignment() {
                return SolveResult::Sat;
            }

            // Make a SAT decision.
            // If the kernel owns full CDCL, you can expose a `decide()` method instead.
            let next = self.pick_unassigned_decision();
            if let Some(lit) = next {
                self.sat.new_decision_level();
                if !self.sat.enqueue(lit, None) {
                    return SolveResult::Unsat;
                }
            } else {
                return SolveResult::Sat;
            }
        }
    }

    /// Theory propagation fixpoint:
    /// - notify theories about new trail literals
    /// - pull theory propagations/conflicts
    /// - translate to SAT clauses + enqueue implied
    fn theory_fixpoint(&mut self) -> Result<(), ()> {
        // 1) Notify theories for new assignments since last time.
        let trail = self.sat.trail();
        for &lit in &trail[self.notified_trail_len..] {
            // If this SAT var corresponds to a theory atom, notify its owning theory.
            if let Some(atom) = self.atoms.get(lit.var()) {
                let value = match self.sat.value_lit(lit) {
                    LBool::True => true,
                    LBool::False => false,
                    LBool::Undef => continue,
                };
                self.theories[atom.theory.0].on_atom_assigned(atom.term, value);
            }
        }
        self.notified_trail_len = trail.len();

        // 2) Pull propagations until fixpoint.
        loop {
            let mut any = false;

            for th in self.theories.iter_mut() {
                match th.propagate() {
                    Ok(props) => {
                        for p in props {
                            any = true;
                            // Add lemma clause for explanation => implied
                            let clause = implication_clause(&p.explain, p.implied);
                            self.sat.add_clause(clause);

                            // Enqueue implied with the reason clause index if your kernel supports it.
                            // If not, it’s still OK: adding the clause and calling sat.propagate()
                            // will typically force it.
                            //
                            // For best performance, expose `add_clause_return_index()` on the kernel.
                            let _ = self.sat.enqueue(p.implied, None);
                        }
                    }
                    Err(conf) => {
                        // Add conflict clause and signal “theory conflict happened”.
                        let clause = conflict_clause(&conf.explain);
                        self.sat.add_clause(clause);
                        return Err(());
                    }
                }
            }

            if !any {
                break;
            }

            // Let SAT absorb newly added clauses and implied enqueues.
            if self.sat.propagate().is_err() {
                return Err(());
            }
        }

        Ok(())
    }

    fn is_complete_assignment(&self) -> bool {
        // Minimal check: if every var in SAT is assigned.
        // A nicer kernel API would expose `is_fully_assigned()`.
        //
        // Here, we use trail length heuristically (not perfect if duplicates are possible).
        false
    }

    fn pick_unassigned_decision(&self) -> Option<Lit> {
        // If your SAT kernel owns decisions (VSIDS/phase), expose that instead.
        None
    }

    pub fn stats(&self) -> SatStats {
        self.sat.stats()
    }
}

/// SMT-level result (SAT/UNSAT for now).
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SolveResult {
    Sat,
    Unsat,
}
```

Two **practical tweaks** you’ll want in a real implementation:

1. `SatKernel::add_clause()` should return the **clause index**, so you can enqueue implied literals with `reason=Some(cidx)` (exactly like learned clauses). That avoids waiting for propagation to rediscover it.
2. `SatKernel` should expose **decision picking** (or the engine should call a `decide()` method), otherwise you duplicate heuristics.

---

## 7) Activation literals (backtrackable theory lemmas)

When theories emit lemmas that should only be active “in this scope” (or you want to disable them when popping), use an **activation literal** `act`:

* Add clause: `(¬act ∨ lemma)`
* During the current solve call, assume `act` is **true**.
* When scope ends, you simply stop assuming `act` true. The lemma stays but becomes inactive.

Helper:

```rust
/// Convert a lemma clause `L` into an activation-guarded lemma:
/// (¬act ∨ L)
pub fn guarded_lemma(act: smt_sat::Lit, lemma: &smt_sat::Clause) -> smt_sat::Clause {
    let mut c = Vec::with_capacity(lemma.len() + 1);
    c.push(act.not());
    c.extend_from_slice(lemma);
    c
}
```

This plays extremely nicely with incremental SMT (`push/pop`) and with “temporary” theory reasoning.

---

## 8) The minimal set of things you need to add to `ToyCdcl` for CDCL(T)

To make this seamless, modify your SAT kernel to support:

* `add_clause_return_index(&mut self, clause) -> usize`
* `enqueue(lit, Some(reason_clause_index))`
* `value_lit(lit)` under partial assignment
* `trail()` slice
* `new_decision_level/backtrack`

You already have nearly all of that.

---

If you want the next piece, say **yes** and I’ll show:

* a **propositionalizer** that separates *Boolean structure* from *theory atoms* (so theories only see atoms), and
* an example `UFTheory` that propagates equalities via congruence closure and returns **explanations as SAT literals**.
