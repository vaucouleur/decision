Below is that **second DOT view**: an **equality-sharing graph** dump.

It renders:

* **term nodes** (pretty-printed if you can)
* **equality edges** `a = b`
* edge labels: `UF→DL` / `DL→UF` + `epoch` + short reason summary (optional)
* optional: link each equality edge to its **ReasonId root** node (so you can jump from “eq exchange” to “reason DAG”)

This is extremely useful when you’re missing a hop.

---

# 1) A small “event recorder” for equality exchange

Record exchanges in the engine as events, then dump them.

### `crates/smt-engine/src/eqshare_trace.rs`

```rust
#![forbid(unsafe_code)]

use smt_core::TermId;
use crate::atoms::TheoryId;
use crate::reason::ReasonId;

#[derive(Debug, Clone)]
pub struct EqShareEvent {
    pub epoch: u64,
    pub src: TheoryId,
    pub dst: TheoryId,
    pub a: TermId,
    pub b: TermId,
    pub explain: ReasonId,
}

#[derive(Default)]
pub struct EqShareTrace {
    events: Vec<EqShareEvent>,
}

impl EqShareTrace {
    pub fn push(&mut self, ev: EqShareEvent) {
        self.events.push(ev);
    }

    pub fn clear(&mut self) {
        self.events.clear();
    }

    pub fn events(&self) -> &[EqShareEvent] {
        &self.events
    }
}
```

Add to engine:

```rust
pub eqshare_trace: EqShareTrace,
```

Init default.

Optionally clear per `check_sat()` call.

---

# 2) Record events in `equality_sharing_round()`

Right before calling `import_equality`, record:

```rust
if self.config.debug_eq.enabled {
    self.eqshare_trace.push(EqShareEvent {
        epoch: self.export_epoch,
        src,
        dst,
        a: eq.a,
        b: eq.b,
        explain: eq.explain,
    });
}
```

This records only actual imports (i.e., only those passing direction filters).

---

# 3) DOT exporter for the equality-sharing graph

### `crates/smt-engine/src/eqshare_dot.rs`

```rust
#![forbid(unsafe_code)]

use std::fmt::Write;

use hashbrown::{HashMap, HashSet};
use rustc_hash::FxHasher;
use core::hash::BuildHasherDefault;

use smt_core::{Context, TermId};
use crate::atoms::TheoryId;
use crate::reason::{ReasonArena, ReasonId};
use crate::eqshare_trace::EqShareEvent;

type FxBuild = BuildHasherDefault<FxHasher>;

#[derive(Debug, Clone, Copy)]
pub struct EqDotLimits {
    pub max_events: usize,
    pub max_reason_lits: usize,
    pub include_reason_nodes: bool, // show ReasonId as separate nodes
}

impl Default for EqDotLimits {
    fn default() -> Self {
        Self { max_events: 300, max_reason_lits: 6, include_reason_nodes: false }
    }
}

fn fmt_term(ctx: &Context, t: TermId) -> String {
    // Replace with a proper pretty printer if you have one.
    format!("{t:?}")
}

fn fmt_theory(name: &str) -> String {
    name.to_string()
}

fn fmt_lit_short(l: smt_sat::Lit) -> String {
    if l.is_pos() { format!("v{}", l.var().as_u32()) } else { format!("¬v{}", l.var().as_u32()) }
}

/// Dump a DOT graph of the equality-sharing exchanges.
pub fn eqshare_to_dot(
    ctx: &Context,
    reasons: &ReasonArena,
    events: &[EqShareEvent],
    theory_names: &dyn Fn(TheoryId) -> &'static str,
    limits: EqDotLimits,
) -> String {
    let mut out = String::new();
    writeln!(&mut out, "digraph EqShare {{").ok();
    writeln!(&mut out, "  rankdir=LR;").ok();
    writeln!(&mut out, "  node [fontname=\"Helvetica\"];").ok();

    // Map terms to node ids t0, t1, ...
    let mut term_nodes: HashMap<TermId, String, FxBuild> = HashMap::default();
    let mut next_term = 0usize;

    let mut edge_seen: HashSet<(TheoryId, TheoryId, TermId, TermId, u64), FxBuild> = HashSet::default();

    let mut count = 0usize;
    for ev in events.iter().take(limits.max_events) {
        count += 1;
        let (p, q) = if ev.a < ev.b { (ev.a, ev.b) } else { (ev.b, ev.a) };

        // Dedup identical edge in same epoch
        if !edge_seen.insert((ev.src, ev.dst, p, q, ev.epoch)) {
            continue;
        }

        let na = term_nodes.entry(ev.a).or_insert_with(|| {
            let id = format!("t{next_term}");
            next_term += 1;
            id
        }).clone();

        let nb = term_nodes.entry(ev.b).or_insert_with(|| {
            let id = format!("t{next_term}");
            next_term += 1;
            id
        }).clone();

        let src_name = fmt_theory(theory_names(ev.src));
        let dst_name = fmt_theory(theory_names(ev.dst));

        // Reason summary (bounded)
        let lits = reasons.expand_lits(ev.explain);
        let mut rs = String::new();
        for (i, l) in lits.iter().take(limits.max_reason_lits).enumerate() {
            if i > 0 { rs.push_str(","); }
            rs.push_str(&fmt_lit_short(*l));
        }
        if lits.len() > limits.max_reason_lits {
            rs.push_str(",...");
        }

        let label = if rs.is_empty() {
            format!("{}→{} @{}", src_name, dst_name, ev.epoch)
        } else {
            format!("{}→{} @{}\\n{}", src_name, dst_name, ev.epoch, rs)
        };

        writeln!(
            &mut out,
            "  {na} -> {nb} [label=\"{label}\"];"
        ).ok();

        if limits.include_reason_nodes {
            let rn = format!("r{}", ev.explain.0);
            writeln!(
                &mut out,
                "  {rn} [shape=box,style=dashed,label=\"ReasonId({})\"];",
                ev.explain.0
            ).ok();
            writeln!(&mut out, "  {na} -> {rn} [style=dotted,arrowhead=none];").ok();
            writeln!(&mut out, "  {rn} -> {nb} [style=dotted,arrowhead=none];").ok();
        }
    }

    // Emit term nodes with labels
    for (t, nid) in &term_nodes {
        let lab = fmt_term(ctx, *t).replace('"', "\\\"");
        writeln!(&mut out, "  {nid} [shape=ellipse,label=\"{lab}\"];").ok();
    }

    if events.len() > limits.max_events {
        writeln!(
            &mut out,
            "  truncated [shape=note,label=\"TRUNCATED: events={} max_events={}\"];",
            events.len(),
            limits.max_events
        ).ok();
    }

    writeln!(&mut out, "}}").ok();
    out
}
```

---

# 4) Engine method to dump to file

### `crates/smt-engine/src/engine_debug.rs` (add)

```rust
impl<K: crate::sat_iface::SatKernel> crate::engine::SmtEngine<K> {
    pub fn dump_eqshare_dot(&self) -> String {
        crate::eqshare_dot::eqshare_to_dot(
            &self.ctx,
            &self.reasons,
            self.eqshare_trace.events(),
            &|tid| self.theories[tid.0].name(),
            crate::eqshare_dot::EqDotLimits {
                include_reason_nodes: false,
                ..Default::default()
            },
        )
    }
}
```

Write it on UNSAT (or always when debug enabled):

```rust
if self.config.debug_eq.enabled {
    let dot = self.dump_eqshare_dot();
    let path = format!("target/eqshare_epoch_{}.dot", self.export_epoch);
    let _ = std::fs::write(&path, dot.as_bytes());
    eprintln!("[eqshare] wrote {path}");
}
```

---

# 5) How to read it

For ping-pong, you should see edges like:

* `f(a) -> f(b)` labeled `UF→DL @epoch ... because vA_EQ_B`
* `x -> y` labeled `DL→UF @epoch ... because vX_LE_FA,vFA_LE_X,vY_LE_FB,vFB_LE_Y,...`
* optionally more edges depending on your export bucket rules

If one of those edges is missing, you instantly know which half is broken:

* shared-term oracle too weak (term nodes absent)
* UF export bucket not producing `f(a)=f(b)`
* DL export not producing `x=y`
* direction flags preventing import

---

# 6) Bonus: bridge to the conflict reason DAG

If you set `include_reason_nodes: true`, you get “ReasonId(…)” nodes in the eqshare graph.
Then separately dump the conflict reason DAG with `reason_to_dot()` for the conflict root.
You can match the `ReasonId` integers.

---

If you want, I can show the last ergonomic bit: a single debug function that, upon UNSAT, writes **both** `eqshare.dot` and `conflict.dot`, plus a tiny `README.txt` with the exact `dot -Tsvg` commands—so you can attach `target/*.dot` directly as CI artifacts.
