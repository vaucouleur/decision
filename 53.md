Hereâ€™s the overload so you can write the clean literal form:

```rust
assert_eqshare_hop_any!(&events, UF => DL, [
    (inst.fa, inst.fb),
    (inst.fa, inst.fa2),
]);
```

No heap allocation; it just takes a reference to a temporary array.

---

## Add these overload arms to `assert_eqshare_hop_any!`

Append **above** the existing slice-based arms (so the array form matches first):

```rust
#[macro_export]
macro_rules! assert_eqshare_hop_any {
    // Array literal overload (no need to write &[])
    ($events:expr, UF => DL, [ $(($a:expr, $b:expr)),+ $(,)? ] $(,)?) => {{
        let candidates = [ $(($a, $b)),+ ];
        $crate::assert_eqshare_hop_any!($events, UF => DL, &candidates);
    }};

    ($events:expr, DL => UF, [ $(($a:expr, $b:expr)),+ $(,)? ] $(,)?) => {{
        let candidates = [ $(($a, $b)),+ ];
        $crate::assert_eqshare_hop_any!($events, DL => UF, &candidates);
    }};

    // Slice form: &[(a,b), (c,d)]
    ($events:expr, UF => DL, $candidates:expr $(,)?) => {{
        let events = $events;
        let cands = $candidates;

        let ok = cands.iter().any(|(a, b)| {
            $crate::eqshare_macros::has_pair(
                events,
                $crate::eqshare_macros::UF,
                $crate::eqshare_macros::DL,
                *a,
                *b,
            )
        });

        if !ok {
            panic!(
                "missing eqshare hop UF=>DL for any candidate pair.\n\
                 candidates={:?}\n\
                 first events:\n{}",
                cands,
                $crate::eqshare_macros::dump(events)
            );
        }
    }};

    ($events:expr, DL => UF, $candidates:expr $(,)?) => {{
        let events = $events;
        let cands = $candidates;

        let ok = cands.iter().any(|(a, b)| {
            $crate::eqshare_macros::has_pair(
                events,
                $crate::eqshare_macros::DL,
                $crate::eqshare_macros::UF,
                *a,
                *b,
            )
        });

        if !ok {
            panic!(
                "missing eqshare hop DL=>UF for any candidate pair.\n\
                 candidates={:?}\n\
                 first events:\n{}",
                cands,
                $crate::eqshare_macros::dump(events)
            );
        }
    }};
}
```

---

## Example

```rust
use crate::{assert_eqshare_hop_any};

assert_eqshare_hop_any!(&events, UF => DL, [
    (inst.fa, inst.fb),
    (inst.fb, inst.fa), // redundant but harmless
]);

assert_eqshare_hop_any!(&events, DL => UF, [
    (inst.x, inst.y),
]);
```

---

If you want, I can also add a companion macro `assert_eqshare_hop_none!(events, UF => DL, [(a,b),...])` which is handy for the matrix rows that are supposed to stay SAT (no hop should occur).
