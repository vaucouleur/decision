Below is the **DlTheory patch** matching the new `ReasonArena` world:

* edges store `ReasonId` (not `Lit`)
* `propagate()` returns `TheoryPropagation { explain: ReasonId }`
* conflicts return `TheoryConflict { explain: ReasonId }`
* export/import equalities use `SharedEq { explain: ReasonId }`
* path & cycle reconstructions build explanations as `tcx.r_and(collected_reason_ids)`
* rollback works (edge undo records store `(from, count)`)

This is “toy but correct”, and now **UF↔DL equality sharing is fully sound**.

---

# `crates/smt-engine/src/theories/dl_theory_reasoned.rs`

```rust
#![forbid(unsafe_code)]
#![warn(missing_docs)]

//! Integer Difference Logic (IDL) theory with reason handles (ReasonId).
//!
//! Constraints are of form: x - y <= c over integers.
//! SAT atom assignment:
//!   atom = true  => add edge y -> x with weight c
//!   atom = false => add edge x -> y with weight -c-1  (negated strictness for integers)
//!
//! Conflict: negative cycle.
//! Propagation: closure implies an unassigned atom must be true or false.
//!
//! Explanations are returned as ReasonId handles allocated via TheoryCtx / ReasonArena.

use std::sync::Arc;

use hashbrown::{HashMap, HashSet};
use rustc_hash::FxHasher;
use core::hash::BuildHasherDefault;

use smt_core::{Context, TermId, TermKind, SortKind};
use smt_sat::{Lit, Var};

use crate::atoms::TheoryId;
use crate::reason::ReasonId;
use crate::theory::{Theory, TheoryConflict, TheoryPropagation, EqualitySharing, SharedEq};
use crate::theory_ctx::TheoryCtx;

type FxBuild = BuildHasherDefault<FxHasher>;

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
struct NodeId(u32);

#[derive(Debug, Clone)]
struct Edge {
    to: NodeId,
    w: i64,
    why: ReasonId,
}

#[derive(Debug, Clone)]
struct DlAtom {
    var: Var,
    x: TermId,
    y: TermId,
    c: i64,
    value: Option<bool>,
    propagated: Option<bool>,
}

#[derive(Clone, Copy, Debug)]
struct Pred {
    prev: NodeId,
    why: ReasonId, // last edge reason on the best path
}

#[derive(Debug, Clone)]
struct AtomUndo {
    term: TermId,
    prev_value: Option<bool>,
    prev_prop: Option<bool>,
}

pub struct DlTheory {
    ctx: Arc<Context>,
    id: TheoryId,

    // nodes
    term_to_node: HashMap<TermId, NodeId, FxBuild>,
    nodes: Vec<TermId>,

    // asserted/derived edges
    adj: Vec<Vec<Edge>>,
    edge_undo: Vec<(NodeId, usize)>,

    // dl atoms: bool-term -> atom
    atoms: HashMap<TermId, DlAtom, FxBuild>,

    // rollback stacks
    atom_undo: Vec<AtomUndo>,
    scope_cp: Vec<(usize, usize)>, // (atom_undo_len, edge_undo_len)
    level_cp: Vec<(usize, usize)>, // (atom_undo_len, edge_undo_len)
}

impl DlTheory {
    pub fn new(ctx: Arc<Context>, id: TheoryId) -> Self {
        Self {
            ctx,
            id,
            term_to_node: HashMap::default(),
            nodes: Vec::new(),
            adj: Vec::new(),
            edge_undo: Vec::new(),
            atoms: HashMap::default(),
            atom_undo: Vec::new(),
            scope_cp: vec![(0, 0)],
            level_cp: vec![(0, 0)],
        }
    }

    pub fn register_dl_atom(&mut self, atom_term: TermId, var: Var) -> smt_core::Result<()> {
        let Some((x, y, c)) = normalize_dl_atom(&self.ctx, atom_term)? else {
            return Ok(());
        };

        self.node(x);
        self.node(y);

        self.atoms.insert(atom_term, DlAtom {
            var, x, y, c, value: None, propagated: None,
        });

        Ok(())
    }

    fn node(&mut self, t: TermId) -> NodeId {
        if let Some(&n) = self.term_to_node.get(&t) {
            return n;
        }
        let id = NodeId(self.nodes.len() as u32);
        self.term_to_node.insert(t, id);
        self.nodes.push(t);
        self.adj.push(Vec::new());
        id
    }

    fn add_edge(&mut self, from: TermId, to: TermId, w: i64, why: ReasonId) {
        let f = self.node(from);
        let t = self.node(to);
        self.adj[f.0 as usize].push(Edge { to: t, w, why });
        self.edge_undo.push((f, 1));
    }

    fn checkpoint(&mut self, stack: &mut Vec<(usize, usize)>) {
        stack.push((self.atom_undo.len(), self.edge_undo.len()));
    }

    fn rollback(&mut self, stack: &mut Vec<(usize, usize)>, n: usize) {
        for _ in 0..n {
            if stack.len() <= 1 { return; }
            let (au, eu) = stack.pop().unwrap();

            while self.edge_undo.len() > eu {
                let (from, k) = self.edge_undo.pop().unwrap();
                let list = &mut self.adj[from.0 as usize];
                for _ in 0..k {
                    list.pop();
                }
            }

            while self.atom_undo.len() > au {
                let u = self.atom_undo.pop().unwrap();
                if let Some(a) = self.atoms.get_mut(&u.term) {
                    a.value = u.prev_value;
                    a.propagated = u.prev_prop;
                }
            }
        }
    }

    /// Floyd–Warshall closure + predecessors + optional negative-cycle explanation.
    fn all_pairs_shortest_paths(
        &self,
        tcx: &mut TheoryCtx,
    ) -> (
        Vec<Vec<Option<i64>>>,
        Vec<Vec<Option<Pred>>>,
        Option<ReasonId>,
    ) {
        let n = self.nodes.len();
        let mut dist = vec![vec![None; n]; n];
        let mut pred = vec![vec![None; n]; n];

        for i in 0..n {
            dist[i][i] = Some(0);
        }

        // init
        for (i, edges) in self.adj.iter().enumerate() {
            for e in edges {
                let j = e.to.0 as usize;
                if dist[i][j].map_or(true, |cur| e.w < cur) {
                    dist[i][j] = Some(e.w);
                    pred[i][j] = Some(Pred { prev: NodeId(i as u32), why: e.why });
                }
            }
        }

        // Floyd–Warshall
        for k in 0..n {
            for i in 0..n {
                let dik = dist[i][k];
                if dik.is_none() { continue; }
                let dik = dik.unwrap();

                for j in 0..n {
                    let dkj = dist[k][j];
                    if dkj.is_none() { continue; }
                    let cand = dik + dkj.unwrap();

                    if dist[i][j].map_or(true, |cur| cand < cur) {
                        dist[i][j] = Some(cand);
                        pred[i][j] = pred[k][j]; // predecessor for k->j part
                    }
                }
            }
        }

        // negative cycle
        for v in 0..n {
            if let Some(d) = dist[v][v] {
                if d < 0 {
                    let start = NodeId(v as u32);
                    let r = self.reconstruct_cycle_reason(&pred, start, tcx);
                    return (dist, pred, Some(r));
                }
            }
        }

        (dist, pred, None)
    }

    fn reconstruct_path_reason(
        &self,
        pred: &[Vec<Option<Pred>>],
        from: NodeId,
        to: NodeId,
        tcx: &mut TheoryCtx,
    ) -> ReasonId {
        let n = self.nodes.len();
        let i = from.0 as usize;
        let mut j = to.0 as usize;

        let mut kids = Vec::new();
        let mut seen: HashSet<ReasonId, FxBuild> = HashSet::default();

        let mut safety = 0;
        while j != i {
            safety += 1;
            if safety > n + 5 { break; }

            let Some(p) = pred[i][j] else { break; };

            if seen.insert(p.why) {
                kids.push(p.why);
            }
            j = p.prev.0 as usize;
        }

        tcx.r_and(kids)
    }

    fn reconstruct_cycle_reason(
        &self,
        pred: &[Vec<Option<Pred>>],
        start: NodeId,
        tcx: &mut TheoryCtx,
    ) -> ReasonId {
        let n = self.nodes.len();
        let s = start.0 as usize;

        // Enter cycle: follow predecessor chain n times
        let mut cur = s;
        for _ in 0..n {
            if let Some(p) = pred[s][cur] {
                cur = p.prev.0 as usize;
            } else {
                return tcx.r_and(Vec::new());
            }
        }

        let mut visited = vec![false; n];
        let mut kids = Vec::new();
        let mut seen: HashSet<ReasonId, FxBuild> = HashSet::default();

        let mut v = cur;
        while !visited[v] {
            visited[v] = true;
            let Some(p) = pred[s][v] else { break; };
            if seen.insert(p.why) {
                kids.push(p.why);
            }
            v = p.prev.0 as usize;
        }

        tcx.r_and(kids)
    }

    fn implies_true(dist: &[Vec<Option<i64>>], x: NodeId, y: NodeId, c: i64) -> bool {
        // x - y <= c  <=>  dist[y][x] <= c
        dist[y.0 as usize][x.0 as usize].map_or(false, |d| d <= c)
    }

    fn implies_false(dist: &[Vec<Option<i64>>], x: NodeId, y: NodeId, c: i64) -> bool {
        // ¬(x - y <= c) <=> x - y >= c+1 <=> y - x <= -(c+1)  <=> dist[x][y] <= -c-1
        dist[x.0 as usize][y.0 as usize].map_or(false, |d| d <= -c - 1)
    }
}

impl Theory for DlTheory {
    fn name(&self) -> &'static str { "DL" }

    fn push_scope(&mut self) { self.checkpoint(&mut self.scope_cp); }
    fn pop_scope(&mut self, n: usize) { self.rollback(&mut self.scope_cp, n); }

    fn push_level(&mut self) { self.checkpoint(&mut self.level_cp); }
    fn pop_levels(&mut self, n: usize) { self.rollback(&mut self.level_cp, n); }

    fn on_atom_assigned(&mut self, atom_term: TermId, value: bool, tcx: &mut TheoryCtx) {
        let Some(a) = self.atoms.get_mut(&atom_term) else { return; };
        if a.value == Some(value) { return; }

        self.atom_undo.push(AtomUndo {
            term: atom_term,
            prev_value: a.value,
            prev_prop: a.propagated,
        });

        a.value = Some(value);
        a.propagated = None;

        if value {
            // x - y <= c  => y -> x weight c
            let why = tcx.r_atom(Lit::pos(a.var));
            self.add_edge(a.y, a.x, a.c, why);
        } else {
            // x - y >= c+1 => x -> y weight -c-1
            let why = tcx.r_atom(Lit::neg(a.var));
            self.add_edge(a.x, a.y, -a.c - 1, why);
        }
    }

    fn propagate(&mut self, tcx: &mut TheoryCtx) -> Result<Vec<TheoryPropagation>, TheoryConflict> {
        let (dist, pred, neg) = self.all_pairs_shortest_paths(tcx);

        if let Some(r) = neg {
            // If r expands to empty, engine will emit an empty conflict clause (bad).
            // Ensure a non-empty fallback if needed.
            // Pragmatic: AND(all assigned atom reasons).
            let mut lits = Vec::new();
            for a in self.atoms.values() {
                if let Some(v) = a.value {
                    lits.push(if v { Lit::pos(a.var) } else { Lit::neg(a.var) });
                }
            }
            let rid = if lits.is_empty() {
                r
            } else {
                let kids: Vec<_> = lits.into_iter().map(|l| tcx.r_atom(l)).collect();
                tcx.r_and(kids)
            };
            return Err(TheoryConflict { explain: rid });
        }

        let mut props = Vec::new();

        for (_t, a) in self.atoms.iter_mut() {
            if a.value.is_some() { continue; }

            let x = self.node(a.x);
            let y = self.node(a.y);

            if Self::implies_true(&dist, x, y, a.c) && a.propagated != Some(true) {
                a.propagated = Some(true);
                let explain = self.reconstruct_path_reason(&pred, y, x, tcx);
                props.push(TheoryPropagation { implied: Lit::pos(a.var), explain });
                continue;
            }

            if Self::implies_false(&dist, x, y, a.c) && a.propagated != Some(false) {
                a.propagated = Some(false);
                let explain = self.reconstruct_path_reason(&pred, x, y, tcx);
                props.push(TheoryPropagation { implied: Lit::neg(a.var), explain });
            }
        }

        Ok(props)
    }

    fn equality_sharing_mut(&mut self) -> Option<&mut dyn EqualitySharing> { Some(self) }

    fn atom_endpoints(&self, atom_term: TermId) -> Vec<TermId> {
        self.atoms.get(&atom_term).map(|a| vec![a.x, a.y]).unwrap_or_default()
    }
}

impl EqualitySharing for DlTheory {
    fn export_equalities(
        &mut self,
        shared: &hashbrown::HashSet<TermId, FxBuild>,
        tcx: &mut TheoryCtx,
    ) -> Vec<SharedEq> {
        let (dist, pred, neg) = self.all_pairs_shortest_paths(tcx);
        if neg.is_some() {
            return Vec::new();
        }

        // Collect shared nodes in this theory
        let shared_terms: Vec<TermId> = self.nodes.iter().copied().filter(|t| shared.contains(t)).collect();

        let mut out = Vec::new();

        for i in 0..shared_terms.len() {
            for j in (i + 1)..shared_terms.len() {
                let a = shared_terms[i];
                let b = shared_terms[j];

                let na = self.node(a);
                let nb = self.node(b);

                let ab = dist[na.0 as usize][nb.0 as usize];
                let ba = dist[nb.0 as usize][na.0 as usize];

                if ab.map_or(false, |d| d <= 0) && ba.map_or(false, |d| d <= 0) {
                    let r1 = self.reconstruct_path_reason(&pred, na, nb, tcx);
                    let r2 = self.reconstruct_path_reason(&pred, nb, na, tcx);
                    let explain = tcx.r_and(vec![r1, r2]);
                    out.push(SharedEq { a, b, explain });
                }
            }
        }

        out
    }

    fn import_equality(&mut self, eq: SharedEq, _tcx: &mut TheoryCtx) {
        // Import a=b as two 0-weight edges with the SAME reason handle.
        self.add_edge(eq.b, eq.a, 0, eq.explain);
        self.add_edge(eq.a, eq.b, 0, eq.explain);
    }
}

/// Normalize Bool term into x - y <= c. Returns None if not a DL atom.
///
/// You need these in smt-core:
/// - bool_sort, int sort kind
/// - OpKind::{Le, Lt, Add}
/// - TermKind::ConstInt
/// - ctx.int_zero() (or create a stable 0 term)
fn normalize_dl_atom(ctx: &Context, atom_term: TermId) -> smt_core::Result<Option<(TermId, TermId, i64)>> {
    let (k, s) = ctx.term_node(atom_term);
    if s != ctx.bool_sort() { return Ok(None); }

    let TermKind::App { op, args } = k else { return Ok(None); };

    match op.kind {
        smt_core::OpKind::Le | smt_core::OpKind::Lt => {
            if args.len() != 2 { return Ok(None); }
            let lhs = args[0];
            let rhs = args[1];

            if ctx.sort_kind(ctx.term_sort(lhs)) != SortKind::Int { return Ok(None); }
            if ctx.sort_kind(ctx.term_sort(rhs)) != SortKind::Int { return Ok(None); }

            let (x, y, mut c) = parse_x_le_y_plus_c(ctx, lhs, rhs)?;
            if matches!(op.kind, smt_core::OpKind::Lt) {
                c -= 1;
            }
            Ok(Some((x, y, c)))
        }
        _ => Ok(None),
    }
}

fn parse_x_le_y_plus_c(ctx: &Context, lhs: TermId, rhs: TermId) -> smt_core::Result<(TermId, TermId, i64)> {
    let (rk, _) = ctx.term_node(rhs);

    match rk {
        TermKind::ConstInt(k) => Ok((lhs, ctx.int_zero(), *k)),
        TermKind::Var { .. } => Ok((lhs, rhs, 0)),
        TermKind::App { op, args } if matches!(op.kind, smt_core::OpKind::Add) && args.len() == 2 => {
            let a0 = args[0];
            let a1 = args[1];
            let (k0, _) = ctx.term_node(a0);
            let (k1, _) = ctx.term_node(a1);

            match (k0, k1) {
                (TermKind::ConstInt(k), _) => Ok((lhs, a1, *k)),
                (_, TermKind::ConstInt(k)) => Ok((lhs, a0, *k)),
                _ => Err(smt_core::Error::SortError("DL expects rhs as y + const".into())),
            }
        }
        _ => Err(smt_core::Error::SortError("DL expects rhs as y + const".into())),
    }
}
```

---

## Two small notes you’ll thank yourself for later

### A) Don’t allocate empty reasons

In a real system, `ReasonArena::and(vec![])` should still be ok, but for conflicts it’s useless. You can add:

* `Reason::True` as identity, and then ensure conflict reason is never True.
  Or keep the fallback I added (AND of assigned atom literals).

### B) Performance

Floyd–Warshall every `propagate()` is O(n³). Fine for architecture work. Later you can replace it with incremental Bellman–Ford / potentials.

---

## What you have now

* Uniform explanation objects (`ReasonId`) across UF and DL.
* Fully sound equality exchange, with real justifications.
* Engine only expands reasons when emitting SAT clauses.

If you say **yes** one last time, I’ll show a tiny end-to-end demo formula that *requires* UF↔DL equality sharing to become UNSAT (so you can regression-test the combination path), and how to wire the classifier so int-valued UF applications participate correctly.
