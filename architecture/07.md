Below is a minimal, clean **SAT-facing boolean layer** + a **Tseitin CNF encoder** (good enough to bootstrap CDCL(T)). I’ll structure it exactly how I’d do it in your repo:

* `crates/smt-sat` defines `Var`, `Lit`, `Clause`, `Cnf`
* `crates/smt-preprocess` defines a `TseitinEncoder` that takes `&mut Context` and a `BoolTerm` root, and outputs a CNF plus a mapping `TermId -> Var`

This keeps boundaries crisp: `smt-core` knows nothing about SAT.

---

# A) `crates/smt-sat/src/lib.rs`

```rust
//! `smt-sat` — basic SAT-facing types used by the engine and encoders.
//!
//! This crate intentionally does **not** implement a full CDCL solver yet.
//! It provides:
//! - `Var`, `Lit`
//! - `Clause`, `Cnf`
//! - small helpers for building CNF

#![forbid(unsafe_code)]
#![warn(missing_docs)]

use core::fmt;

/// SAT variable (1-based or 0-based is a policy choice; we use 0-based here).
#[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct Var(u32);

impl Var {
    /// Create a new variable from a raw index.
    #[inline]
    pub const fn from_u32(v: u32) -> Self {
        Self(v)
    }

    /// Get raw variable index.
    #[inline]
    pub const fn as_u32(self) -> u32 {
        self.0
    }
}

impl fmt::Debug for Var {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "v{}", self.0)
    }
}

/// A SAT literal (var with polarity).
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Lit {
    var: Var,
    neg: bool,
}

impl Lit {
    /// Positive literal (v).
    #[inline]
    pub const fn pos(var: Var) -> Self {
        Self { var, neg: false }
    }

    /// Negative literal (¬v).
    #[inline]
    pub const fn neg(var: Var) -> Self {
        Self { var, neg: true }
    }

    /// Underlying variable.
    #[inline]
    pub const fn var(self) -> Var {
        self.var
    }

    /// True if this is a negated literal.
    #[inline]
    pub const fn is_neg(self) -> bool {
        self.neg
    }

    /// Negate literal.
    #[inline]
    pub const fn not(self) -> Self {
        Self {
            var: self.var,
            neg: !self.neg,
        }
    }
}

impl fmt::Debug for Lit {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if self.neg {
            write!(f, "¬{:?}", self.var)
        } else {
            write!(f, "{:?}", self.var)
        }
    }
}

/// A CNF clause: disjunction of literals.
pub type Clause = Vec<Lit>;

/// A CNF formula: conjunction of clauses.
#[derive(Debug, Default, Clone)]
pub struct Cnf {
    /// Total number of variables used.
    pub num_vars: u32,
    /// Clauses (each is a Vec of literals).
    pub clauses: Vec<Clause>,
}

impl Cnf {
    /// Create empty CNF.
    pub fn new() -> Self {
        Self::default()
    }

    /// Allocate a fresh SAT variable.
    pub fn fresh_var(&mut self) -> Var {
        let v = Var::from_u32(self.num_vars);
        self.num_vars += 1;
        v
    }

    /// Add a clause.
    pub fn add_clause(&mut self, clause: Clause) {
        self.clauses.push(clause);
    }

    /// Add a unit clause (single literal).
    pub fn add_unit(&mut self, lit: Lit) {
        self.add_clause(vec![lit]);
    }
}
```

---

# B) `crates/smt-preprocess/src/lib.rs`

```rust
//! `smt-preprocess` — preprocessing passes and encoders (CNF, rewriting, etc).

#![forbid(unsafe_code)]
#![warn(missing_docs)]

mod tseitin;

pub use crate::tseitin::{TseitinEncoder, TseitinOutput};
```

---

# C) `crates/smt-preprocess/src/tseitin.rs` (Tseitin CNF encoder)

This encoder supports a minimal Boolean fragment:

* `true/false`, variables
* `(not a)`, `(and ...)`, `(or ...)`
* optionally you can add `xor`, `ite`, `=>` later

It introduces an aux SAT variable for each Boolean subterm, and emits equivalence clauses.

```rust
use hashbrown::HashMap;
use rustc_hash::FxHasher;
use core::hash::BuildHasherDefault;

use smt_core::{BoolTerm, Context};
use smt_sat::{Cnf, Lit, Var};

type FxBuildHasher = BuildHasherDefault<FxHasher>;

/// Result of Tseitin encoding.
#[derive(Debug)]
pub struct TseitinOutput {
    /// Produced CNF.
    pub cnf: Cnf,
    /// Root literal that must be asserted true to enforce the original formula.
    pub root: Lit,
    /// Mapping from `TermId` (Bool terms) to SAT variables.
    pub term_to_var: HashMap<smt_core::TermId, Var, FxBuildHasher>,
}

/// Tseitin encoder for Bool terms.
///
/// Design:
/// - Each Boolean term gets a SAT variable representing its truth value.
/// - For operators, we add CNF clauses enforcing equivalence between the variable and the operator semantics.
/// - The caller asserts the returned `root` as a unit clause to encode satisfiability of the original formula.
pub struct TseitinEncoder {
    cnf: Cnf,
    map: HashMap<smt_core::TermId, Var, FxBuildHasher>,
}

impl TseitinEncoder {
    /// Create a new encoder.
    pub fn new() -> Self {
        Self {
            cnf: Cnf::new(),
            map: HashMap::default(),
        }
    }

    /// Encode a Boolean formula, returning CNF + root literal.
    pub fn encode(mut self, ctx: &Context, root: BoolTerm) -> smt_core::Result<TseitinOutput> {
        let v = self.encode_term(ctx, root.id())?;
        let root_lit = Lit::pos(v);

        Ok(TseitinOutput {
            cnf: self.cnf,
            root: root_lit,
            term_to_var: self.map,
        })
    }

    /// Get or create a SAT variable for a boolean term and add constraints for it.
    fn encode_term(&mut self, ctx: &Context, t: smt_core::TermId) -> smt_core::Result<Var> {
        // Ensure term is boolean at boundary.
        ctx.ensure_bool(t)?;

        if let Some(&v) = self.map.get(&t) {
            return Ok(v);
        }

        // Allocate variable for this term.
        let v = self.cnf.fresh_var();
        self.map.insert(t, v);

        // Add defining clauses based on the term structure.
        let (k, _s) = ctx.term_node(t);

        match k {
            smt_core::TermKind::ConstBool(b) => {
                // v <-> true  => (v)
                // v <-> false => (¬v)
                self.cnf.add_unit(if *b { Lit::pos(v) } else { Lit::neg(v) });
            }

            smt_core::TermKind::Var(_sym) => {
                // A Boolean variable/constant: no extra clauses needed.
                // Its SAT var is the representation.
            }

            smt_core::TermKind::App { op, args } => {
                use smt_core::OpKind;

                match op.kind {
                    OpKind::Not => {
                        let a = expect_arity(args, 1, "not")?;
                        let va = self.encode_term(ctx, *a)?;
                        // v <-> ¬a  encoded as:
                        // (¬v ∨ ¬a) and (v ∨ a)
                        self.cnf.add_clause(vec![Lit::neg(v), Lit::neg(va)]);
                        self.cnf.add_clause(vec![Lit::pos(v), Lit::pos(va)]);
                    }

                    OpKind::And => {
                        // v <-> (a1 ∧ ... ∧ an)
                        // (¬v ∨ a1) ... (¬v ∨ an) and (v ∨ ¬a1 ∨ ... ∨ ¬an)
                        if args.is_empty() {
                            // (and) = true in SMT-LIB tradition (identity).
                            self.cnf.add_unit(Lit::pos(v));
                        } else {
                            let mut negs: Vec<Lit> = Vec::with_capacity(args.len() + 1);
                            negs.push(Lit::pos(v));
                            for a in args.iter() {
                                let va = self.encode_term(ctx, *a)?;
                                self.cnf.add_clause(vec![Lit::neg(v), Lit::pos(va)]);
                                negs.push(Lit::neg(va));
                            }
                            self.cnf.add_clause(negs);
                        }
                    }

                    OpKind::Or => {
                        // v <-> (a1 ∨ ... ∨ an)
                        // (v ∨ ¬a1) ... (v ∨ ¬an) and (¬v ∨ a1 ∨ ... ∨ an)
                        if args.is_empty() {
                            // (or) = false in SMT-LIB tradition (identity).
                            self.cnf.add_unit(Lit::neg(v));
                        } else {
                            let mut pos: Vec<Lit> = Vec::with_capacity(args.len() + 1);
                            pos.push(Lit::neg(v));
                            for a in args.iter() {
                                let va = self.encode_term(ctx, *a)?;
                                self.cnf.add_clause(vec![Lit::pos(v), Lit::neg(va)]);
                                pos.push(Lit::pos(va));
                            }
                            self.cnf.add_clause(pos);
                        }
                    }

                    // For a minimal bootstrap, reject other ops.
                    // You can extend with Xor / Ite / Eq over Bool later.
                    other => {
                        return Err(smt_core::Error::SortError(format!(
                            "Tseitin encoder: unsupported boolean operator {:?}",
                            other
                        )));
                    }
                }
            }
        }

        Ok(v)
    }
}

/// Validate arity and return first arg reference for unary ops.
fn expect_arity<'a>(
    args: &'a smallvec::SmallVec<[smt_core::TermId; 4]>,
    expected: usize,
    opname: &str,
) -> smt_core::Result<&'a smt_core::TermId> {
    if args.len() != expected {
        return Err(smt_core::Error::SortError(format!(
            "operator `{}` expects {} args, got {}",
            opname,
            expected,
            args.len()
        )));
    }
    Ok(&args[0])
}
```

---

# D) Wiring: `Cargo.toml` for `smt-preprocess`

### `crates/smt-preprocess/Cargo.toml`

```toml
[package]
name = "smt-preprocess"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "Preprocessing passes and encoders (CNF, rewriting) for the modular SMT solver."
repository = "https://example.com/your/repo"

[features]
default = ["std"]
std = ["smt-core/std", "smt-sat/std"]
alloc = ["smt-core/alloc", "smt-sat/alloc"]

[dependencies]
smt-core = { path = "../smt-core", default-features = false }
smt-sat  = { path = "../smt-sat",  default-features = false }

hashbrown = { workspace = true, default-features = false }
rustc-hash = { workspace = true }
smallvec = { workspace = true, default-features = false }

[lints.rust]
unsafe_code = "forbid"
missing_docs = "warn"
```

(You can decide whether `smt-sat` should have `std/alloc` features; right now it only uses `Vec`, so it needs `alloc` in `no_std` builds. If you want that, add `#![cfg_attr(not(feature="std"), no_std)] extern crate alloc;` to `smt-sat` too.)

---

# E) Example usage (end-to-end)

```rust
use smt_core::prelude::*;
use smt_preprocess::TseitinEncoder;

fn main() -> Result<()> {
    let mut ctx = Context::default();

    let x = ctx.mk_bool_var("x");
    let y = ctx.mk_bool_var("y");

    let f = ctx.and([x, y])?; // (and x y)
    let g = ctx.not(f)?;      // (not (and x y))

    let out = TseitinEncoder::new().encode(&ctx, g)?;
    println!("CNF vars: {}", out.cnf.num_vars);
    println!("CNF clauses: {}", out.cnf.clauses.len());
    println!("root lit: {:?}", out.root);

    // If you were to solve:
    // out.cnf.add_unit(out.root); // assert formula true
    Ok(())
}
```

---

## What I’d do next (and it stays “beautiful”)

1. Extend boolean fragment with `Eq` over Bool and `Ite` (still easy in Tseitin).
2. Add a tiny **DIMACS exporter** in `smt-sat` for debugging.
3. Implement a small CDCL solver (or wrap an embedded one) in `smt-sat`, keeping `Var/Lit/Cnf` stable.
4. Add an **interface trait** `SatSolver` in `smt-engine` so you can swap CDCL engines.

If you say “yes”, I’ll show the `SatSolver` trait + a minimal “toy CDCL” skeleton (with doc comments) that consumes `Cnf` and supports assumptions + incremental add-clause.
