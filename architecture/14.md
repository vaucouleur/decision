Below are the **concrete changes** to `ToyCdcl` so it implements the new `SatKernel` trait cleanly, including the important “trail head clamping” detail when SAT backtracks (whether initiated by SAT internally during conflict resolution or by the engine during `pop`).

I’m going to show:

1. the `SatKernel` trait file you should expose from `smt-sat`
2. an updated `ToyCdcl` with the necessary new fields + methods + `impl SatKernel`
3. the one subtle but crucial invariant: **whenever the trail shrinks, clamp `notify_head`**

---

## 1) `crates/smt-sat/src/lib.rs` exports

Add:

```rust
pub mod kernel;
```

And in `crates/smt-sat/src/lib.rs`:

```rust
pub use crate::kernel::{Conflict, LBool, SatKernel};
```

---

## 2) `crates/smt-sat/src/kernel.rs` (final)

```rust
use crate::{Clause, Lit, SatStats, Var};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LBool {
    True,
    False,
    Undef,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Conflict {
    pub clause: usize,
}

pub trait SatKernel {
    fn reserve_vars(&mut self, num_vars: u32);

    fn add_clause_return_index(&mut self, clause: Clause) -> usize;

    #[inline]
    fn add_clause(&mut self, clause: Clause) {
        let _ = self.add_clause_return_index(clause);
    }

    fn new_decision_level(&mut self);
    fn backtrack(&mut self, level: usize);
    fn decision_level(&self) -> usize;

    fn enqueue(&mut self, lit: Lit, reason: Option<usize>) -> bool;

    /// Propagate to fixpoint.
    ///
    /// The kernel may learn/backjump internally. Only return `Err` for global UNSAT at level 0.
    fn propagate(&mut self) -> Result<(), Conflict>;

    fn value_var(&self, var: Var) -> LBool;
    fn value_lit(&self, lit: Lit) -> LBool;

    fn trail(&self) -> &[Lit];

    /// Engine notification cursor: where new assignments begin.
    fn trail_head(&self) -> usize;
    fn set_trail_head(&mut self, new_head: usize);

    fn stats(&self) -> SatStats;

    fn pick_branch_lit(&self) -> Option<Lit>;

    fn fresh_var(&mut self) -> Var;
}
```

---

## 3) Updated `ToyCdcl` implementing `SatKernel`

This is your earlier `ToyCdcl` (with 1-UIP learning), plus:

* `notify_head: usize`   (engine’s cursor into the trail)
* `add_clause_return_index()` returning `ClauseRef`
* `fresh_var()`
* `value_var/value_lit` returning `LBool`
* **clamp** `notify_head` inside `backtrack()`, `reset_search_state()`, and anywhere SAT shrinks trail

### `crates/smt-sat/src/toy_cdcl.rs` (only the delta you need)

I’m showing the added/changed parts; you can paste them into the existing full file.

#### A) Add field to struct

```rust
    // Engine notification cursor into `trail`.
    notify_head: usize,
```

Initialize in `new()`:

```rust
            notify_head: 0,
```

Reset in `reset_search_state()`:

```rust
        self.notify_head = 0;
```

Clamp in `backtrack()` (after you shrink trail):

```rust
        self.qhead = self.trail.len();

        // IMPORTANT: engine cursor must not point past end of trail after backtrack.
        if self.notify_head > self.trail.len() {
            self.notify_head = self.trail.len();
        }
```

Also clamp in any other place where you truncate trail (you currently only do it in `backtrack` and `reset_search_state`, so this is enough).

---

#### B) Add `add_clause_return_index` helper

You already have:

```rust
fn add_clause_internal(&mut self, clause: Clause) -> ClauseRef
```

Keep it, but make sure it returns `cidx` (it already does in my earlier version).

---

#### C) Expose enqueue wrapper compatible with kernel trait

You already have:

```rust
fn enqueue_with_reason(&mut self, lit: Lit, reason: Option<ClauseRef>) -> bool
```

We’ll call this from `SatKernel::enqueue`.

---

#### D) Add `fresh_var()`

Add:

```rust
    /// Allocate a new variable at the end.
    fn fresh_var_impl(&mut self) -> Var {
        let v = Var::from_u32(self.num_vars);
        self.reserve_vars(self.num_vars + 1);
        v
    }
```

---

#### E) Add `value_var` / `value_lit` returning `LBool`

Add:

```rust
    fn value_var_lbool(&self, var: Var) -> crate::kernel::LBool {
        match self.assigns.get(var.as_u32() as usize).copied().unwrap_or(0) {
            1 => crate::kernel::LBool::True,
            -1 => crate::kernel::LBool::False,
            _ => crate::kernel::LBool::Undef,
        }
    }

    fn value_lit_lbool(&self, lit: Lit) -> crate::kernel::LBool {
        match self.lit_value(lit) {
            1 => crate::kernel::LBool::True,
            -1 => crate::kernel::LBool::False,
            _ => crate::kernel::LBool::Undef,
        }
    }
```

---

#### F) Implement `SatKernel` for `ToyCdcl`

At the bottom of the file, add:

```rust
use crate::kernel::{Conflict, LBool, SatKernel};

impl SatKernel for ToyCdcl {
    fn reserve_vars(&mut self, num_vars: u32) {
        // Reuse your existing reserve_vars logic from SatSolver impl.
        // If you kept only SatSolver before, move that code here.
        if num_vars <= self.num_vars {
            return;
        }
        self.num_vars = num_vars;

        self.assigns.resize(self.num_vars as usize, 0);
        self.levels.resize(self.num_vars as usize, 0);
        self.reasons.resize(self.num_vars as usize, None);

        self.activity.resize(self.num_vars as usize, 0.0);
        self.phase.resize(self.num_vars as usize, true);

        self.watches.resize((self.num_vars as usize) * 2, Vec::new());
    }

    fn add_clause_return_index(&mut self, clause: Clause) -> usize {
        if self.inconsistent {
            // Still return a stable index; but nothing meaningful. Keep it simple:
            // create an empty “dummy” entry is not great. Better: accept that
            // in inconsistent mode we don't care about indices.
            return 0;
        }
        if clause.is_empty() {
            self.inconsistent = true;
            return 0;
        }

        // Reserve vars.
        let mut maxv = 0u32;
        for lit in clause.iter() {
            maxv = maxv.max(lit.var().as_u32() + 1);
        }
        self.reserve_vars(maxv);

        self.add_clause_internal(clause)
    }

    fn new_decision_level(&mut self) {
        self.new_decision_level();
    }

    fn backtrack(&mut self, level: usize) {
        self.backtrack(level);
        // backtrack() already clamps notify_head as per the patch above
    }

    fn decision_level(&self) -> usize {
        self.decision_level()
    }

    fn enqueue(&mut self, lit: Lit, reason: Option<usize>) -> bool {
        self.enqueue_with_reason(lit, reason)
    }

    fn propagate(&mut self) -> Result<(), Conflict> {
        // In your CDCL kernel, conflicts are handled by learning/backjump
        // inside `solve()`. For kernel-driven SMT, we want propagate() to:
        // - run propagation
        // - on conflict, do analyze+learn+backjump+assert
        // - repeat until fixpoint or UNSAT at level 0.
        //
        // So we inline the conflict loop here.

        loop {
            if self.inconsistent {
                return Err(Conflict { clause: 0 });
            }

            let conflict = self.propagate(); // your internal watched-lits propagation
            if conflict.is_none() {
                return Ok(());
            }

            let conflict = conflict.expect("some");
            if self.decision_level() == 0 {
                return Err(Conflict { clause: conflict });
            }

            // Analyze conflict (1-UIP), learn clause, backjump, enqueue asserting lit.
            let (mut learned, backjump_level, asserting) = self.analyze_conflict(conflict);

            // Optional minimization if you implemented it.
            self.minimize_learned_clause(&mut learned);

            // VSIDS bump if you implemented it.
            self.bump_activity(&learned);

            let learned_cidx = self.add_clause_internal(learned);
            self.backtrack(backjump_level);

            if !self.enqueue_with_reason(asserting, Some(learned_cidx)) {
                // If it immediately contradicts, continue—propagate will see it.
                // If level 0, next loop iteration will return UNSAT.
                continue;
            }

            // Continue loop: propagate again until fixpoint or UNSAT.
        }
    }

    fn value_var(&self, var: Var) -> LBool {
        self.value_var_lbool(var)
    }

    fn value_lit(&self, lit: Lit) -> LBool {
        self.value_lit_lbool(lit)
    }

    fn trail(&self) -> &[Lit] {
        &self.trail
    }

    fn trail_head(&self) -> usize {
        self.notify_head
    }

    fn set_trail_head(&mut self, new_head: usize) {
        self.notify_head = new_head.min(self.trail.len());
    }

    fn stats(&self) -> SatStats {
        self.stats
    }

    fn pick_branch_lit(&self) -> Option<Lit> {
        self.pick_branch_lit()
    }

    fn fresh_var(&mut self) -> Var {
        self.fresh_var_impl()
    }
}
```

### Important detail: name collisions inside impl

Notice: `fn propagate(&mut self)` in trait calls your internal `propagate()` with the same name. Rename the internal one to avoid accidental recursion:

* Rename internal watched-literals propagation to `propagate_watches()` (recommended).

So in your solver, change:

```rust
fn propagate(&mut self) -> Option<ClauseRef>
```

to:

```rust
fn propagate_watches(&mut self) -> Option<ClauseRef>
```

and update call sites accordingly.

Then in `SatKernel::propagate()`:

```rust
let conflict = self.propagate_watches();
```

Same for `pick_branch_lit`: rename internal to `pick_branch_lit_impl()` to avoid recursion in the trait impl (or call it with `Self::pick_branch_lit(self)` pattern, but renaming is clearer).

---

## 4) The subtle invariant you must keep

**Whenever SAT backtracks (for any reason), the engine’s notification cursor must be clamped.**

You’ve now ensured that because:

* `ToyCdcl::backtrack()` clamps `notify_head`
* `SatKernel::set_trail_head()` also clamps
* `reset_search_state()` resets it to 0

This prevents a classic CDCL(T) bug where the engine “skips” notifying theories about assignments because its cursor points beyond the new trail end after backjump.

---

## 5) One last tweak: stable clause indices

If you plan to use `reason = Some(cidx)` reliably, ensure:

* clause indices never change (no deletion or compaction), or
* reasons use a stable “ClauseId” indirection.

For now: **don’t delete clauses** in ToyCdcl. If you later add deletion, introduce:

```rust
struct ClauseId(u32);
```

and a slab with generation counters.

---

If you say **yes** again, I’ll give you a complete small working “vertical slice” demo:

* build `Context` with UF terms
* propositionalize
* register UF atoms
* run `CdcltEngine<ToyCdcl>` with `UfTheory`
* and print SAT/UNSAT + a model for a few atoms.
