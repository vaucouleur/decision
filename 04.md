Below are the missing pieces:

1. `crates/smt-core/Cargo.toml` (features + deps wired correctly)
2. a small pretty-printer (`pretty.rs`) + the tiny `len()` additions so `Context::stats()` works.

---

## 1) `crates/smt-core/Cargo.toml`

```toml
[package]
name = "smt-core"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "Core term DAG, sorts, and scoped context for a modular SMT solver."
repository = "https://example.com/your/repo"

[features]
# Keep core usable standalone.
default = ["std"]

# `std` implies `alloc` in practice, but we keep both flags explicit and propagatable.
std = ["alloc", "hashbrown/std", "smallvec/std"]

# Enables `alloc`-based collections when building in `no_std`.
alloc = ["hashbrown/alloc", "smallvec/alloc"]

# Optional serde support (IDs, and optionally node kinds if you decide to expose them).
serde = ["dep:serde", "hashbrown/serde", "smallvec/serde"]

# Optional tracing hooks (kept lightweight; you can make it std-only if you prefer).
tracing = ["dep:tracing"]

[dependencies]
# Fast hash maps/sets with `no_std + alloc` support.
hashbrown = { workspace = true, default-features = false, features = ["default-hasher"] }

# Fast hasher; typically `no_std`-friendly.
rustc-hash = { workspace = true }

# Compact argument vectors in term nodes (most apps have small arity).
smallvec = { workspace = true, default-features = false }

serde = { workspace = true, optional = true, default-features = false, features = ["derive"] }
tracing = { workspace = true, optional = true, default-features = false }

[lints.rust]
unsafe_code = "forbid"
missing_docs = "warn"

[lints.clippy]
all = "warn"
pedantic = "warn"
module_name_repetitions = "allow"
too_many_lines = "allow"
```

> Note: `hashbrown` feature `"default-hasher"` is handy if you later decide to remove `rustc-hash`. Keeping `rustc-hash` is totally fine (and fast), but you can simplify later.

Also add this guard near the top of `smt-core/src/lib.rs` (recommended):

```rust
#[cfg(all(not(feature = "std"), not(feature = "alloc")))]
compile_error!("smt-core requires either feature `std` or feature `alloc`.");
```

---

## 2) Add `len()` methods to interners

### `crates/smt-core/src/interner.rs` (additions only)

```rust
impl SymbolInterner {
    /// Number of interned symbols.
    #[inline]
    pub(crate) fn len(&self) -> usize {
        self.vec.len()
    }
}

impl SortInterner {
    /// Number of interned sorts.
    #[inline]
    pub(crate) fn len(&self) -> usize {
        self.vec.len()
    }
}

impl TermInterner {
    /// Number of interned term nodes.
    #[inline]
    pub(crate) fn len(&self) -> usize {
        self.vec.len()
    }
}
```

### `crates/smt-core/src/context.rs` (fix `stats()`)

Replace your `stats()` + the stubbed `*_len()` helpers with this:

```rust
    /// Basic stats (useful for early perf profiling).
    pub fn stats(&self) -> ContextStats {
        ContextStats {
            terms: self.terms.len(),
            sorts: self.sorts.len(),
            symbols: self.syms.len(),
        }
    }
```

(And delete the now-useless `terms_len/sorts_len/syms_len` private fns.)

---

## 3) Pretty printer

### `crates/smt-core/src/pretty.rs`

````rust
use core::fmt;

use crate::context::Context;
use crate::ids::{SortId, TermId};
use crate::op::OpKind;
use crate::sort::SortKind;
use crate::term::TermKind;

/// A display wrapper that prints a term in an SMT-LIB-ish s-expression style.
///
/// This is intentionally small and dependency-free.
/// - No hash-cons DAG “sharing” printing yet (it will repeat subterms).
/// - No let-binding introduction yet.
/// - Good enough for debugging, tests, and logs.
///
/// Usage:
/// ```ignore
/// println!("{}", ctx.pretty_term(t));
/// ```
pub struct PrettyTerm<'a> {
    ctx: &'a Context,
    term: TermId,
}

impl<'a> PrettyTerm<'a> {
    /// Create a new pretty printer wrapper.
    pub fn new(ctx: &'a Context, term: TermId) -> Self {
        Self { ctx, term }
    }
}

impl fmt::Display for PrettyTerm<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt_term(self.ctx, self.term, f)
    }
}

/// A display wrapper for sorts.
pub struct PrettySort<'a> {
    ctx: &'a Context,
    sort: SortId,
}

impl<'a> PrettySort<'a> {
    /// Create a new sort pretty printer wrapper.
    pub fn new(ctx: &'a Context, sort: SortId) -> Self {
        Self { ctx, sort }
    }
}

impl fmt::Display for PrettySort<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt_sort(self.ctx, self.sort, f)
    }
}

// ----------------------------------------------------------------------------
// Context convenience constructors
// ----------------------------------------------------------------------------

impl Context {
    /// Pretty-print a term.
    #[inline]
    pub fn pretty_term(&self, t: TermId) -> PrettyTerm<'_> {
        PrettyTerm::new(self, t)
    }

    /// Pretty-print a sort.
    #[inline]
    pub fn pretty_sort(&self, s: SortId) -> PrettySort<'_> {
        PrettySort::new(self, s)
    }
}

// ----------------------------------------------------------------------------
// Formatting helpers
// ----------------------------------------------------------------------------

fn fmt_sort(ctx: &Context, s: SortId, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    match ctx.sort_kind(s) {
        SortKind::Bool => write!(f, "Bool"),
        SortKind::Int => write!(f, "Int"),
        SortKind::Real => write!(f, "Real"),
        SortKind::BitVec { width } => write!(f, "(_ BitVec {width})"),
        SortKind::Array { index, elem } => {
            write!(f, "(Array ")?;
            fmt_sort(ctx, *index, f)?;
            write!(f, " ")?;
            fmt_sort(ctx, *elem, f)?;
            write!(f, ")")
        }
        SortKind::Uninterpreted { name } => {
            // Minimal: we only stored a numeric “name”. If you switch SortKind to store SymbolId,
            // print the actual symbol name here.
            write!(f, "U{}", name.0)
        }
    }
}

fn fmt_term(ctx: &Context, t: TermId, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    let (k, _sort) = ctx.term_node(t);
    match k {
        TermKind::ConstBool(b) => write!(f, "{}", if *b { "true" } else { "false" }),
        TermKind::ConstInt(i) => write!(f, "{i}"),
        TermKind::Var(sym) => write!(f, "{}", ctx.sym_name(*sym)),
        TermKind::App { op, args } => {
            write!(f, "(")?;
            fmt_op(ctx, op.kind, f)?;
            for &a in args.iter() {
                write!(f, " ")?;
                fmt_term(ctx, a, f)?;
            }
            write!(f, ")")
        }
    }
}

fn fmt_op(ctx: &Context, op: OpKind, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    let s = match op {
        OpKind::Not => "not",
        OpKind::And => "and",
        OpKind::Or => "or",
        OpKind::Xor => "xor",
        OpKind::Ite => "ite",
        OpKind::Eq => "=",
        OpKind::Add => "+",
        OpKind::Sub => "-",
        OpKind::Mul => "*",
        OpKind::Lt => "<",
        OpKind::Le => "<=",
        OpKind::BvNot => "bvnot",
        OpKind::BvAnd => "bvand",
        OpKind::BvOr => "bvor",
        OpKind::BvXor => "bvxor",
        OpKind::Uf(sym) => return write!(f, "{}", ctx.sym_name(sym)),
    };
    write!(f, "{s}")
}
````

### Make sure `lib.rs` exposes it

In `smt-core/src/lib.rs`, you already had:

```rust
mod pretty;
```

and:

```rust
pub mod fmt {
    pub use crate::pretty::{PrettyTerm, PrettySort};
}
```

That’s enough (or keep the `Context::pretty_term/pretty_sort` methods as shown above, which is a very ergonomic UX).

---

If you want the next “real SMT solver” step, I’d suggest we adjust `SortKind::Uninterpreted` to store a `SymbolId` directly (so pretty-printing and symbol tables are consistent), and then add **type-checking helpers** (`term_sort(t)`, `ensure_bool(t)`, etc.) so your later SAT/theory layers don’t need to duplicate sort logic.
