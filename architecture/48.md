Below is a robust `assert_unsat_core_contains_any(...)` helper that:

* asserts `check_sat() == UNSAT`
* checks the UNSAT core contains **at least one** label from each **required group** (so it’s not brittle)
* if anything fails, it re-runs with eq-sharing debug enabled and points you to the bundle folder

This is ideal for your 3 combo regressions where cores can vary.

---

## 1) Helper: groups-based UNSAT core assertion (+ bundle on failure)

### `crates/smt-tests/src/core_assert.rs`

```rust
#![forbid(unsafe_code)]

use std::collections::HashSet;

use smt_api::{CheckSat, Session};
use smt_engine::test_debug;

/// A requirement is a set of labels of which at least one must appear in the UNSAT core.
#[derive(Debug, Clone)]
pub struct CoreReq {
    pub any_of: &'static [&'static str],
    pub name: &'static str, // for better error messages
}

fn core_to_set(sess: &Session) -> HashSet<String> {
    sess.get_unsat_core().into_iter().map(|l| l.0).collect()
}

/// Assert UNSAT and that the core contains at least one label from each requirement group.
///
/// If it fails, reruns the same instance with debug enabled (to write DOT bundle) and panics
/// with a clear message.
///
///// - `make_sess`: builds a fresh session (must be deterministic)
/// - `setup`: adds the assertions
pub fn assert_unsat_core_contains_any<FMake, FSetup>(
    mut make_sess: FMake,
    setup: FSetup,
    reqs: &[CoreReq],
) -> smt_core::Result<()>
where
    FMake: FnMut() -> Session,
    FSetup: Fn(&mut Session) -> smt_core::Result<()>,
{
    // First run: debug off
    test_debug::set_eqshare_debug_enabled(false);

    let mut sess = make_sess();
    setup(&mut sess)?;
    let got = sess.check_sat();

    if got != CheckSat::Unsat {
        // Rerun with debug enabled to capture artifacts
        test_debug::set_eqshare_debug_enabled(true);

        let mut sess2 = make_sess();
        setup(&mut sess2)?;
        let got2 = sess2.check_sat();

        test_debug::set_eqshare_debug_enabled(false);

        panic!(
            "expected UNSAT but got {:?}; rerun-with-debug got {:?}. \
             If UNSAT, see target/smt-debug-<pid>/ for eqshare.dot + conflict.dot.",
            got, got2
        );
    }

    // Core checks
    let core = core_to_set(&sess);

    let mut missing = Vec::new();
    for r in reqs {
        if !r.any_of.iter().any(|lab| core.contains(*lab)) {
            missing.push((r.name, r.any_of));
        }
    }

    if missing.is_empty() {
        return Ok(());
    }

    // Rerun with debug enabled to capture artifacts for diagnosis
    test_debug::set_eqshare_debug_enabled(true);

    let mut sess2 = make_sess();
    setup(&mut sess2)?;
    let _ = sess2.check_sat(); // force bundle on UNSAT path

    let core2 = core_to_set(&sess2);

    test_debug::set_eqshare_debug_enabled(false);

    panic!(
        "UNSAT core did not satisfy requirements.\n\
         first core: {:?}\n\
         rerun core:  {:?}\n\
         missing groups: {:?}\n\
         See target/smt-debug-<pid>/ for eqshare.dot + conflict.dot.",
        core, core2, missing
    );
}
```

---

## 2) Use it in your 3 regressions

### UF → DL regression (expected UNSAT core should include AB and both DL inequalities)

```rust
use crate::core_assert::{assert_unsat_core_contains_any, CoreReq};

#[test]
fn uf_to_dl_unsat_core_shape() -> smt_core::Result<()> {
    assert_unsat_core_contains_any(
        || common::make_session(SharingConfig { uf_to_dl: true, dl_to_uf: false }),
        setup_uf_to_dl_instance,
        &[
            CoreReq { name: "UF equality", any_of: &["AB"] },
            CoreReq { name: "DL fa constraint", any_of: &["FA_LE_0"] },
            CoreReq { name: "DL fb constraint", any_of: &["FB_GE_1"] },
        ],
    )
}
```

### DL → UF regression (core should include both inequalities and the UF diseq)

```rust
#[test]
fn dl_to_uf_unsat_core_shape() -> smt_core::Result<()> {
    assert_unsat_core_contains_any(
        || common::make_session(SharingConfig { uf_to_dl: false, dl_to_uf: true }),
        setup_dl_to_uf_instance,
        &[
            CoreReq { name: "DL x<=y", any_of: &["X_LE_Y"] },
            CoreReq { name: "DL y<=x", any_of: &["Y_LE_X"] },
            CoreReq { name: "UF diseq", any_of: &["GX_NE_GY"] },
        ],
    )
}
```

### Ping-pong regression (core can vary; require the diseq + at least one of the chain labels)

```rust
#[test]
fn ping_pong_unsat_core_shape() -> smt_core::Result<()> {
    assert_unsat_core_contains_any(
        || common::make_session(SharingConfig { uf_to_dl: true, dl_to_uf: true }),
        setup_ping_pong_instance,
        &[
            CoreReq { name: "UF diseq", any_of: &["GX_NE_GY"] },
            CoreReq { name: "UF a=b", any_of: &["A_EQ_B"] },
            CoreReq { name: "x=f(a) or y=f(b) constraints", any_of: &["X_LE_FA", "FA_LE_X", "Y_LE_FB", "FB_LE_Y"] },
        ],
    )
}
```

This avoids brittleness while still catching real regressions.

---

## 3) Make sure UNSAT core labels are stable

If your `Session::assert(term, Some(label))` stores labels, you’re good.
If not, you can store labels in a map from atom var to label and recover.

---

## 4) Optional: also check the eqshare graph is non-empty (super useful)

If you want, I can add a postcondition like:

* for UF→DL test: eqshare trace contains at least one UF→DL event on `f(a)=f(b)`
* for DL→UF test: contains at least one DL→UF event on `x=y`

That’s sometimes even more direct than core shape.

Just say **yes** and I’ll add those trace assertions.
