Here are the **other two** in the same compact style: **UF→DL** and **DL→UF**. They match the ping-pong layout: `run_*()` helper returning `(res, events, inst)` and a single `#[test]` that checks the matrix rows.

---

# `crates/smt-tests/src/equality_sharing_golden_compact_uf_dl.rs`

```rust
#![forbid(unsafe_code)]

use crate::prelude::*;

mod common;
use common::make_session;

#[derive(Debug, Clone, Copy)]
struct UfToDlInst {
    fa: smt_core::TermId,
    fb: smt_core::TermId,
}

fn setup_uf_to_dl(sess: &mut smt_api::Session) -> smt_core::Result<UfToDlInst> {
    let u = sess.declare_uninterpreted_sort("U");
    let a = sess.declare_const("a", u);
    let b = sess.declare_const("b", u);

    let f = sess.declare_ufun("f");
    let int = sess.ctx().int_sort();

    let fa = sess.app_uf(f, &[a], int)?;
    let fb = sess.app_uf(f, &[b], int)?;

    sess.assert(sess.eq(a, b)?, Some("AB"))?;

    let zero = sess.ctx().int_const(0);
    sess.assert(sess.ctx().le(fa, zero)?, Some("FA_LE_0"))?;

    let one = sess.ctx().int_const(1);
    sess.assert(sess.ctx().le(one, fb)?, Some("FB_GE_1"))?;

    Ok(UfToDlInst { fa, fb })
}

fn run_uf_to_dl(cfg: SharingConfig) -> smt_core::Result<(CheckSat, Vec<smt_engine::eqshare_trace::EqShareEvent>, UfToDlInst)> {
    let mut sess = make_session(cfg);
    let inst = setup_uf_to_dl(&mut sess)?;
    let res = sess.check_sat();
    let events = sess.take_eqshare_events();
    Ok((res, events, inst))
}

#[test]
fn golden_uf_to_dl_matrix_compact() -> smt_core::Result<()> {
    // (0) both off => SAT + no events
    {
        let (res, events, _) = run_uf_to_dl(SharingConfig { uf_to_dl: false, dl_to_uf: false })?;
        assert_eq!(res, CheckSat::Sat);
        assert_eqshare_events_empty!(&events);
    }

    // (1) UF->DL only => UNSAT + UF->DL hop on f(a)=f(b); no DL->UF direction
    {
        assert_sat_with_bundle_on_mismatch(
            || make_session(SharingConfig { uf_to_dl: true, dl_to_uf: false }),
            |s| { setup_uf_to_dl(s).map(|_| ()) },
            Expect::Unsat,
        )?;

        assert_unsat_core_contains_any(
            || make_session(SharingConfig { uf_to_dl: true, dl_to_uf: false }),
            |s| { setup_uf_to_dl(s).map(|_| ()) },
            &[
                CoreReq { name: "UF equality", any_of: &["AB"] },
                CoreReq { name: "DL fa constraint", any_of: &["FA_LE_0"] },
                CoreReq { name: "DL fb constraint", any_of: &["FB_GE_1"] },
            ],
        )?;

        let (res, events, inst) = run_uf_to_dl(SharingConfig { uf_to_dl: true, dl_to_uf: false })?;
        assert_eq!(res, CheckSat::Unsat);

        assert_eqshare_dir!(&events, UF => DL);
        assert_eqshare_dir_none!(&events, DL => UF);
        assert_eqshare_hop!(&events, UF => DL, inst.fa, inst.fb);
    }

    // (2) DL->UF only => SAT; no UF->DL hop expected
    {
        let (res, events, inst) = run_uf_to_dl(SharingConfig { uf_to_dl: false, dl_to_uf: true })?;
        assert_eq!(res, CheckSat::Sat);

        assert_eqshare_dir_none!(&events, UF => DL);
        assert_eqshare_hop_none!(&events, UF => DL, [(inst.fa, inst.fb)]);
    }

    Ok(())
}
```

---

# `crates/smt-tests/src/equality_sharing_golden_compact_dl_uf.rs`

```rust
#![forbid(unsafe_code)]

use crate::prelude::*;

mod common;
use common::make_session;

#[derive(Debug, Clone, Copy)]
struct DlToUfInst {
    x: smt_core::TermId,
    y: smt_core::TermId,
}

fn setup_dl_to_uf(sess: &mut smt_api::Session) -> smt_core::Result<DlToUfInst> {
    let int = sess.ctx().int_sort();
    let x = sess.declare_const("x", int);
    let y = sess.declare_const("y", int);

    let u = sess.declare_uninterpreted_sort("U");
    let g = sess.declare_ufun("g");

    let gx = sess.app_uf(g, &[x], u)?;
    let gy = sess.app_uf(g, &[y], u)?;

    sess.assert(sess.ctx().le(x, y)?, Some("X_LE_Y"))?;
    sess.assert(sess.ctx().le(y, x)?, Some("Y_LE_X"))?;
    sess.assert(sess.not(sess.eq(gx, gy)?)?, Some("GX_NE_GY"))?;

    Ok(DlToUfInst { x, y })
}

fn run_dl_to_uf(cfg: SharingConfig) -> smt_core::Result<(CheckSat, Vec<smt_engine::eqshare_trace::EqShareEvent>, DlToUfInst)> {
    let mut sess = make_session(cfg);
    let inst = setup_dl_to_uf(&mut sess)?;
    let res = sess.check_sat();
    let events = sess.take_eqshare_events();
    Ok((res, events, inst))
}

#[test]
fn golden_dl_to_uf_matrix_compact() -> smt_core::Result<()> {
    // (0) both off => SAT + no events
    {
        let (res, events, _) = run_dl_to_uf(SharingConfig { uf_to_dl: false, dl_to_uf: false })?;
        assert_eq!(res, CheckSat::Sat);
        assert_eqshare_events_empty!(&events);
    }

    // (1) DL->UF only => UNSAT + DL->UF hop on x=y; no UF->DL direction
    {
        assert_sat_with_bundle_on_mismatch(
            || make_session(SharingConfig { uf_to_dl: false, dl_to_uf: true }),
            |s| { setup_dl_to_uf(s).map(|_| ()) },
            Expect::Unsat,
        )?;

        assert_unsat_core_contains_any(
            || make_session(SharingConfig { uf_to_dl: false, dl_to_uf: true }),
            |s| { setup_dl_to_uf(s).map(|_| ()) },
            &[
                CoreReq { name: "DL x<=y", any_of: &["X_LE_Y"] },
                CoreReq { name: "DL y<=x", any_of: &["Y_LE_X"] },
                CoreReq { name: "UF diseq", any_of: &["GX_NE_GY"] },
            ],
        )?;

        let (res, events, inst) = run_dl_to_uf(SharingConfig { uf_to_dl: false, dl_to_uf: true })?;
        assert_eq!(res, CheckSat::Unsat);

        assert_eqshare_dir!(&events, DL => UF);
        assert_eqshare_dir_none!(&events, UF => DL);
        assert_eqshare_hop!(&events, DL => UF, inst.x, inst.y);
    }

    // (2) UF->DL only => SAT; no DL->UF hop expected
    {
        let (res, events, inst) = run_dl_to_uf(SharingConfig { uf_to_dl: true, dl_to_uf: false })?;
        assert_eq!(res, CheckSat::Sat);

        assert_eqshare_dir_none!(&events, DL => UF);
        assert_eqshare_hop_none!(&events, DL => UF, [(inst.x, inst.y)]);
    }

    Ok(())
}
```

---

## Suggested file layout

* `equality_sharing_golden_compact.rs` (ping-pong)
* `equality_sharing_golden_compact_uf_dl.rs`
* `equality_sharing_golden_compact_dl_uf.rs`

Or merge all three into one module if you prefer.

---

If you want, I can also show a tiny `mod` that conditionally compiles these golden tests only when the `test-debug` feature is enabled (so normal users don’t even compile the trace machinery), while keeping the SAT/UNSAT matrix tests always available.
