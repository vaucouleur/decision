Below is a clean way to turn the 3 demos into **unit tests** with a **SAT/UNSAT matrix** by toggling equality-sharing directions via feature flags (or runtime config). I’ll show:

1. a tiny `SharingConfig` that the engine reads
2. how to wire it into the engine loop
3. test helpers that build a session and run the matrix
4. three `#[test]` cases: UF→DL, DL→UF, ping-pong
5. how to assert *core contains required labels* without being brittle

---

## 1) Add a runtime sharing config

### `crates/smt-engine/src/config.rs`

```rust
#![forbid(unsafe_code)]

/// Controls which equality-sharing flows are enabled.
#[derive(Debug, Clone, Copy)]
pub struct SharingConfig {
    pub uf_to_dl: bool,
    pub dl_to_uf: bool,
}

impl Default for SharingConfig {
    fn default() -> Self {
        Self { uf_to_dl: true, dl_to_uf: true }
    }
}
```

Add to your engine:

```rust
pub struct SmtEngine<K: SatKernel> {
    // ...
    pub sharing: SharingConfig,
}
```

Initialize with `Default::default()`.

---

## 2) Engine: apply config in equality-sharing broadcast

In your `equality_sharing_fixpoint()` where you broadcast exported equalities, split by source theory kind (or TheoryId):

You’ll want to know which theory exported an equality. Easiest: return `(TheoryId, Vec<SharedEq>)`.

Change export loop:

```rust
let mut exported = Vec::<(TheoryId, SharedEq)>::new();

for (i, th) in self.theories.iter_mut().enumerate() {
    let tid = TheoryId(i);
    if let Some(sh) = th.equality_sharing_mut() {
        for eq in sh.export_equalities(&shared, &mut tcx) {
            exported.push((tid, eq));
        }
    }
}
```

Then broadcast with config:

```rust
for (src, eq) in exported {
    for (j, th) in self.theories.iter_mut().enumerate() {
        let dst = TheoryId(j);

        // Don't re-import into same theory (optional)
        if dst == src { continue; }

        // Apply directional policy
        let allow = match (src, dst) {
            (s, d) if s == self.uf_id && d == self.dl_id => self.sharing.uf_to_dl,
            (s, d) if s == self.dl_id && d == self.uf_id => self.sharing.dl_to_uf,
            _ => true, // for future theories
        };

        if !allow { continue; }

        if let Some(sh) = th.equality_sharing_mut() {
            sh.import_equality(eq.clone(), &mut tcx);
        }
    }
}
```

You’ll need `uf_id` and `dl_id` stored in the engine (or in a registry).

---

## 3) Test helper: build a session with UF + DL and a chosen config

### `crates/smt-tests/src/common.rs`

```rust
use std::sync::Arc;

use smt_core::Context;
use smt_sat::ToyCdcl;

use smt_engine::{SmtEngine};
use smt_engine::config::SharingConfig;
use smt_engine::atoms::AtomTable;
use smt_engine::atoms::TheoryId;

use smt_engine::theories::uf_theory_reasoned::UfTheory;
use smt_engine::theories::dl_theory_reasoned::DlTheory;

use smt_engine::classifier::UfDlClassifier;
use smt_api::Session;

pub fn make_session(sharing: SharingConfig) -> Session {
    let ctx = Arc::new(Context::default());

    let uf_id = TheoryId(0);
    let dl_id = TheoryId(1);

    let uf = UfTheory::new(ctx.clone(), uf_id);
    let dl = DlTheory::new(ctx.clone(), dl_id);

    let atoms = AtomTable::default();
    let sat = ToyCdcl::new();

    let mut eng = SmtEngine::new(sat, atoms, vec![Box::new(uf), Box::new(dl)]);
    eng.sharing = sharing;

    // If you stored ids in engine:
    eng.uf_id = uf_id;
    eng.dl_id = dl_id;

    let classifier = Box::new(UfDlClassifier { uf: uf_id, dl: dl_id });

    Session::new(ctx, eng, classifier)
}
```

---

## 4) Assert UNSAT core contains at least some labels (robust)

Cores can vary. Use “must contain at least one of these” or “must contain these three essentials”.

Helper:

```rust
pub fn core_labels(sess: &smt_api::Session) -> std::collections::HashSet<String> {
    sess.get_unsat_core().into_iter().map(|l| l.0).collect()
}

pub fn assert_core_contains(core: &std::collections::HashSet<String>, required: &[&str]) {
    for &r in required {
        assert!(core.contains(r), "core missing label: {r}; got {core:?}");
    }
}
```

---

## 5) Tests: the SAT/UNSAT matrix

Create a test module:

### `crates/smt-tests/src/equality_sharing_matrix.rs`

```rust
use smt_engine::config::SharingConfig;
use smt_api::CheckSat;

mod common;
use common::{make_session, core_labels, assert_core_contains};

#[test]
fn uf_to_dl_regression_matrix() -> smt_core::Result<()> {
    // This is the UF->DL-only test:
    // a=b, f(a)<=0, f(b)>=1  should be UNSAT only when UF->DL sharing is enabled
    // (with our earlier example)

    // 1) Both off => SAT
    {
        let mut sess = make_session(SharingConfig { uf_to_dl: false, dl_to_uf: false });
        setup_uf_to_dl_instance(&mut sess)?;
        assert_eq!(sess.check_sat(), CheckSat::Sat);
    }

    // 2) UF->DL on => UNSAT
    {
        let mut sess = make_session(SharingConfig { uf_to_dl: true, dl_to_uf: false });
        setup_uf_to_dl_instance(&mut sess)?;
        assert_eq!(sess.check_sat(), CheckSat::Unsat);

        let core = core_labels(&sess);
        assert_core_contains(&core, &["AB", "FA_LE_0", "FB_GE_1"]);
    }

    // 3) DL->UF on only => SAT
    {
        let mut sess = make_session(SharingConfig { uf_to_dl: false, dl_to_uf: true });
        setup_uf_to_dl_instance(&mut sess)?;
        assert_eq!(sess.check_sat(), CheckSat::Sat);
    }

    Ok(())
}

#[test]
fn dl_to_uf_regression_matrix() -> smt_core::Result<()> {
    // DL->UF-only test:
    // x<=y, y<=x, g(x)!=g(y)  UNSAT only when DL->UF sharing is enabled

    // both off => SAT
    {
        let mut sess = make_session(SharingConfig { uf_to_dl: false, dl_to_uf: false });
        setup_dl_to_uf_instance(&mut sess)?;
        assert_eq!(sess.check_sat(), CheckSat::Sat);
    }

    // DL->UF on => UNSAT
    {
        let mut sess = make_session(SharingConfig { uf_to_dl: false, dl_to_uf: true });
        setup_dl_to_uf_instance(&mut sess)?;
        assert_eq!(sess.check_sat(), CheckSat::Unsat);

        let core = core_labels(&sess);
        assert_core_contains(&core, &["X_LE_Y", "Y_LE_X", "GX_NE_GY"]);
    }

    // UF->DL on only => SAT
    {
        let mut sess = make_session(SharingConfig { uf_to_dl: true, dl_to_uf: false });
        setup_dl_to_uf_instance(&mut sess)?;
        assert_eq!(sess.check_sat(), CheckSat::Sat);
    }

    Ok(())
}

#[test]
fn ping_pong_regression_matrix() -> smt_core::Result<()> {
    // Ping-pong needs BOTH directions.

    // none => SAT
    {
        let mut sess = make_session(SharingConfig { uf_to_dl: false, dl_to_uf: false });
        setup_ping_pong_instance(&mut sess)?;
        assert_eq!(sess.check_sat(), CheckSat::Sat);
    }

    // only UF->DL => SAT
    {
        let mut sess = make_session(SharingConfig { uf_to_dl: true, dl_to_uf: false });
        setup_ping_pong_instance(&mut sess)?;
        assert_eq!(sess.check_sat(), CheckSat::Sat);
    }

    // only DL->UF => SAT
    {
        let mut sess = make_session(SharingConfig { uf_to_dl: false, dl_to_uf: true });
        setup_ping_pong_instance(&mut sess)?;
        assert_eq!(sess.check_sat(), CheckSat::Sat);
    }

    // both => UNSAT
    {
        let mut sess = make_session(SharingConfig { uf_to_dl: true, dl_to_uf: true });
        setup_ping_pong_instance(&mut sess)?;
        assert_eq!(sess.check_sat(), CheckSat::Unsat);

        let core = core_labels(&sess);
        // not all labels must appear, but these are typically essential:
        assert_core_contains(&core, &["A_EQ_B", "GX_NE_GY"]);
    }

    Ok(())
}

// ----- Instances -----

fn setup_uf_to_dl_instance(sess: &mut smt_api::Session) -> smt_core::Result<()> {
    let u = sess.declare_uninterpreted_sort("U");
    let a = sess.declare_const("a", u);
    let b = sess.declare_const("b", u);

    let f = sess.declare_ufun("f");
    let int = sess.ctx().int_sort();
    let fa = sess.app_uf(f, &[a], int)?;
    let fb = sess.app_uf(f, &[b], int)?;

    sess.assert(sess.eq(a, b)?, Some("AB"))?;

    let zero = sess.ctx().int_const(0);
    sess.assert(sess.ctx().le(fa, zero)?, Some("FA_LE_0"))?;

    let one = sess.ctx().int_const(1);
    sess.assert(sess.ctx().le(one, fb)?, Some("FB_GE_1"))?;

    Ok(())
}

fn setup_dl_to_uf_instance(sess: &mut smt_api::Session) -> smt_core::Result<()> {
    let int = sess.ctx().int_sort();
    let x = sess.declare_const("x", int);
    let y = sess.declare_const("y", int);

    let u = sess.declare_uninterpreted_sort("U");
    let g = sess.declare_ufun("g");

    let gx = sess.app_uf(g, &[x], u)?;
    let gy = sess.app_uf(g, &[y], u)?;

    sess.assert(sess.ctx().le(x, y)?, Some("X_LE_Y"))?;
    sess.assert(sess.ctx().le(y, x)?, Some("Y_LE_X"))?;

    sess.assert(sess.not(sess.eq(gx, gy)?)?, Some("GX_NE_GY"))?;
    Ok(())
}

fn setup_ping_pong_instance(sess: &mut smt_api::Session) -> smt_core::Result<()> {
    let u = sess.declare_uninterpreted_sort("U");
    let int = sess.ctx().int_sort();

    let a = sess.declare_const("a", u);
    let b = sess.declare_const("b", u);

    let x = sess.declare_const("x", int);
    let y = sess.declare_const("y", int);

    let f = sess.declare_ufun("f"); // U -> Int
    let g = sess.declare_ufun("g"); // Int -> U

    let fa = sess.app_uf(f, &[a], int)?;
    let fb = sess.app_uf(f, &[b], int)?;
    let gx = sess.app_uf(g, &[x], u)?;
    let gy = sess.app_uf(g, &[y], u)?;

    sess.assert(sess.eq(a, b)?, Some("A_EQ_B"))?;

    // x = f(a)
    sess.assert(sess.ctx().le(x, fa)?, Some("X_LE_FA"))?;
    sess.assert(sess.ctx().le(fa, x)?, Some("FA_LE_X"))?;

    // y = f(b)
    sess.assert(sess.ctx().le(y, fb)?, Some("Y_LE_FB"))?;
    sess.assert(sess.ctx().le(fb, y)?, Some("FB_LE_Y"))?;

    sess.assert(sess.not(sess.eq(gx, gy)?)?, Some("GX_NE_GY"))?;
    Ok(())
}
```

---

## 6) Notes to keep tests stable

* If your UNSAT core extraction returns a smaller core, don’t assert every label.
  Use a minimal “must contain” set (I used 2–3 labels).
* If core sometimes excludes one label due to a different proof path, weaken assertions:

  * e.g. for the ping-pong test, check it contains `GX_NE_GY` plus **at least one** of the equality-chain labels.

---

## 7) If you prefer feature flags (compile-time) instead of runtime config

You can put:

* `cfg(feature = "share-uf-dl")`
* `cfg(feature = "share-dl-uf")`

around the `allow` checks in the engine.
But runtime config is nicer for a matrix test in one compilation.

---

If you want, say **yes** and I’ll show the tiny UF `atom_endpoints` update (include UF-app args) and the UF export bucket logic (export shared app equalities by representative) in code form, because those two are what make the DL→UF and ping-pong tests pass reliably.
