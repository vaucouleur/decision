Below is the **minimal, solid assumption-UNSAT-core** support you can add to `ToyCdcl`, and then how to map it back to **exact asserted SMT terms** via `act_assert -> TermId`.

This is the classic “assumption core from final conflict clause” approach (MiniSAT-ish). It’s **sound**, usually small, and easy.

---

# Part A — `ToyCdcl`: store assumptions and extract an UNSAT core

## 1) Add fields

In `ToyCdcl`:

```rust
    // Assumptions for the last solve call (engine passes them via enqueue as decisions).
    cur_assumptions: Vec<Lit>,

    // Extracted unsat core (subset of cur_assumptions) from the last UNSAT result.
    last_unsat_core: Vec<Lit>,
```

Initialize in `new()` and clear in `reset_search_state()`.

---

## 2) Mark assumption enqueues

You need a way for the engine to tell the kernel “this decision literal is an assumption”.

Simplest: add a dedicated method on the kernel (recommended):

### `SatKernel` extension

```rust
fn enqueue_assumption(&mut self, lit: Lit) -> bool;
fn last_unsat_core(&self) -> Option<&[Lit]>;
```

If you don’t want to touch the trait, you can do it with a convention:

* engine enqueues assumptions at decision level 1 and calls `sat.set_assumptions(Vec<Lit>)`
  …but explicit is cleaner.

### Implement in `ToyCdcl`

Add:

```rust
impl ToyCdcl {
    /// Enqueue an assumption literal (treated as a decision) and record it.
    pub fn enqueue_assumption(&mut self, lit: Lit) -> bool {
        self.cur_assumptions.push(lit);
        self.enqueue_with_reason(lit, None)
    }

    pub fn last_unsat_core(&self) -> Option<&[Lit]> {
        if self.last_unsat_core.is_empty() {
            None
        } else {
            Some(&self.last_unsat_core)
        }
    }
}
```

---

## 3) Extract core on UNSAT-at-level-0

In your `SatKernel::propagate()` implementation for `ToyCdcl`, you already loop:

* propagate
* if conflict:

  * if level == 0 => UNSAT

At that point, compute core:

### Add helper: `extract_unsat_core_from_conflict(conflict_clause)`

```rust
impl ToyCdcl {
    /// Extract a (sound) assumption UNSAT core from a conflict clause by:
    /// - analyzing conflict to get a learned clause
    /// - selecting assumption literals whose vars appear in that clause
    ///
    /// Works best when assumptions are at dedicated levels (common pattern).
    fn extract_unsat_core(&self, conflict: ClauseRef) -> Vec<Lit> {
        if self.cur_assumptions.is_empty() {
            return Vec::new();
        }

        let (learned, _bj, _asserting) = self.analyze_conflict(conflict);

        // Map assumption vars -> the exact assumed literal.
        let mut amap = vec![None; self.num_vars as usize];
        for &a in &self.cur_assumptions {
            amap[a.var().as_u32() as usize] = Some(a);
        }

        let mut core = Vec::new();
        for &lit in learned.iter() {
            if let Some(a) = amap[lit.var().as_u32() as usize] {
                core.push(a);
            }
        }

        // Fallback: if we somehow failed, return all assumptions (still sound).
        if core.is_empty() {
            core.extend_from_slice(&self.cur_assumptions);
        }

        // Optional: dedup (rarely needed)
        core.sort();
        core.dedup();

        core
    }
}
```

Now patch `SatKernel::propagate()` loop:

When you hit UNSAT at level 0, do:

```rust
if self.decision_level() == 0 {
    self.last_unsat_core = self.extract_unsat_core(conflict);
    return Err(Conflict { clause: conflict });
}
```

Also clear cores at the start of a solve / reset:

```rust
self.last_unsat_core.clear();
self.cur_assumptions.clear();
```

---

## 4) Ensure assumptions are “visible” as assumptions

The core extraction relies on `cur_assumptions` being filled and stable during the solve.

So in the SMT engine, replace:

```rust
self.sat.enqueue(a, None);
```

with:

```rust
self.sat.enqueue_assumption(a);
```

And call it only for your `act_scope` and `act_assert` literals.

---

# Part B — Map core literals back to asserted SMT terms

You want: **which assertions caused UNSAT**.

## 1) Store an activation-literal → assertion metadata map

In your SMT engine, when you create `act_assert`, store:

```rust
struct AssertionInfo {
    term: smt_core::BoolTerm,
    // optional: source location, user label, etc.
}

assert_map: HashMap<Lit, AssertionInfo, FxBuild>
```

When you `assert_term_scoped(term)`:

* you already propositionalize to get `root`
* you create `act_assert`
* add clause `(¬act_scope ∨ ¬act_assert ∨ root)`
* store `assert_map.insert(act_assert, AssertionInfo { term })`

Note: store the *positive* activation literal (the one you assume true).

## 2) On UNSAT, collect core and translate

Add to engine:

```rust
pub fn unsat_core_assertions(&self) -> Option<Vec<smt_core::BoolTerm>> {
    let core = self.sat.last_unsat_core()?;
    let mut out = Vec::new();

    for &lit in core {
        // We only care about assertion activations; scope activations are optional.
        if let Some(info) = self.assert_map.get(&lit) {
            out.push(info.term);
        }
    }

    if out.is_empty() { None } else { Some(out) }
}
```

If you also want to include scope activations (coarser core), keep a `scope_map: HashMap<Lit, ScopeId>` too.

---

# Part C — Make core quality better with one tiny improvement

The learned clause used for core extraction depends on the last conflict you analyzed. Better is:

* when UNSAT at level 0 under assumptions, compute the conflict clause after full CDCL analysis at level 0, which you already do.

What we’re doing is already that: `analyze_conflict(conflict)` gives you a clause that is implied by the formula and falsified by assumptions.

This is the standard mechanism; it produces a sound subset core.

---

# What you get now

* Assertion-level activations enable **precise UNSAT cores** (subset of assertions).
* Extraction is cheap and easy, no proof logging required.
* Works seamlessly with CDCL(T): theory conflicts generate clauses; SAT learns; final learned clause yields assumption core.

---

If you say **yes** again, I’ll show a compact “public” API for your whole solver that looks like a real SMT solver:

```rust
engine.push();
engine.assert(term, Some("label"));
match engine.check_sat() {
  Sat => ...
  Unsat => engine.get_unsat_core_labels()
}
engine.pop(1);
```

…and how to keep propositionalization incremental across multiple asserts (single global term→var map, no re-Tseitin).
