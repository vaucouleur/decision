Alright—here are the two missing “real SMT” pieces in a form that stays modular and *pleasant* in Rust:

1. a **propositionalizer** that:

   * Tseitin-encodes Boolean structure
   * treats **theory atoms as propositional leaves**
   * builds an `AtomTable` (SAT `Var` → `Atom { term, theory }`)

2. a minimal **UF theory** (congruence closure-ish) that:

   * consumes assignments of equality atoms (`(= a b)` true/false)
   * maintains a rollbackable union-find
   * produces **propagations/conflicts with explanations as SAT literals**

I’ll give you concrete file-level code.

---

# 0) Make Tseitin treat “unknown Bool ops” as atoms

Your current Tseitin rejects everything except `not/and/or`. For SMT you want:

* `and/or/not` => encoded structurally
* everything else returning Bool (e.g. `=` over non-bool, `<`, `p(x)`) => **atom leaf**

Patch in `crates/smt-preprocess/src/tseitin.rs` inside `TermKind::App { op, args }`:

```rust
match op.kind {
    OpKind::Not => { /* as before */ }
    OpKind::And => { /* as before */ }
    OpKind::Or  => { /* as before */ }

    // Everything else that returns Bool is treated as an atom:
    // allocate a SAT var for it but do NOT add defining clauses here.
    _other => {
        // no clauses
    }
}
```

That’s the key “split”: Boolean structure vs theory atoms.

---

# 1) Propositionalizer (CNF + atom table)

### `crates/smt-engine/src/propositionalize.rs`

```rust
//! Propositionalization: Boolean structure → CNF, theory predicates → atoms (SAT vars).
//!
//! - Boolean connectives are Tseitin-encoded into CNF.
//! - Boolean terms that are NOT connectives become leaf atoms (SAT vars).
//! - We build an AtomTable: Var -> (TermId, TheoryId).

use smt_core::{BoolTerm, Context, SortKind, TermId, TermKind};
use smt_preprocess::{TseitinEncoder, TseitinOutput};
use smt_sat::{Var};

use crate::atoms::{Atom, AtomTable, TheoryId};

/// Output of propositionalization.
#[derive(Debug)]
pub struct Propositionalization {
    pub cnf: smt_sat::Cnf,
    pub root: smt_sat::Lit,
    pub term_to_var: hashbrown::HashMap<TermId, Var, core::hash::BuildHasherDefault<rustc_hash::FxHasher>>,
    pub atoms: AtomTable,
}

/// Classifies boolean terms into “theory atoms” (owned by some theory) vs “pure boolean”.
pub trait AtomClassifier {
    /// Return owning theory id if `t` is a theory atom, otherwise None.
    fn classify_bool_term(&self, ctx: &Context, t: TermId) -> Option<TheoryId>;
}

/// A simple default classifier:
/// - UF atoms: (= a b) where a/b are NOT Bool and look like UF terms
/// (you can extend with LIA/BV/Arrays later)
pub struct DefaultClassifier {
    pub uf: TheoryId,
}

impl DefaultClassifier {
    pub fn new(uf: TheoryId) -> Self {
        Self { uf }
    }
}

impl AtomClassifier for DefaultClassifier {
    fn classify_bool_term(&self, ctx: &Context, t: TermId) -> Option<TheoryId> {
        let (k, s) = ctx.term_node(t);
        if s != ctx.bool_sort() {
            return None;
        }
        let TermKind::App { op, args } = k else {
            // Bool vars are *not* theory atoms by default.
            return None;
        };

        match op.kind {
            smt_core::OpKind::Eq => {
                if args.len() != 2 {
                    return None;
                }
                let a = args[0];
                let b = args[1];
                let sa = ctx.term_sort(a);
                let sb = ctx.term_sort(b);
                if sa != sb || sa == ctx.bool_sort() {
                    return None; // Bool equality we treat as pure boolean (optional policy)
                }

                // UF owns equalities over uninterpreted sorts / UF terms.
                if looks_like_uf_term(ctx, a) || looks_like_uf_term(ctx, b) {
                    Some(self.uf)
                } else {
                    None
                }
            }
            _ => None,
        }
    }
}

/// Heuristic: term is a UF term if:
/// - sort is uninterpreted, OR
/// - it is an application of an uninterpreted function symbol (`OpKind::Uf`)
fn looks_like_uf_term(ctx: &Context, t: TermId) -> bool {
    match ctx.sort_kind(ctx.term_sort(t)) {
        SortKind::Uninterpreted { .. } => true,
        _ => {
            let (k, _) = ctx.term_node(t);
            matches!(k, TermKind::App { op, .. } if matches!(op.kind, smt_core::OpKind::Uf(_)))
        }
    }
}

/// Propositionalize a boolean root.
pub fn propositionalize(
    ctx: &Context,
    root: BoolTerm,
    classifier: &dyn AtomClassifier,
) -> smt_core::Result<Propositionalization> {
    let out: TseitinOutput = TseitinEncoder::new().encode(ctx, root)?;

    // Build atom table from the term->var map.
    let mut atoms = AtomTable::default();
    for (&term, &var) in out.term_to_var.iter() {
        if let Some(th) = classifier.classify_bool_term(ctx, term) {
            atoms.insert(var, Atom { term, theory: th });
        }
    }

    Ok(Propositionalization {
        cnf: out.cnf,
        root: out.root,
        term_to_var: out.term_to_var,
        atoms,
    })
}
```

Add it to `crates/smt-engine/src/lib.rs` exports:

```rust
mod propositionalize;
pub use propositionalize::{propositionalize, AtomClassifier, DefaultClassifier, Propositionalization};
```

---

# 2) UF theory (with explanations as SAT literals)

This is a minimal-but-correct shape:

* The only atoms UF cares about: equality terms `Eq(lhs, rhs)` (assigned true/false).
* It keeps:

  * rollbackable union-find (no path compression; union-by-rank)
  * a reason edge per union (points to a `ReasonId` that stores `Vec<Lit>`)
  * a list of disequalities from “(= a b) = false”
  * a signature table for congruence (very simple rebuild-per-propagate)

### `crates/smt-engine/src/theories/uf.rs`

```rust
//! UF theory: congruence closure-ish with explanations.
//!
//! Atoms: (= a b) where a/b are UF terms (uninterpreted sort / Uf apps).
//! Assignments:
//! - atom true  => assert equality (union)
//! - atom false => assert disequality; conflict if classes already equal
//!
//! Propagation:
//! - if classes become equal, any equality atom between them can be implied true
//! - if some equality atom is assigned false but classes are equal => conflict

use hashbrown::HashMap;
use rustc_hash::FxHasher;
use core::hash::BuildHasherDefault;

use smt_core::{Context, TermId, TermKind};
use smt_sat::{Lit, Var};

use crate::atoms::TheoryId;
use crate::theory::{Theory, TheoryConflict, TheoryPropagation};

type FxBuild = BuildHasherDefault<FxHasher>;

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
struct NodeId(u32);

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
struct ReasonId(u32);

#[derive(Debug, Clone)]
struct AtomInfo {
    var: Var,
    lhs: TermId,
    rhs: TermId,
    /// Current SAT-level assignment for this atom (as notified by engine).
    value: Option<bool>,
}

/// Rollback point for push/pop.
#[derive(Debug, Clone, Copy)]
struct UfCheckpoint {
    uf_trail_len: usize,
    diseq_len: usize,
}

/// A UF theory instance.
///
/// Notes:
/// - we do NOT use path compression (so explanations and rollback are simpler).
/// - union edges are labeled by ReasonId, which stores a Vec<Lit>.
pub struct UfTheory<'a> {
    ctx: &'a Context,
    id: TheoryId,

    // TermId (UF term) -> NodeId
    term_to_node: HashMap<TermId, NodeId, FxBuild>,
    nodes: Vec<TermId>,

    parent: Vec<NodeId>,
    rank: Vec<u8>,
    // reason for the edge: node -> parent[node]
    parent_reason: Vec<Option<ReasonId>>,

    // Reason store: ReasonId -> Vec<Lit>
    reasons: Vec<Vec<Lit>>,

    // Rollback trail for union operations:
    // (node, old_parent, old_rank, old_reason)
    uf_trail: Vec<(NodeId, NodeId, u8, Option<ReasonId>)>,

    // Disequalities asserted (from atom=false):
    // each record: (a_node, b_node, reason_lits)
    diseqs: Vec<(NodeId, NodeId, Vec<Lit>)>,

    // Atoms owned by UF: term (= lhs rhs) -> AtomInfo
    atoms: HashMap<TermId, AtomInfo, FxBuild>,

    // push/pop checkpoints
    scopes: Vec<UfCheckpoint>,

    // UF terms that are function applications, for congruence processing
    uf_apps: Vec<TermId>,
}

impl<'a> UfTheory<'a> {
    pub fn new(ctx: &'a Context, id: TheoryId) -> Self {
        Self {
            ctx,
            id,
            term_to_node: HashMap::default(),
            nodes: Vec::new(),
            parent: Vec::new(),
            rank: Vec::new(),
            parent_reason: Vec::new(),
            reasons: Vec::new(),
            uf_trail: Vec::new(),
            diseqs: Vec::new(),
            atoms: HashMap::default(),
            scopes: vec![UfCheckpoint { uf_trail_len: 0, diseq_len: 0 }],
            uf_apps: Vec::new(),
        }
    }

    /// Register an equality atom term owned by UF.
    ///
    /// `term` is the Bool term of the equality `(= lhs rhs)`, and `var` is its SAT var.
    pub fn register_eq_atom(&mut self, term: TermId, var: Var) -> smt_core::Result<()> {
        let (lhs, rhs) = parse_eq_atom(self.ctx, term)?;

        // Ensure UF nodes exist for lhs/rhs (and subterms, e.g. uf apps).
        self.ensure_uf_term(lhs);
        self.ensure_uf_term(rhs);

        self.atoms.insert(term, AtomInfo { var, lhs, rhs, value: None });
        Ok(())
    }

    /// Ensure a UF term is tracked.
    fn ensure_uf_term(&mut self, t: TermId) -> NodeId {
        if let Some(&n) = self.term_to_node.get(&t) {
            return n;
        }

        let nid = NodeId(self.nodes.len() as u32);
        self.term_to_node.insert(t, nid);
        self.nodes.push(t);

        self.parent.push(nid);
        self.rank.push(0);
        self.parent_reason.push(None);

        // Track UF applications for congruence.
        let (k, _) = self.ctx.term_node(t);
        if matches!(k, TermKind::App { op, .. } if matches!(op.kind, smt_core::OpKind::Uf(_))) {
            self.uf_apps.push(t);
        }

        // Also ensure UF subterms exist (arguments of Uf apps).
        if let TermKind::App { op, args } = k {
            if matches!(op.kind, smt_core::OpKind::Uf(_)) {
                for &a in args.iter() {
                    self.ensure_uf_term(a);
                }
            }
        }

        nid
    }

    fn find(&self, mut x: NodeId) -> NodeId {
        while self.parent[x.0 as usize] != x {
            x = self.parent[x.0 as usize];
        }
        x
    }

    /// Add a reason vector and return ReasonId.
    fn mk_reason(&mut self, lits: Vec<Lit>) -> ReasonId {
        let id = ReasonId(self.reasons.len() as u32);
        self.reasons.push(lits);
        id
    }

    /// Union with rollback, labeling the edge with a reason.
    fn union(&mut self, a: NodeId, b: NodeId, reason: Vec<Lit>) {
        let mut ra = self.find(a);
        let mut rb = self.find(b);
        if ra == rb {
            return;
        }

        // Union by rank.
        let (rka, rkb) = (self.rank[ra.0 as usize], self.rank[rb.0 as usize]);
        if rka > rkb {
            core::mem::swap(&mut ra, &mut rb);
        }

        // Save old state for rollback.
        let rb_idx = rb.0 as usize;
        let old_parent = self.parent[ra.0 as usize];
        let old_rank = self.rank[rb_idx];
        let old_reason = self.parent_reason[ra.0 as usize];

        self.uf_trail.push((ra, old_parent, old_rank, old_reason));

        // Attach ra under rb.
        self.parent[ra.0 as usize] = rb;
        self.parent_reason[ra.0 as usize] = Some(self.mk_reason(reason));

        // Update rank if equal.
        if rka == rkb {
            self.rank[rb_idx] = old_rank.saturating_add(1);
        }
    }

    /// Explain why two nodes are equal (collect literals along paths to LCA).
    ///
    /// Not minimal, but sound. Requires no path compression.
    fn explain_eq(&self, a: NodeId, b: NodeId) -> Vec<Lit> {
        let ra = self.find(a);
        let rb = self.find(b);
        if ra != rb {
            return Vec::new();
        }

        // Collect ancestors of a: node -> index in path.
        let mut anc = HashMap::<NodeId, usize, FxBuild>::default();
        let mut path_a: Vec<(NodeId, Option<ReasonId>)> = Vec::new();

        let mut x = a;
        while self.parent[x.0 as usize] != x {
            anc.insert(x, path_a.len());
            path_a.push((x, self.parent_reason[x.0 as usize]));
            x = self.parent[x.0 as usize];
        }
        anc.insert(x, path_a.len()); // root
        // Traverse b upward until common ancestor.
        let mut path_b: Vec<(NodeId, Option<ReasonId>)> = Vec::new();
        let mut y = b;
        let lca: NodeId;
        loop {
            if anc.contains_key(&y) {
                lca = y;
                break;
            }
            path_b.push((y, self.parent_reason[y.0 as usize]));
            y = self.parent[y.0 as usize];
        }

        // Collect reasons from a up to lca.
        let mut out: Vec<Lit> = Vec::new();
        let mut cur = a;
        while cur != lca {
            if let Some(rid) = self.parent_reason[cur.0 as usize] {
                out.extend_from_slice(&self.reasons[rid.0 as usize]);
            }
            cur = self.parent[cur.0 as usize];
        }

        // Collect reasons from b up to lca.
        let mut cur = b;
        while cur != lca {
            if let Some(rid) = self.parent_reason[cur.0 as usize] {
                out.extend_from_slice(&self.reasons[rid.0 as usize]);
            }
            cur = self.parent[cur.0 as usize];
        }

        out
    }

    /// Rebuild congruence signatures and merge congruent applications.
    ///
    /// This is O(n log n) per call, but very simple and correct for a starter.
    fn congruence_closure_step(&mut self) {
        // signature: (f_sym, rep(arg1), rep(arg2), ...) -> representative term
        #[derive(Hash, PartialEq, Eq)]
        struct Sig {
            f: smt_core::SymbolId,
            args: Vec<NodeId>,
        }

        let mut table: HashMap<Sig, TermId, FxBuild> = HashMap::default();

        for &app in &self.uf_apps {
            let (k, _) = self.ctx.term_node(app);
            let TermKind::App { op, args } = k else { continue };
            let smt_core::OpKind::Uf(f) = op.kind else { continue };

            let mut sig_args = Vec::with_capacity(args.len());
            for &a in args.iter() {
                let na = self.ensure_uf_term(a);
                sig_args.push(self.find(na));
            }

            let sig = Sig { f, args: sig_args };

            if let Some(&other) = table.get(&sig) {
                // app == other by congruence
                let na = self.ensure_uf_term(app);
                let nb = self.ensure_uf_term(other);

                // Reason: equalities of corresponding args
                let mut reason: Vec<Lit> = Vec::new();
                if let TermKind::App { args: a_args, .. } = self.ctx.term_node(app).0 {
                    if let TermKind::App { args: b_args, .. } = self.ctx.term_node(other).0 {
                        for (&aa, &bb) in a_args.iter().zip(b_args.iter()) {
                            let naa = self.ensure_uf_term(aa);
                            let nbb = self.ensure_uf_term(bb);
                            reason.extend(self.explain_eq(naa, nbb));
                        }
                    }
                }

                self.union(na, nb, reason);
            } else {
                table.insert(sig, app);
            }
        }
    }

    /// Check disequalities for conflicts.
    fn check_diseqs(&self) -> Option<TheoryConflict> {
        for (a, b, why) in &self.diseqs {
            if self.find(*a) == self.find(*b) {
                // Conflict explanation: why (diseq literal) + equality explanation
                let mut explain = self.explain_eq(*a, *b);
                explain.extend_from_slice(why);
                return Some(TheoryConflict { explain });
            }
        }
        None
    }

    /// Try to propagate equality atoms whose endpoints are now equal.
    fn propagate_equalities(&self) -> Vec<TheoryPropagation> {
        let mut out = Vec::new();

        for (_term, info) in self.atoms.iter() {
            let a = self.term_to_node[&info.lhs];
            let b = self.term_to_node[&info.rhs];
            let eq_now = self.find(a) == self.find(b);

            match (info.value, eq_now) {
                (None, true) => {
                    // We can imply (= lhs rhs) is true.
                    let explain = self.explain_eq(a, b);
                    out.push(TheoryPropagation {
                        implied: Lit::pos(info.var),
                        explain,
                    });
                }
                (Some(false), true) => {
                    // Conflict: atom says false but UF says equal.
                    // Engine will surface this via `propagate()` returning Err.
                    // (Handled in propagate(); we don’t return propagations here.)
                }
                _ => {}
            }
        }

        out
    }
}

impl<'a> Theory for UfTheory<'a> {
    fn name(&self) -> &'static str {
        "UF"
    }

    fn push(&mut self) {
        self.scopes.push(UfCheckpoint {
            uf_trail_len: self.uf_trail.len(),
            diseq_len: self.diseqs.len(),
        });
    }

    fn pop(&mut self, n: usize) {
        for _ in 0..n {
            if self.scopes.len() <= 1 {
                return; // keep base scope
            }
            let cp = self.scopes.pop().expect("non-empty");

            // rollback diseqs
            self.diseqs.truncate(cp.diseq_len);

            // rollback union-find changes
            while self.uf_trail.len() > cp.uf_trail_len {
                let (node, old_parent, old_rank, old_reason) = self.uf_trail.pop().unwrap();
                let i = node.0 as usize;
                self.parent[i] = old_parent;
                self.parent_reason[i] = old_reason;
                // old_rank was stored for the parent root used in union; in this simplified trail,
                // we store it as "rank of current parent", so update that slot:
                let p = self.parent[i].0 as usize;
                self.rank[p] = old_rank;
            }

            // atom values should also roll back in a full incremental SMT.
            // For now we keep values as “last notified” (engine typically recreates per solve).
        }
    }

    fn on_atom_assigned(&mut self, atom_term: TermId, value: bool) {
        let Some(info) = self.atoms.get_mut(&atom_term) else { return };
        info.value = Some(value);

        let a = self.ensure_uf_term(info.lhs);
        let b = self.ensure_uf_term(info.rhs);

        if value {
            // Assert equality: reason is the atom literal itself.
            self.union(a, b, vec![Lit::pos(info.var)]);
        } else {
            // Assert disequality: reason is ¬(= lhs rhs) literal.
            self.diseqs.push((a, b, vec![Lit::neg(info.var)]));
        }
    }

    fn propagate(&mut self) -> Result<Vec<TheoryPropagation>, TheoryConflict> {
        // 1) Congruence closure merges (can create new equalities).
        self.congruence_closure_step();

        // 2) Check disequalities.
        if let Some(conf) = self.check_diseqs() {
            return Err(conf);
        }

        // 3) If any equality atom is assigned false but endpoints are equal => conflict.
        for (_term, info) in self.atoms.iter() {
            if info.value == Some(false) {
                let a = self.term_to_node[&info.lhs];
                let b = self.term_to_node[&info.rhs];
                if self.find(a) == self.find(b) {
                    let mut explain = self.explain_eq(a, b);
                    explain.push(Lit::neg(info.var));
                    return Err(TheoryConflict { explain });
                }
            }
        }

        // 4) Propagate implied equality atoms.
        Ok(self.propagate_equalities())
    }
}

/// Parse a Bool equality term `(= lhs rhs)` into endpoints.
fn parse_eq_atom(ctx: &Context, t: TermId) -> smt_core::Result<(TermId, TermId)> {
    let (k, s) = ctx.term_node(t);
    if s != ctx.bool_sort() {
        return Err(smt_core::Error::SortError("expected Bool equality atom".into()));
    }
    let TermKind::App { op, args } = k else {
        return Err(smt_core::Error::SortError("expected application for equality atom".into()));
    };
    if !matches!(op.kind, smt_core::OpKind::Eq) || args.len() != 2 {
        return Err(smt_core::Error::SortError("expected (= a b)".into()));
    }
    Ok((args[0], args[1]))
}
```

### Where does `register_eq_atom` get called?

In the engine setup phase, right after propositionalization, for each atom owned by UF:

* look up `Var` from `term_to_var[atom_term]`
* call `uf.register_eq_atom(atom_term, var)`

---

# 3) Wiring it together (example)

### Engine setup (pseudo-code using your earlier pieces)

```rust
use smt_core::prelude::*;
use smt_engine::{propositionalize, DefaultClassifier, TheoryId};
use smt_engine::theories::uf::UfTheory;
use smt_sat::ToyCdcl;

// Suppose root is a BoolTerm you want to solve.
fn solve_with_uf(ctx: &Context, root: BoolTerm) -> Result<()> {
    let uf_id = TheoryId(0);
    let classifier = DefaultClassifier::new(uf_id);

    let prop = propositionalize(ctx, root, &classifier)?;

    // Build UF theory and register its atoms:
    let mut uf = UfTheory::new(ctx, uf_id);
    for (&term, &var) in prop.term_to_var.iter() {
        if classifier.classify_bool_term(ctx, term) == Some(uf_id) {
            uf.register_eq_atom(term, var)?;
        }
    }

    // SAT kernel:
    let mut sat = ToyCdcl::new();
    sat.reserve_vars(prop.cnf.num_vars);
    for c in prop.cnf.clauses {
        sat.add_clause(c);
    }
    // Enforce root true:
    sat.add_clause(vec![prop.root]);

    // Now run a CDCL(T) loop (your engine would do this),
    // interleaving sat.propagate() and uf.propagate().
    // (I’m not repeating the whole loop here; it’s the same structure as earlier.)

    Ok(())
}
```

---

# The key architectural takeaway

This combo scales extremely well:

* **Propositionalizer** owns “what becomes SAT structure vs atom”.
* `AtomTable` is your stable bridge: SAT `Var` → SMT `TermId` atom → owning theory.
* **Theories never need to see raw CNF**. They only talk in:

  * assignments of their atoms
  * implied literals with explanations (`Vec<Lit>`)
  * conflicts with explanations (`Vec<Lit>`)

That makes the whole system both customizable *and* safe.

---

If you want the next piece: say **yes** and I’ll show a clean CDCL(T) loop that works with your *SAT-kernel-with-learning* (so the engine doesn’t reimplement CDCL), including:

* using `add_clause_return_index()` so theory propagations can be enqueued with a proper reason,
* activation literals for backtrackable theory lemmas,
* and how `push/pop` maps to SAT decision levels in a predictable way.
