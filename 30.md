Below is a **minimal, clean `ReasonArena`** that lives in the engine and is shared by all theories, so UF and DL can exchange **fully sound explanations** without “pick first literal” hacks.

You’ll get:

* a shared `ReasonArena` (`ReasonId` handles)
* theory interfaces that use `ReasonId` instead of `Vec<Lit>`
* engine expands reasons only when emitting SAT clauses
* UF and DL both store *reason handles* on union edges / graph edges
* equality sharing imports/exports carry a single `ReasonId`

This is the same architectural shape used by serious solvers (proof objects are DAGs).

---

# 1) `ReasonArena`: engine-owned DAG of reasons

### `crates/smt-engine/src/reason.rs`

```rust
#![forbid(unsafe_code)]

use hashbrown::HashSet;
use rustc_hash::FxHasher;
use core::hash::BuildHasherDefault;

use smt_sat::Lit;

type FxBuild = BuildHasherDefault<FxHasher>;

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ReasonId(pub u32);

#[derive(Debug, Clone)]
pub enum Reason {
    /// Single SAT literal.
    Atom(Lit),

    /// Conjunction of reasons.
    And(Vec<ReasonId>),
}

/// Engine-owned arena. Theories store ReasonId handles.
#[derive(Default)]
pub struct ReasonArena {
    reasons: Vec<Reason>,
}

impl ReasonArena {
    pub fn new() -> Self {
        Self { reasons: Vec::new() }
    }

    pub fn atom(&mut self, lit: Lit) -> ReasonId {
        let id = ReasonId(self.reasons.len() as u32);
        self.reasons.push(Reason::Atom(lit));
        id
    }

    pub fn and(&mut self, kids: Vec<ReasonId>) -> ReasonId {
        let id = ReasonId(self.reasons.len() as u32);
        self.reasons.push(Reason::And(kids));
        id
    }

    /// Expand into a deduped list of SAT literals.
    pub fn expand_lits(&self, rid: ReasonId) -> Vec<Lit> {
        let mut out = Vec::new();
        let mut seen: HashSet<Lit, FxBuild> = HashSet::default();
        self.expand_rec(rid, &mut seen, &mut out);
        out
    }

    fn expand_rec(&self, rid: ReasonId, seen: &mut HashSet<Lit, FxBuild>, out: &mut Vec<Lit>) {
        match &self.reasons[rid.0 as usize] {
            Reason::Atom(l) => {
                if seen.insert(*l) {
                    out.push(*l);
                }
            }
            Reason::And(kids) => {
                for &k in kids {
                    self.expand_rec(k, seen, out);
                }
            }
        }
    }
}
```

---

# 2) Update theory structs to use `ReasonId`

## 2.1 Replace `Vec<Lit>` in `TheoryPropagation`/`TheoryConflict`

### `crates/smt-engine/src/theory.rs`

```rust
use smt_core::TermId;
use smt_sat::Lit;

use crate::reason::ReasonId;

#[derive(Debug, Clone)]
pub struct TheoryPropagation {
    pub implied: Lit,
    pub explain: ReasonId,
}

#[derive(Debug, Clone)]
pub struct TheoryConflict {
    pub explain: ReasonId,
}

#[derive(Debug, Clone)]
pub struct SharedEq {
    pub a: TermId,
    pub b: TermId,
    pub explain: ReasonId,
}

pub trait EqualitySharing {
    fn export_equalities(
        &mut self,
        shared: &hashbrown::HashSet<TermId, core::hash::BuildHasherDefault<rustc_hash::FxHasher>>,
    ) -> Vec<SharedEq>;

    fn import_equality(&mut self, eq: SharedEq);
}

pub trait Theory {
    fn name(&self) -> &'static str;

    fn push_scope(&mut self);
    fn pop_scope(&mut self, n: usize);

    fn push_level(&mut self);
    fn pop_levels(&mut self, n: usize);

    fn on_atom_assigned(&mut self, atom_term: TermId, value: bool);

    fn propagate(&mut self) -> Result<Vec<TheoryPropagation>, TheoryConflict>;

    fn equality_sharing_mut(&mut self) -> Option<&mut dyn EqualitySharing> { None }

    fn atom_endpoints(&self, _atom_term: TermId) -> Vec<TermId> { Vec::new() }
}
```

---

# 3) Give theories access to the arena: `TheoryCtx`

We don’t want theories to own the arena; they need a handle to allocate reason nodes.

Make a lightweight context object passed by the engine.

### `crates/smt-engine/src/theory_ctx.rs`

```rust
use crate::reason::{ReasonArena, ReasonId};
use smt_sat::Lit;

/// Context passed to theories so they can allocate reason nodes.
pub struct TheoryCtx<'a> {
    arena: &'a mut ReasonArena,
}

impl<'a> TheoryCtx<'a> {
    pub fn new(arena: &'a mut ReasonArena) -> Self {
        Self { arena }
    }

    pub fn r_atom(&mut self, lit: Lit) -> ReasonId {
        self.arena.atom(lit)
    }

    pub fn r_and(&mut self, kids: Vec<ReasonId>) -> ReasonId {
        self.arena.and(kids)
    }
}
```

Now update `Theory` methods that produce explanations to accept `&mut TheoryCtx`:

### `Theory` signature change

```rust
fn on_atom_assigned(&mut self, t: TermId, value: bool, tcx: &mut TheoryCtx);
fn propagate(&mut self, tcx: &mut TheoryCtx) -> Result<Vec<TheoryPropagation>, TheoryConflict>;
```

Same for equality-sharing methods if they need to build reasons.

This change is worth it: now *all* explanations are reason handles.

---

# 4) Engine expands reasons to SAT clauses

When the engine gets a propagation:

* it has `p.explain: ReasonId`
* it expands to lits using `arena.expand_lits(p.explain)`
* it emits clause `(¬explain_lits... ∨ implied)`

### `crates/smt-engine/src/engine_ctx.rs` helpers now accept `&[Lit]` as before.

In the engine:

```rust
let explain_lits = self.reasons.expand_lits(p.explain);
let lemma = implication_clause(&explain_lits, p.implied);
```

For conflict:

```rust
let explain_lits = self.reasons.expand_lits(conf.explain);
let lemma = conflict_clause(&explain_lits);
```

---

# 5) UF changes: replace its internal reason DAG with `ReasonId` from engine

This is a big simplification: UF no longer needs its own `Reason` enum. It just stores `ReasonId` on union edges.

In `UfCc`:

* `edge_reason: Vec<Option<ReasonId>>`
* when asserting equality atom:

  * reason is `tcx.r_atom(Lit::pos(var))`
* when congruence merges:

  * reason is `tcx.r_and(vec![ reason(arg1=arg1'), ... ])`

`UfCc::explain_eq(a,b)` returns a `ReasonId`:

* gather all `ReasonId`s on both paths
* return `tcx.r_and(kids)`

So UF becomes both smaller and more consistent.

---

# 6) DL changes: edges carry `ReasonId`

In DL:

```rust
struct Edge { to: NodeId, w: i64, why: ReasonId }
```

* When atom=true:

  * `why = tcx.r_atom(+var)`
* When atom=false:

  * `why = tcx.r_atom(-var)`
* When importing equality:

  * use the imported `ReasonId` directly as `why`
* Path reconstruction collects `ReasonId`s along edges and returns `tcx.r_and(kids)` (or just return a list and let engine AND them—either works)

Conflict cycle reconstruction similarly returns `tcx.r_and(kids)`.

---

# 7) Equality sharing now carries a single `ReasonId` (fully sound)

* UF exports `SharedEq { a, b, explain: rid }`
* DL imports using that exact `ReasonId`
* DL exports equalities with `ReasonId` built from path reasons
* UF imports unions with that `ReasonId`

No lossy conversions, no “first literal”, no duplicating large vectors everywhere.

---

# 8) Minimal integration checklist (practical)

If you implement this, do it in this order:

1. Introduce `ReasonArena` + `TheoryCtx`
2. Update engine to own `ReasonArena` and pass `TheoryCtx` to theory methods
3. Update UF theory first (easiest) to use `ReasonId`
4. Update DL theory edges to store `ReasonId`
5. Update equality-sharing API to pass `ReasonId` explanations
6. Add a regression demo:

   * UF implies equality, DL imports, DL conflicts due to constraints, core contains the original assumptions

---

If you say **yes**, I’ll give you the exact code diff for:

* the updated `Theory` trait signatures,
* the engine call sites (notify + propagate loops),
* and a minimal UF implementation that uses engine `ReasonArena` (no UF-local reason DAG).
