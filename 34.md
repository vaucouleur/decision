Here’s the **reverse-direction regression** where **DL must export an equality** that **UF needs** to become UNSAT. This complements the previous test and proves your equality-sharing loop is truly bidirectional.

---

# Goal

Make the formula UNSAT only if:

1. DL deduces `t1 = t2` (from arithmetic constraints), **exports** it, and
2. UF **imports** it, and then UF’s congruence/disequality creates the contradiction.

We’ll use:

* `U` uninterpreted sort
* `g : Int → U` (UF from Int to U)
* Int terms `x, y : Int`

Constraints:

### DL constraints (force x = y)

1. `x ≤ y`
2. `y ≤ x`

So DL entails `x = y`.

### UF constraints (contradiction if x=y)

3. `g(x) ≠ g(y)`

UF alone can’t refute `g(x) ≠ g(y)` unless it knows `x=y` (then congruence yields `g(x)=g(y)`).

So:

* without DL→UF equality sharing: **SAT**
* with DL exporting `x=y` and UF importing: **UNSAT**

---

# 1) Requirements / caveat

Your DL theory as written handles constraints of the form `t1 - t2 <= c` and can export equality `a=b` when it proves both directions `<=0`.

To make DL export `x=y`, you need `x` and `y` to be in the DL node set, which they are via atoms `x ≤ y` and `y ≤ x`.

Classifier must assign:

* `Le/Lt` on Int to DL
* `Eq` involving UF apps to UF (but here we don’t use Eq in DL)
* `g(x) ≠ g(y)` is a UF-owned negated equality atom (since it contains UF app).

Also: your UF theory must support disequality `(not (= gx gy))` as in the earlier UF theory (store diseqs and conflict if UF entails equality).

---

# 2) Session demo formula (pseudo-Rust)

### `crates/smt-demo/src/dl_to_uf_combo.rs`

```rust
use std::sync::Arc;

use smt_api::{Session, CheckSat};

fn main() -> smt_core::Result<()> {
    let ctx = Arc::new(smt_core::Context::default());
    let mut sess = build_session_with_uf_and_dl(ctx.clone());

    let int = sess.ctx().int_sort();

    // x, y : Int (these are just Int vars)
    let x = sess.declare_const("x", int);
    let y = sess.declare_const("y", int);

    // g : Int -> U
    let u = sess.declare_uninterpreted_sort("U");
    let g = sess.declare_ufun("g");

    let gx = sess.app_uf(g, &[x], u)?;
    let gy = sess.app_uf(g, &[y], u)?;

    // 1) x <= y   labeled "X_LE_Y"
    let x_le_y = sess.ctx().le(x, y)?;
    sess.assert(x_le_y, Some("X_LE_Y"))?;

    // 2) y <= x   labeled "Y_LE_X"
    let y_le_x = sess.ctx().le(y, x)?;
    sess.assert(y_le_x, Some("Y_LE_X"))?;

    // 3) g(x) != g(y)  labeled "GX_NE_GY"
    let eq_g = sess.eq(gx, gy)?;
    let neq_g = sess.not(eq_g)?;
    sess.assert(neq_g, Some("GX_NE_GY"))?;

    match sess.check_sat() {
        CheckSat::Sat => {
            println!("SAT (BUG: DL->UF equality sharing not working?)");
        }
        CheckSat::Unsat => {
            println!("UNSAT (expected)");
            println!("core: {:?}", sess.get_unsat_core());
        }
    }

    Ok(())
}
```

**Expected:** UNSAT and the core should include `X_LE_Y`, `Y_LE_X`, `GX_NE_GY` (or a subset).

---

# 3) Make sure DL exports `x=y` in a way UF recognizes

## 3.1 Shared-term detection must include `x` and `y`

* DL `atom_endpoints` returns `x` and `y` for both inequalities
* UF `atom_endpoints` for `g(x) != g(y)` returns `g(x)`, `g(y)`; that doesn’t include `x,y`
* But DL already sees `x,y` owned by DL only, so `compute_shared_terms()` as “>=2 theories” would NOT mark `x,y` as shared.

So for this regression, you need a slightly richer shared-term definition:

✅ A term is “shared” if:

* it appears in a DL atom, and
* it occurs as a subterm of a UF application that appears in a UF atom

In our case: `x` occurs inside `g(x)`.

### Minimal enhancement: “UF app arguments are shared endpoints”

Add in UF theory:

```rust
fn atom_endpoints(&self, atom_term: TermId) -> Vec<TermId> {
    // For (= gx gy) or its negation: include gx, gy AND also their arguments recursively (or at least direct args).
}
```

For UF atoms involving UF apps, include app arguments:

* endpoints: `gx, gy, x, y` (and deeper args if nested)

This makes `x` and `y` shared between UF and DL, so DL will export `x=y`.

**This is the key fix for DL→UF sharing.** It matches Nelson–Oppen: shared symbols are variables that occur in both theories.

## 3.2 Practical `atom_endpoints` for UF (include args)

In `UfTheory::atom_endpoints`:

```rust
fn atom_endpoints(&self, atom_term: TermId) -> Vec<TermId> {
    let Some(a) = self.atoms.get(&atom_term) else { return Vec::new(); };

    let mut out = vec![a.lhs, a.rhs];

    // If lhs/rhs contain UF apps, include their direct args (or recurse).
    self.collect_uf_app_args(a.lhs, &mut out);
    self.collect_uf_app_args(a.rhs, &mut out);

    out
}
```

And helper:

```rust
fn collect_uf_app_args(&self, t: TermId, out: &mut Vec<TermId>) {
    let (k, _) = self.ctx.term_node(t);
    if let TermKind::App { op, args } = k {
        if matches!(op.kind, smt_core::OpKind::Uf(_)) {
            for &a in args {
                out.push(a);
                // optionally recurse
                // self.collect_uf_app_args(a, out);
            }
        }
    }
}
```

Now `compute_shared_terms()` will mark `x` and `y` as shared (because they appear in UF endpoints and DL endpoints).

---

# 4) Make DL export equality only on shared terms

Your DL export already does:

* iterate over shared terms in DL nodes
* if both directions <= 0, export eq

With the above shared-term fix, DL will export `x=y`.

---

# 5) UF import of equality must merge Int terms too

Your UF congruence closure should be willing to “own” equality between Int terms if it comes via sharing.

That’s okay if UF treats TermIds uniformly regardless of sort, but you should ensure:

* `UfCc::ensure_term` registers nodes for any term (including Int vars), even if not UF apps.

It already does.

Then importing equality `x=y` will unify their classes in UF, and congruence over `g(·)` will unify `g(x)` and `g(y)`.

Then with diseq `g(x) != g(y)`, UF conflicts.

---

# 6) Expected UNSAT core

Typical UNSAT core labels:

* `X_LE_Y`
* `Y_LE_X`
* `GX_NE_GY`

If your solver returns a smaller or different core, that’s fine as long as it’s a subset of assertions implying UNSAT.

---

# Summary: why this regression is valuable

* The previous regression tested **UF ⇒ DL** sharing (congruence produces int equality needed by DL).
* This regression tests **DL ⇒ UF** sharing (arithmetic forces equality needed by UF to refute disequality).
* Together they validate:

  * shared-term detection isn’t too weak
  * equality-sharing loop is truly bidirectional
  * reasons survive roundtrips and still yield correct UNSAT and a sensible core

If you want, I can also provide a third regression where both directions are needed in one run (a tiny “ping-pong” instance), but these two are usually the best starting smoke tests.
