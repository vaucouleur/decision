Here’s the **third regression (“ping-pong”)** where you need **both directions** of equality sharing in the same run:

* **UF ⇒ DL** to create an arithmetic equality,
* then **DL ⇒ UF** to push an arithmetic-derived equality back into UF,
* and only then the contradiction appears.

It’s small, deterministic, and great for CI.

---

# Ping-pong idea

We’ll chain two UF functions:

* `f : U → Int`  (UF returns Int)
* `g : Int → U`  (UF returns U)

And Int vars/constants.

### Constraints

1. **UF**: `a = b`
2. **DL**: `f(a) ≤ 0`
3. **DL**: `f(b) ≥ 1`
   → with UF congruence, `a=b ⇒ f(a)=f(b)` (UF ⇒ DL), DL becomes inconsistent **unless** DL can use the imported equality. That already yields UNSAT, so we need to prevent DL from immediately conflicting and instead make it **deduce an equality**.

So we adjust the arithmetic so DL doesn’t conflict but instead *deduces* an equality:

Let DL constraints force `f(a) = 0` and `f(b) = 0` but it only learns `f(a)=f(b)` via UF.

Then DL can deduce `f(a)=f(b)` (trivial) and export it (not useful). We want DL to deduce **something new** that UF needs.

Instead, we use DL to deduce `x = f(a)` and `x = f(b)` and export `x = f(a)` or `x = f(b)` which UF uses to equate `g(x)` with `g(f(a))` etc. Still not a contradiction unless we add a diseq.

Better ping-pong:

* UF implies **an equality between Int terms** that DL needs to derive **another equality between Int terms**
* DL exports that equality back to UF, which triggers a UF contradiction.

We can do:

* UF gives `a=b` ⇒ `f(a)=f(b)` (Int equality shared into DL)
* DL constraints ensure `x = f(a)` and `y = f(b)`; with `f(a)=f(b)` it deduces `x=y`
* DL exports `x=y` back to UF
* UF has constraint `g(x) ≠ g(y)`; with `x=y`, UF implies `g(x)=g(y)` and conflicts.

This uses both directions:

* UF ⇒ DL (to get `f(a)=f(b)`)
* DL ⇒ UF (to get `x=y`)

---

# The actual formula

Sorts / symbols:

* `U` uninterpreted sort
* `a, b : U`
* `x, y : Int`
* `f : U → Int`
* `g : Int → U`

Assertions:

**UF side**

* (A) `a = b`
* (G) `g(x) ≠ g(y)`

**DL side**

* (X1) `x ≤ f(a)`
* (X2) `f(a) ≤ x`          ⇒ DL entails `x = f(a)`
* (Y1) `y ≤ f(b)`
* (Y2) `f(b) ≤ y`          ⇒ DL entails `y = f(b)`

Now:

* UF congruence gives `f(a)=f(b)` (because `a=b`)
* DL with `x=f(a)` and `y=f(b)` and `f(a)=f(b)` entails `x=y`
* DL exports `x=y`
* UF imports `x=y` ⇒ congruence yields `g(x)=g(y)` contradicting `g(x) ≠ g(y)`.

Without sharing:

* If UF⇒DL sharing missing: DL can’t conclude `x=y`.
* If DL⇒UF sharing missing: UF can’t use `x=y` to refute diseq.
  So SAT.

With both: UNSAT.

---

# Demo code (pseudo-Rust)

### `crates/smt-demo/src/ping_pong.rs`

```rust
use std::sync::Arc;
use smt_api::{Session, CheckSat};

fn main() -> smt_core::Result<()> {
    let ctx = Arc::new(smt_core::Context::default());
    let mut sess = build_session_with_uf_and_dl(ctx.clone());

    let u = sess.declare_uninterpreted_sort("U");
    let int = sess.ctx().int_sort();

    let a = sess.declare_const("a", u);
    let b = sess.declare_const("b", u);

    let x = sess.declare_const("x", int);
    let y = sess.declare_const("y", int);

    // f: U -> Int, g: Int -> U
    let f = sess.declare_ufun("f");
    let g = sess.declare_ufun("g");

    let fa = sess.app_uf(f, &[a], int)?;
    let fb = sess.app_uf(f, &[b], int)?;

    let gx = sess.app_uf(g, &[x], u)?;
    let gy = sess.app_uf(g, &[y], u)?;

    // (A) a = b
    sess.assert(sess.eq(a, b)?, Some("A_EQ_B"))?;

    // DL: x = f(a)
    sess.assert(sess.ctx().le(x, fa)?, Some("X_LE_FA"))?;
    sess.assert(sess.ctx().le(fa, x)?, Some("FA_LE_X"))?;

    // DL: y = f(b)
    sess.assert(sess.ctx().le(y, fb)?, Some("Y_LE_FB"))?;
    sess.assert(sess.ctx().le(fb, y)?, Some("FB_LE_Y"))?;

    // (G) g(x) != g(y)
    sess.assert(sess.not(sess.eq(gx, gy)?)?, Some("GX_NE_GY"))?;

    match sess.check_sat() {
        CheckSat::Sat => {
            println!("SAT (BUG: ping-pong sharing not fully working)");
        }
        CheckSat::Unsat => {
            println!("UNSAT (expected)");
            println!("core: {:?}", sess.get_unsat_core());
        }
    }

    Ok(())
}
```

**Expected UNSAT core** contains a subset of:

* `A_EQ_B`
* `X_LE_FA`, `FA_LE_X`
* `Y_LE_FB`, `FB_LE_Y`
* `GX_NE_GY`

Sometimes a solver may include only one of each equality pair depending on how DL propagates; that’s fine.

---

# Two key wiring details for this to work

## 1) Shared-term detection must include:

* `f(a)`, `f(b)` (Int UF apps)
* `x`, `y` (Int vars, because they appear as args to `g(x), g(y)` UF apps)
* `g(x)`, `g(y)` too (U UF apps) but less important

So update UF `atom_endpoints` to include UF app arguments (as described in the previous message). That makes `x,y` shared with DL.

## 2) UF export must include congruence equalities between shared UF apps

So UF exports `f(a)=f(b)` when `a=b` is asserted.

That’s the UF⇒DL hop.

---

# Quick sanity matrix

| Sharing enabled? | Result                                       |
| ---------------- | -------------------------------------------- |
| none             | SAT                                          |
| UF⇒DL only       | SAT (DL can derive x=y but UF never gets it) |
| DL⇒UF only       | SAT (DL can’t derive x=y without f(a)=f(b))  |
| both             | UNSAT                                        |

This is exactly what you want for CI to detect regressions.

---

If you want, I can also show how to turn these three demos into **unit tests** that assert:

* `check_sat == Unsat`
* core contains at least certain labels
* toggling equality-sharing feature flags yields the SAT/UNSAT matrix above.
