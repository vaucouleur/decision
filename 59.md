Here’s the **compact one-liner-ish** style using the prelude. It keeps each matrix row short while still asserting:

* SAT/UNSAT (with bundle-on-mismatch)
* trace directions (positive + negative)
* optionally core requirements on UNSAT rows

I’ll show ping-pong (the most interesting) in this compact style; the other two follow the same pattern.

---

# `crates/smt-tests/src/equality_sharing_golden_compact.rs`

```rust
#![forbid(unsafe_code)]

use crate::prelude::*;

mod common;
use common::make_session;

// Instance holds the key TermIds for trace assertions.
#[derive(Debug, Clone, Copy)]
struct PingPongInst {
    fa: smt_core::TermId,
    fb: smt_core::TermId,
    x: smt_core::TermId,
    y: smt_core::TermId,
}

fn setup_ping_pong(sess: &mut smt_api::Session) -> smt_core::Result<PingPongInst> {
    let u = sess.declare_uninterpreted_sort("U");
    let int = sess.ctx().int_sort();

    let a = sess.declare_const("a", u);
    let b = sess.declare_const("b", u);

    let x = sess.declare_const("x", int);
    let y = sess.declare_const("y", int);

    let f = sess.declare_ufun("f"); // U -> Int
    let g = sess.declare_ufun("g"); // Int -> U

    let fa = sess.app_uf(f, &[a], int)?;
    let fb = sess.app_uf(f, &[b], int)?;
    let gx = sess.app_uf(g, &[x], u)?;
    let gy = sess.app_uf(g, &[y], u)?;

    sess.assert(sess.eq(a, b)?, Some("A_EQ_B"))?;
    sess.assert(sess.ctx().le(x, fa)?, Some("X_LE_FA"))?;
    sess.assert(sess.ctx().le(fa, x)?, Some("FA_LE_X"))?;
    sess.assert(sess.ctx().le(y, fb)?, Some("Y_LE_FB"))?;
    sess.assert(sess.ctx().le(fb, y)?, Some("FB_LE_Y"))?;
    sess.assert(sess.not(sess.eq(gx, gy)?)?, Some("GX_NE_GY"))?;

    Ok(PingPongInst { fa, fb, x, y })
}

/// Run a case (build session, setup, check) and return (result, events, inst).
fn run_ping_pong(cfg: SharingConfig) -> smt_core::Result<(CheckSat, Vec<smt_engine::eqshare_trace::EqShareEvent>, PingPongInst)> {
    let mut sess = make_session(cfg);
    let inst = setup_ping_pong(&mut sess)?;
    let res = sess.check_sat();
    let events = sess.take_eqshare_events();
    Ok((res, events, inst))
}

#[test]
fn golden_ping_pong_matrix_compact() -> smt_core::Result<()> {
    // (0) both off => SAT + no events
    {
        let (res, events, _) = run_ping_pong(SharingConfig { uf_to_dl: false, dl_to_uf: false })?;
        assert_eq!(res, CheckSat::Sat);
        assert_eqshare_events_empty!(&events);
    }

    // (1) UF->DL only => SAT + no DL->UF direction
    {
        let (res, events, inst) = run_ping_pong(SharingConfig { uf_to_dl: true, dl_to_uf: false })?;
        assert_eq!(res, CheckSat::Sat);
        assert_eqshare_dir_none!(&events, DL => UF);
        // UF->DL may or may not happen depending on your export throttling; don't over-assert here.
        assert_eqshare_hop_none!(&events, DL => UF, [(inst.x, inst.y)]);
    }

    // (2) DL->UF only => SAT + no UF->DL direction
    {
        let (res, events, inst) = run_ping_pong(SharingConfig { uf_to_dl: false, dl_to_uf: true })?;
        assert_eq!(res, CheckSat::Sat);
        assert_eqshare_dir_none!(&events, UF => DL);
        assert_eqshare_hop_none!(&events, UF => DL, [(inst.fa, inst.fb)]);
    }

    // (3) both on => UNSAT + both hops + core shape
    {
        // SAT/UNSAT with bundle on mismatch (auto-rerun with debug if broken)
        assert_sat_with_bundle_on_mismatch(
            || make_session(SharingConfig { uf_to_dl: true, dl_to_uf: true }),
            |s| { setup_ping_pong(s).map(|_| ()) },
            Expect::Unsat,
        )?;

        // Core: not too brittle, just essential groups
        assert_unsat_core_contains_any(
            || make_session(SharingConfig { uf_to_dl: true, dl_to_uf: true }),
            |s| { setup_ping_pong(s).map(|_| ()) },
            &[
                CoreReq { name: "UF diseq", any_of: &["GX_NE_GY"] },
                CoreReq { name: "UF a=b", any_of: &["A_EQ_B"] },
                CoreReq { name: "some DL equality constraints", any_of: &["X_LE_FA", "FA_LE_X", "Y_LE_FB", "FB_LE_Y"] },
            ],
        )?;

        // Trace: exact hops
        let (res, events, inst) = run_ping_pong(SharingConfig { uf_to_dl: true, dl_to_uf: true })?;
        assert_eq!(res, CheckSat::Unsat);

        assert_eqshare_dir!(&events, UF => DL);
        assert_eqshare_dir!(&events, DL => UF);
        assert_eqshare_hop!(&events, UF => DL, inst.fa, inst.fb);
        assert_eqshare_hop!(&events, DL => UF, inst.x, inst.y);
    }

    Ok(())
}
```

---

## Why this style is nice

* Each row is “setup → check → a couple of asserts”
* The UNSAT row includes:

  * bundle-on-mismatch safety net
  * core requirements
  * exact trace hop checks

You can copy the same pattern for UF→DL and DL→UF tests (swap setup + which hop is forbidden/required).

If you want, I can rewrite the other two golden tests in this same compact style too (UF→DL and DL→UF) so you have a uniform trio.
