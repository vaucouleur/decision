Below is a clean “capability” pattern for **equality sharing** with **no downcasting**, plus concrete, implementable `export_equalities/import_equality` for **UF** and **DL**, including a **shared-term filter**.

I’ll show:

1. the capability trait (`EqualitySharing`) and how `Theory` exposes it
2. engine integration loop (broadcast equalities to fixpoint)
3. UF implementation on top of `UfCc`
4. DL implementation on top of the explained shortest-path closure
5. a shared-term filter that is simple and effective

---

# 1) Capability pattern: `Theory::equality_sharing_mut()`

### `crates/smt-engine/src/theory.rs`

```rust
use smt_core::TermId;
use smt_sat::Lit;

#[derive(Debug, Clone)]
pub struct TheoryPropagation {
    pub implied: Lit,
    pub explain: Vec<Lit>,
}

#[derive(Debug, Clone)]
pub struct TheoryConflict {
    pub explain: Vec<Lit>,
}

/// A derived equality between theory terms, justified by SAT literals.
#[derive(Debug, Clone)]
pub struct SharedEq {
    pub a: TermId,
    pub b: TermId,
    pub explain: Vec<Lit>,
}

pub trait EqualitySharing {
    /// Export equalities that the theory currently entails, restricted to terms in `shared`.
    fn export_equalities(&mut self, shared: &hashbrown::HashSet<TermId, core::hash::BuildHasherDefault<rustc_hash::FxHasher>>)
        -> Vec<SharedEq>;

    /// Import a derived equality from another theory.
    fn import_equality(&mut self, eq: SharedEq);
}

pub trait Theory {
    fn name(&self) -> &'static str;

    fn push_scope(&mut self);
    fn pop_scope(&mut self, n: usize);

    fn push_level(&mut self);
    fn pop_levels(&mut self, n: usize);

    fn on_atom_assigned(&mut self, atom_term: TermId, value: bool);
    fn propagate(&mut self) -> Result<Vec<TheoryPropagation>, TheoryConflict>;

    /// Capability hook (default: no equality sharing).
    fn equality_sharing_mut(&mut self) -> Option<&mut dyn EqualitySharing> {
        None
    }

    /// For shared-term detection: return the “endpoint terms” of an atom owned by this theory.
    /// (Engine uses it to compute the shared set.)
    fn atom_endpoints(&self, _atom_term: TermId) -> Vec<TermId> {
        Vec::new()
    }
}
```

No downcast. Each theory that supports equality sharing overrides `equality_sharing_mut()`.

---

# 2) Engine: compute shared terms + broadcast equalities to fixpoint

## 2.1 Shared term computation

### `crates/smt-engine/src/engine_shared.rs` (helper)

```rust
use hashbrown::{HashMap, HashSet};
use rustc_hash::FxHasher;
use core::hash::BuildHasherDefault;

use smt_core::TermId;

use crate::theory::Theory;

type FxBuild = BuildHasherDefault<FxHasher>;

/// Compute a set of terms that appear in atoms of >=2 different theories.
pub fn compute_shared_terms(
    atoms: &crate::atoms::AtomTable,
    theories: &mut [Box<dyn Theory>],
) -> HashSet<TermId, FxBuild> {
    // term -> bitmask of owners (up to 32 theories). For >32, use a small Vec<TheoryId>.
    let mut owners: HashMap<TermId, u32, FxBuild> = HashMap::default();

    for atom in atoms.iter_atoms() {
        let th_idx = atom.theory.0;
        let endpoints = theories[th_idx].atom_endpoints(atom.term);
        let bit = 1u32 << (th_idx.min(31) as u32);

        for t in endpoints {
            owners.entry(t).and_modify(|m| *m |= bit).or_insert(bit);
        }
    }

    let mut shared = HashSet::default();
    for (t, mask) in owners {
        if mask.count_ones() >= 2 {
            shared.insert(t);
        }
    }
    shared
}
```

This is simple and works well early on.

## 2.2 Equality-sharing loop

In your engine’s solve loop, after your normal theory propagation fixpoint, add:

```rust
fn equality_sharing_fixpoint(&mut self) {
    use crate::theory::EqualitySharing;

    // Compute shared once per outer iteration; you can recompute occasionally if atoms grow.
    let shared = crate::engine_shared::compute_shared_terms(&self.atoms, &mut self.theories);

    loop {
        let mut any = false;

        // 1) Collect exported eqs
        let mut exported = Vec::new();
        for th in self.theories.iter_mut() {
            if let Some(sh) = th.equality_sharing_mut() {
                exported.extend(sh.export_equalities(&shared));
            }
        }

        if exported.is_empty() {
            break;
        }

        // 2) Broadcast
        for eq in exported {
            for th in self.theories.iter_mut() {
                if let Some(sh) = th.equality_sharing_mut() {
                    sh.import_equality(eq.clone());
                    any = true;
                }
            }
        }

        if !any {
            break;
        }

        // 3) After importing, theories may now propagate/conflict; engine loop will handle it.
        // Here we just continue; the caller should run another theory fixpoint + SAT propagate.
        break;
    }
}
```

Then in the main `solve()` loop:

* run `theory_fixpoint()`
* call `equality_sharing_fixpoint()`
* run `theory_fixpoint()` again (because imports can cause new propagations/conflicts)

A typical structure:

```rust
loop {
  sat.propagate(); notify; theory_fixpoint();
  equality_sharing_fixpoint();
  sat.propagate(); notify; theory_fixpoint();
  decide...
}
```

---

# 3) UF: export/import equalities

UF can export equalities between terms that are in the shared set and currently merged.

### `crates/smt-engine/src/theories/uf_theory_inc.rs` additions

#### 3.1 Add `atom_endpoints`

Inside `impl Theory for UfTheoryInc`:

```rust
fn atom_endpoints(&self, atom_term: TermId) -> Vec<TermId> {
    if let Some(a) = self.atoms.get(&atom_term) {
        vec![a.lhs, a.rhs]
    } else {
        Vec::new()
    }
}
```

#### 3.2 Implement `EqualitySharing` via the capability hook

Add:

```rust
use crate::theory::{EqualitySharing, SharedEq};

impl crate::theory::Theory for UfTheoryInc {
    // ... existing methods ...

    fn equality_sharing_mut(&mut self) -> Option<&mut dyn EqualitySharing> {
        Some(self)
    }
}

impl EqualitySharing for UfTheoryInc {
    fn export_equalities(
        &mut self,
        shared: &hashbrown::HashSet<TermId, core::hash::BuildHasherDefault<rustc_hash::FxHasher>>,
    ) -> Vec<SharedEq> {
        // Strategy: export equalities that are already known as UF atoms, but currently
        // unassigned and entailed; and only if both endpoints are shared.
        //
        // This is *minimal* and avoids enumerating all pairs in an e-class.

        let mut out = Vec::new();
        for (_term, atom) in self.atoms.iter_mut() {
            if atom.value == Some(true) {
                continue;
            }
            if !shared.contains(&atom.lhs) || !shared.contains(&atom.rhs) {
                continue;
            }
            if self.uf_entails_eq(atom.lhs, atom.rhs) {
                let explain = self.explain_eq_lits(atom.lhs, atom.rhs);
                out.push(SharedEq { a: atom.lhs, b: atom.rhs, explain });
            }
        }
        out
    }

    fn import_equality(&mut self, eq: SharedEq) {
        // Import as a UF union with explanation.
        // Turn explain lits into a ReasonId in UfCc:
        // For now we just pick one supporting literal or build a Derived reason from atoms.
        //
        // If your UfCc uses Reason DAG: create a Derived reason containing Atom reasons.
        // Here we do a lightweight sound approach:
        let support = eq.explain.first().copied().unwrap_or_else(|| {
            // If no explanation, it's still safe to union, but it should normally not happen.
            smt_sat::Lit::pos(smt_sat::Var::from_u32(0))
        });

        // Use assert_eq_atom which expects an atom literal, not a list.
        // Better: add a new UfCc method `assert_eq_with_reason_lits(a,b,explain_lits)`.
        //
        // Minimal pragmatic:
        self.uf.assert_eq_atom(eq.a, eq.b, support);
    }
}
```

### Note (important)

For correctness with full explanations, you *should* add to `UfCc`:

```rust
pub fn assert_eq_with_reason_lits(&mut self, a: TermId, b: TermId, lits: Vec<Lit>)
```

that builds `Reason::Derived([Reason::Atom(lit), ...])` and unions with that.
But the above “pick first lit” is still **sound** if that lit alone already implies the equality; it just won’t always be true. So: **do the proper derived reason** (recommended).

Here’s the proper tiny helper inside `UfTheoryInc`:

```rust
fn import_eq_with_explain(&mut self, a: TermId, b: TermId, explain: Vec<Lit>) {
    let na = self.uf.ensure_term(a);
    let nb = self.uf.ensure_term(b);

    let kids: Vec<_> = explain.into_iter().map(|l| self.uf.mk_reason_atom(l)).collect();
    let r = self.uf.mk_reason_derived(kids);
    self.uf.union(na, nb, r);
}
```

(You’d need to expose `mk_reason_atom/mk_reason_derived/union` or provide a public helper in `UfCc`.)

---

# 4) DL: export/import equalities

DL exports `a=b` if it entails both directions with `<= 0`. Import is adding the two zero-weight edges with the same explanation.

### 4.1 Add `atom_endpoints`

Inside `impl Theory for DlTheory`:

```rust
fn atom_endpoints(&self, atom_term: TermId) -> Vec<TermId> {
    if let Some(a) = self.atoms.get(&atom_term) {
        vec![a.x, a.y]
    } else {
        Vec::new()
    }
}
```

### 4.2 Implement `EqualitySharing`

Add to `DlTheory`:

```rust
use crate::theory::{EqualitySharing, SharedEq};

impl crate::theory::Theory for DlTheory {
    // ... existing methods ...
    fn equality_sharing_mut(&mut self) -> Option<&mut dyn EqualitySharing> {
        Some(self)
    }
}

impl EqualitySharing for DlTheory {
    fn export_equalities(
        &mut self,
        shared: &hashbrown::HashSet<TermId, core::hash::BuildHasherDefault<rustc_hash::FxHasher>>,
    ) -> Vec<SharedEq> {
        let (dist, pred, neg) = self.all_pairs_shortest_paths();
        if neg.is_some() {
            return Vec::new(); // conflicts handled by propagate()
        }

        let mut out = Vec::new();

        // Export equalities only for terms that are explicitly shared.
        // For toy: check all pairs of shared nodes (O(m^2)).
        let shared_nodes: Vec<_> = self.nodes.iter().copied().filter(|t| shared.contains(t)).collect();

        for i in 0..shared_nodes.len() {
            for j in (i + 1)..shared_nodes.len() {
                let a = shared_nodes[i];
                let b = shared_nodes[j];

                let na = self.node(a);
                let nb = self.node(b);

                let ab = dist[na.0 as usize][nb.0 as usize];
                let ba = dist[nb.0 as usize][na.0 as usize];

                if ab.map_or(false, |d| d <= 0) && ba.map_or(false, |d| d <= 0) {
                    let mut explain = self.reconstruct_path_lits(&pred, na, nb);
                    let explain2 = self.reconstruct_path_lits(&pred, nb, na);
                    explain.extend(explain2);

                    // Dedup
                    explain.sort();
                    explain.dedup();

                    out.push(SharedEq { a, b, explain });
                }
            }
        }

        out
    }

    fn import_equality(&mut self, eq: SharedEq) {
        // DL import equality as two 0-weight edges.
        // Use a stable "support literal" (first in explain) for each edge;
        // better: create a synthetic lemma literal, but this is fine if explain is non-empty.
        let support = eq.explain.first().copied().unwrap_or_else(|| smt_sat::Lit::pos(smt_sat::Var::from_u32(0)));

        self.add_edge(eq.b, eq.a, 0, support);
        self.add_edge(eq.a, eq.b, 0, support);
    }
}
```

Again: for fully sound import explanations, you’d want your DL edges to carry *all* explain lits (or a `ReasonId` DAG like UF does). The “support=first lit” is a pragmatic shortcut but weak. Better is:

* store `Edge.why: ReasonId` where `ReasonId` expands to `Vec<Lit>`
* then propagation/conflict reconstruction collects `ReasonId`s and expands/dedups
  That aligns DL with UF’s reason DAG.

---

# 5) Engine call order for combination (important)

Inside your solve loop:

1. SAT propagate (kernel may backjump)
2. sync levels, notify theories
3. theory propagate-to-fixpoint (lemmas permanent)
4. **equality sharing round** (export/import)
5. SAT propagate again
6. back to step 2/3 until stable
7. decide if needed

That ensures imported equalities influence SAT/theories before making a new decision.

---

# 6) One “beautiful architecture” polish: unify explanations across theories

If you want this to feel like a real solver, do this:

* define a `ReasonArena` in the engine (global per solve)
* theories store `ReasonId` handles instead of `Vec<Lit>`
* engine expands to `Vec<Lit>` only when turning into SAT clauses

This removes duplication and makes equality-sharing imports have exact explanations cheaply.

---

If you say **yes** again, I’ll show a minimal `ReasonArena` design that both UF and DL can use (shared across theories), plus the tiny API changes needed so your engine can store and expand reasons uniformly (and so DL’s imported equalities stay fully sound without hacks like “first literal only”).
