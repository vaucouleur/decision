Here’s the clean **drain / take** pattern so tests can do:

* `let events = sess.take_eqshare_events();`
* assert on just the events produced by this `check_sat()`

No accumulation across multiple runs.

---

## 1) Add `take()` to `EqShareTrace`

### `crates/smt-engine/src/eqshare_trace.rs`

```rust
impl EqShareTrace {
    /// Drain all recorded equality-sharing events and return them.
    pub fn take(&mut self) -> Vec<EqShareEvent> {
        std::mem::take(&mut self.events)
    }
}
```

---

## 2) Engine: expose a mutable “take trace” method (feature-gated)

### `crates/smt-engine/src/engine_debug.rs`

```rust
impl<K: crate::sat_iface::SatKernel> crate::engine::SmtEngine<K> {
    /// Drain eq-sharing trace events (test/debug only).
    #[cfg(feature = "test-debug")]
    pub fn take_eqshare_events(&mut self) -> Vec<crate::eqshare_trace::EqShareEvent> {
        self.eqshare_trace.take()
    }

    #[cfg(not(feature = "test-debug"))]
    pub fn take_eqshare_events(&mut self) -> Vec<crate::eqshare_trace::EqShareEvent> {
        Vec::new()
    }
}
```

(If you’d rather not compile this in non-test builds, keep it behind the `test-debug` feature only.)

---

## 3) Session: forward `take_eqshare_events()`

### `crates/smt-api/src/session.rs`

```rust
impl Session {
    /// Drain and return equality-sharing events recorded during the last solve steps.
    ///
    /// Useful for tests: call this right after `check_sat()`.
    pub fn take_eqshare_events(&mut self) -> Vec<smt_engine::eqshare_trace::EqShareEvent> {
        self.engine.take_eqshare_events()
    }
}
```

This requires `Session` to own the engine mutably (typical). If your `check_sat()` takes `&mut self`, you can call this right after.

---

## 4) Record events “always in tests” (but don’t leak into prod)

In `equality_sharing_round()`, keep recording behind feature:

```rust
#[cfg(feature = "test-debug")]
{
    self.eqshare_trace.push(EqShareEvent { /* ... */ });
}
```

This is cheap and isolated.

---

## 5) Example usage in a test (no accumulation)

```rust
#[test]
fn ping_pong_trace_has_both_hops() -> smt_core::Result<()> {
    let mut sess = common::make_session(SharingConfig { uf_to_dl: true, dl_to_uf: true });
    let inst = setup_ping_pong_instance(&mut sess)?;

    assert_eq!(sess.check_sat(), CheckSat::Unsat);

    let events = sess.take_eqshare_events();
    assert!(!events.is_empty(), "expected some eqshare events");

    // Now assert on `events` only (no older ones).
    // ...
    Ok(())
}
```

---

## 6) Optional: auto-clear trace at start of `check_sat()`

Even with `take()`, you might prefer the engine to clear trace at the start of `check_sat()` so it’s always “per check”. You can do:

* in `Session::check_sat()` before solve loop:

  * `self.engine.take_eqshare_events();` (discard)

But I like the explicit drain in tests.

---

If you want, I can also show a tiny macro like `assert_eqshare_hop!(events, UF=>DL, fa, fb)` that makes the trace tests very readable.
