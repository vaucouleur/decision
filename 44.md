Here’s a clean way to enable the UNSAT debug bundle **only for the three matrix tests**, without slowing down normal test runs:

* a tiny helper `debug_enabled_for_current_test()` that reads `SMT_EQSHARE_DEBUG_FILTER`
* the test harness sets that env var for just those tests (via `cargo test ...` invocation or a wrapper script)
* engine checks the helper once per `Session` / `SmtEngine` creation and sets `config.debug_eq.enabled`

This avoids global always-on debug and keeps CI fast.

---

## 1) Filter helper: enable debug for matching test names

### `crates/smt-tests/src/debug_filter.rs`

```rust
#![forbid(unsafe_code)]

/// Returns true if SMT debug should be enabled for the current test process.
///
/// Usage:
///   SMT_EQSHARE_DEBUG_FILTER=ping_pong,uf_to_dl,dl_to_uf cargo test -p smt-tests -- --nocapture
///
/// If the filter is unset, returns false (debug disabled).
pub fn debug_enabled_for_current_test() -> bool {
    let Ok(filter) = std::env::var("SMT_EQSHARE_DEBUG_FILTER") else {
        return false;
    };
    if filter.trim().is_empty() {
        return false;
    }

    // Rust tests don't provide a standard "current test name" to the process.
    // So we use a pragmatic approach:
    // - either run a single test by name (cargo test <name>),
    // - or set filter to "always".
    //
    // If filter contains "always", enable unconditionally.
    if filter.split(',').any(|s| s.trim() == "always") {
        return true;
    }

    // Otherwise, enable only when the command-line args include any of the filter tokens.
    // This works because `cargo test foo` includes "foo" in argv.
    let args: Vec<String> = std::env::args().collect();
    for token in filter.split(',').map(|s| s.trim()).filter(|s| !s.is_empty()) {
        if args.iter().any(|a| a.contains(token)) {
            return true;
        }
    }
    false
}
```

Why this works:

* When you run `cargo test ping_pong_regression_matrix`, that string appears in argv.
* So you can match on substrings.

---

## 2) Use the filter in `make_session(...)`

### `crates/smt-tests/src/common.rs` (builder patch)

```rust
mod debug_filter;

pub fn make_session(sharing: SharingConfig) -> Session {
    // ... build engine as before ...

    let mut eng = SmtEngine::new(sat, atoms, vec![Box::new(uf), Box::new(dl)]);
    eng.sharing = sharing;

    // Enable debug only if the filter matches this test invocation.
    if debug_filter::debug_enabled_for_current_test() {
        eng.config.debug_eq.enabled = true;
        eng.config.debug_eq.max_reason_lits = 16;
    }

    // ...
    Session::new(ctx, eng, classifier)
}
```

Now debug is controlled purely by env + invocation name.

---

## 3) A minimal wrapper script for local use

### `scripts/test-eqshare-debug.sh`

```bash
#!/usr/bin/env bash
set -euo pipefail

export SMT_EQSHARE_DEBUG_FILTER="uf_to_dl_regression_matrix,dl_to_uf_regression_matrix,ping_pong_regression_matrix"

cargo test -p smt-tests \
  uf_to_dl_regression_matrix \
  dl_to_uf_regression_matrix \
  ping_pong_regression_matrix \
  -- --nocapture
```

This will:

* run only the three tests
* enable debug only for those (argv contains the names)
* emit / write the debug bundle on UNSAT (as per your engine hook)

---

## 4) CI usage (GitHub Actions pattern)

* Run normal test suite with debug disabled.
* If the job fails, rerun only the three tests with debug enabled and upload artifacts:

Pseudo-steps:

1. `cargo test -p smt-tests` (no env)
2. on failure:

   * `SMT_EQSHARE_DEBUG_FILTER=always cargo test -p smt-tests ping_pong_regression_matrix -- --nocapture`
   * upload `target/smt-debug*`

(You can also just set filter to those three names.)

---

## 5) Bonus: avoid overwriting bundles in parallel

In your UNSAT bundle writer, use PID-based folder names:

```rust
let pid = std::process::id();
let dir = Path::new("target").join(format!("smt-debug-{}", pid));
```

Then each test process writes to its own folder.

---

If you want, I can also show a tiny `#[test]`-local “enable debug” guard that flips a global atomic just for that test (works even when running the whole suite), but the env+argv filter is usually the simplest and most reliable with `cargo test`.
